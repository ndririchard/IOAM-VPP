From 08687ab75afff109bd2a329379acb398c0efa593 Mon Sep 17 00:00:00 2001
From: ndririchard <ndririchard@outlook.com>
Date: Wed, 31 Aug 2022 00:27:50 +0200
Subject: [PATCH] first test1

---
 ioam/CMakeLists.txt                           | 107 ---
 ioam/analyse/ioam_analyse.h                   | 507 ----------
 ioam/analyse/ioam_summary_export.c            | 445 ---------
 ioam/analyse/ioam_summary_export.h            |  86 --
 ioam/analyse/ip6/ip6_ioam_analyse.c           | 164 ----
 ioam/analyse/ip6/ip6_ioam_analyse.h           | 127 ---
 ioam/analyse/ip6/node.c                       | 518 ----------
 ioam/dir.dox                                  |  18 -
 ioam/encap/ip6_ioam_e2e.c                     | 213 ----
 ioam/encap/ip6_ioam_e2e.h                     |  64 --
 ioam/encap/ip6_ioam_pot.c                     | 263 -----
 ioam/encap/ip6_ioam_pot.h                     |  40 -
 ioam/encap/ip6_ioam_seqno.c                   |  75 --
 ioam/encap/ip6_ioam_seqno.h                   |  30 -
 ioam/encap/ip6_ioam_trace.c                   | 730 --------------
 ioam/encap/ip6_ioam_trace.h                   |  63 --
 ioam/export-common/ioam_export.h              | 635 ------------
 .../vxlan_gpe_ioam_export.api                 |  37 -
 ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.c | 200 ----
 .../vxlan_gpe_ioam_export_test.c              |  82 --
 .../vxlan_gpe_ioam_export_thread.c            |  51 -
 ioam/export-vxlan-gpe/vxlan_gpe_node.c        | 170 ----
 ioam/export/ioam_export.api                   |  37 -
 ioam/export/ioam_export.c                     | 182 ----
 ioam/export/ioam_export_test.c                |  74 --
 ioam/export/ioam_export_thread.c              |  40 -
 ioam/export/node.c                            | 168 ----
 ioam/ioam_plugin_doc.rst                      | 490 ----------
 ioam/ioam_test.c                              |  67 --
 ioam/ip6/ioam_cache.api                       |  30 -
 ioam/ip6/ioam_cache.c                         | 354 -------
 ioam/ip6/ioam_cache.h                         | 909 ------------------
 ioam/ip6/ioam_cache_node.c                    | 415 --------
 ioam/ip6/ioam_cache_tunnel_select_node.c      | 768 ---------------
 ioam/ipfixcollector/ipfixcollector.c          | 107 ---
 ioam/ipfixcollector/ipfixcollector.h          | 124 ---
 ioam/ipfixcollector/node.c                    | 300 ------
 ioam/lib-e2e/e2e_util.h                       |  37 -
 ioam/lib-e2e/ioam_seqno_lib.c                 |  84 --
 ioam/lib-e2e/ioam_seqno_lib.h                 | 202 ----
 ioam/lib-pot/math64.h                         | 159 ---
 ioam/lib-pot/pot.api                          | 100 --
 ioam/lib-pot/pot_api.c                        | 166 ----
 ioam/lib-pot/pot_test.c                       | 197 ----
 ioam/lib-pot/pot_util.c                       | 445 ---------
 ioam/lib-pot/pot_util.h                       | 195 ----
 ioam/lib-trace/trace.api                      |  87 --
 ioam/lib-trace/trace_api.c                    | 151 ---
 ioam/lib-trace/trace_config.h                 |  41 -
 ioam/lib-trace/trace_test.c                   | 128 ---
 ioam/lib-trace/trace_util.c                   | 445 ---------
 ioam/lib-trace/trace_util.h                   | 447 ---------
 ioam/lib-vxlan-gpe/ioam_decap.c               | 223 -----
 ioam/lib-vxlan-gpe/ioam_encap.c               | 194 ----
 ioam/lib-vxlan-gpe/ioam_pop.c                 | 353 -------
 ioam/lib-vxlan-gpe/ioam_transit.c             | 187 ----
 ioam/lib-vxlan-gpe/ioam_vxlan_gpe.api         | 109 ---
 ioam/lib-vxlan-gpe/vxlan_gpe_api.c            | 254 -----
 ioam/lib-vxlan-gpe/vxlan_gpe_ioam.c           | 765 ---------------
 ioam/lib-vxlan-gpe/vxlan_gpe_ioam.h           | 178 ----
 ioam/lib-vxlan-gpe/vxlan_gpe_ioam_packet.h    |  61 --
 ioam/lib-vxlan-gpe/vxlan_gpe_ioam_trace.c     | 546 -----------
 ioam/lib-vxlan-gpe/vxlan_gpe_ioam_util.h      | 172 ----
 ioam/lib-vxlan-gpe/vxlan_gpe_test.c           | 347 -------
 ioam/udp-ping/udp_ping.api                    |  56 --
 ioam/udp-ping/udp_ping.h                      | 141 ---
 ioam/udp-ping/udp_ping_api.c                  |  99 --
 ioam/udp-ping/udp_ping_export.c               | 310 ------
 ioam/udp-ping/udp_ping_node.c                 | 844 ----------------
 ioam/udp-ping/udp_ping_packet.h               | 154 ---
 ioam/udp-ping/udp_ping_test.c                 | 135 ---
 ioam/udp-ping/udp_ping_util.c                 | 331 -------
 ioam/udp-ping/udp_ping_util.h                 |  83 --
 updates/crypto/aes256/aes256.c                | 415 --------
 updates/crypto/aes256/aes256.h                |  34 -
 updates/crypto/keys/keys.c                    |  19 -
 updates/crypto/keys/keys.h                    |  11 -
 updates/crypto/keys/test                      | Bin 17648 -> 0 bytes
 updates/crypto/keys/test.c                    |   6 -
 updates/crypto/sha256/sha256.c                | 141 ---
 updates/crypto/sha256/sha256.h                |  24 -
 updates/crypto/test/test_sha256.c             |  48 -
 updates/crypto/utility/convert.c              |  49 -
 updates/crypto/utility/convert.h              |  15 -
 updates/trace_integrity/trace_integrity.c     |  47 -
 updates/trace_integrity/trace_integrity.h     |  25 -
 vpp                                           |   2 +-
 87 files changed, 1 insertion(+), 17951 deletions(-)
 delete mode 100644 ioam/CMakeLists.txt
 delete mode 100644 ioam/analyse/ioam_analyse.h
 delete mode 100644 ioam/analyse/ioam_summary_export.c
 delete mode 100644 ioam/analyse/ioam_summary_export.h
 delete mode 100644 ioam/analyse/ip6/ip6_ioam_analyse.c
 delete mode 100644 ioam/analyse/ip6/ip6_ioam_analyse.h
 delete mode 100644 ioam/analyse/ip6/node.c
 delete mode 100644 ioam/dir.dox
 delete mode 100644 ioam/encap/ip6_ioam_e2e.c
 delete mode 100644 ioam/encap/ip6_ioam_e2e.h
 delete mode 100644 ioam/encap/ip6_ioam_pot.c
 delete mode 100644 ioam/encap/ip6_ioam_pot.h
 delete mode 100644 ioam/encap/ip6_ioam_seqno.c
 delete mode 100644 ioam/encap/ip6_ioam_seqno.h
 delete mode 100644 ioam/encap/ip6_ioam_trace.c
 delete mode 100644 ioam/encap/ip6_ioam_trace.h
 delete mode 100644 ioam/export-common/ioam_export.h
 delete mode 100644 ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.api
 delete mode 100644 ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.c
 delete mode 100644 ioam/export-vxlan-gpe/vxlan_gpe_ioam_export_test.c
 delete mode 100644 ioam/export-vxlan-gpe/vxlan_gpe_ioam_export_thread.c
 delete mode 100644 ioam/export-vxlan-gpe/vxlan_gpe_node.c
 delete mode 100644 ioam/export/ioam_export.api
 delete mode 100644 ioam/export/ioam_export.c
 delete mode 100644 ioam/export/ioam_export_test.c
 delete mode 100644 ioam/export/ioam_export_thread.c
 delete mode 100644 ioam/export/node.c
 delete mode 100644 ioam/ioam_plugin_doc.rst
 delete mode 100644 ioam/ioam_test.c
 delete mode 100644 ioam/ip6/ioam_cache.api
 delete mode 100644 ioam/ip6/ioam_cache.c
 delete mode 100644 ioam/ip6/ioam_cache.h
 delete mode 100644 ioam/ip6/ioam_cache_node.c
 delete mode 100644 ioam/ip6/ioam_cache_tunnel_select_node.c
 delete mode 100644 ioam/ipfixcollector/ipfixcollector.c
 delete mode 100644 ioam/ipfixcollector/ipfixcollector.h
 delete mode 100644 ioam/ipfixcollector/node.c
 delete mode 100644 ioam/lib-e2e/e2e_util.h
 delete mode 100644 ioam/lib-e2e/ioam_seqno_lib.c
 delete mode 100644 ioam/lib-e2e/ioam_seqno_lib.h
 delete mode 100644 ioam/lib-pot/math64.h
 delete mode 100644 ioam/lib-pot/pot.api
 delete mode 100644 ioam/lib-pot/pot_api.c
 delete mode 100644 ioam/lib-pot/pot_test.c
 delete mode 100644 ioam/lib-pot/pot_util.c
 delete mode 100644 ioam/lib-pot/pot_util.h
 delete mode 100644 ioam/lib-trace/trace.api
 delete mode 100644 ioam/lib-trace/trace_api.c
 delete mode 100644 ioam/lib-trace/trace_config.h
 delete mode 100644 ioam/lib-trace/trace_test.c
 delete mode 100644 ioam/lib-trace/trace_util.c
 delete mode 100644 ioam/lib-trace/trace_util.h
 delete mode 100644 ioam/lib-vxlan-gpe/ioam_decap.c
 delete mode 100644 ioam/lib-vxlan-gpe/ioam_encap.c
 delete mode 100644 ioam/lib-vxlan-gpe/ioam_pop.c
 delete mode 100644 ioam/lib-vxlan-gpe/ioam_transit.c
 delete mode 100644 ioam/lib-vxlan-gpe/ioam_vxlan_gpe.api
 delete mode 100644 ioam/lib-vxlan-gpe/vxlan_gpe_api.c
 delete mode 100644 ioam/lib-vxlan-gpe/vxlan_gpe_ioam.c
 delete mode 100644 ioam/lib-vxlan-gpe/vxlan_gpe_ioam.h
 delete mode 100644 ioam/lib-vxlan-gpe/vxlan_gpe_ioam_packet.h
 delete mode 100644 ioam/lib-vxlan-gpe/vxlan_gpe_ioam_trace.c
 delete mode 100644 ioam/lib-vxlan-gpe/vxlan_gpe_ioam_util.h
 delete mode 100644 ioam/lib-vxlan-gpe/vxlan_gpe_test.c
 delete mode 100644 ioam/udp-ping/udp_ping.api
 delete mode 100644 ioam/udp-ping/udp_ping.h
 delete mode 100644 ioam/udp-ping/udp_ping_api.c
 delete mode 100644 ioam/udp-ping/udp_ping_export.c
 delete mode 100644 ioam/udp-ping/udp_ping_node.c
 delete mode 100644 ioam/udp-ping/udp_ping_packet.h
 delete mode 100644 ioam/udp-ping/udp_ping_test.c
 delete mode 100644 ioam/udp-ping/udp_ping_util.c
 delete mode 100644 ioam/udp-ping/udp_ping_util.h
 delete mode 100644 updates/crypto/aes256/aes256.c
 delete mode 100644 updates/crypto/aes256/aes256.h
 delete mode 100644 updates/crypto/keys/keys.c
 delete mode 100644 updates/crypto/keys/keys.h
 delete mode 100644 updates/crypto/keys/test
 delete mode 100644 updates/crypto/keys/test.c
 delete mode 100644 updates/crypto/sha256/sha256.c
 delete mode 100644 updates/crypto/sha256/sha256.h
 delete mode 100644 updates/crypto/test/test_sha256.c
 delete mode 100644 updates/crypto/utility/convert.c
 delete mode 100644 updates/crypto/utility/convert.h
 delete mode 100644 updates/trace_integrity/trace_integrity.c
 delete mode 100644 updates/trace_integrity/trace_integrity.h

diff --git a/ioam/CMakeLists.txt b/ioam/CMakeLists.txt
deleted file mode 100644
index d2a78c7..0000000
--- a/ioam/CMakeLists.txt
+++ /dev/null
@@ -1,107 +0,0 @@
-# Copyright (c) 2018 Cisco and/or its affiliates.
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at:
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-add_vpp_plugin(ioam
-  SOURCES
-  # iOAM Proof of Transit
-  lib-pot/pot_util.c
-  encap/ip6_ioam_pot.c
-  lib-pot/pot_api.c
-
-  # iOAM trace export for IPv6
-  export/ioam_export.c
-  export/node.c
-  export/ioam_export_thread.c
-
-  # iOAM Trace
-  lib-trace/trace_util.c
-  encap/ip6_ioam_trace.c
-  lib-trace/trace_api.c
-
-  # VxLAN-GPE
-  lib-vxlan-gpe/ioam_encap.c
-  lib-vxlan-gpe/ioam_decap.c
-  lib-vxlan-gpe/ioam_transit.c
-  lib-vxlan-gpe/ioam_pop.c
-  lib-vxlan-gpe/vxlan_gpe_api.c
-  lib-vxlan-gpe/vxlan_gpe_ioam_trace.c
-  lib-vxlan-gpe/vxlan_gpe_ioam.c
-  export-vxlan-gpe/vxlan_gpe_ioam_export.c
-  export-vxlan-gpe/vxlan_gpe_node.c
-  export-vxlan-gpe/vxlan_gpe_ioam_export_thread.c
-
-  # iOAM E2E
-  encap/ip6_ioam_e2e.c
-  encap/ip6_ioam_seqno.c
-  lib-e2e/ioam_seqno_lib.c
-
-  # ipfix collector
-  ipfixcollector/ipfixcollector.c
-  ipfixcollector/node.c
-
-  # iOAM Analyse
-  analyse/ip6/ip6_ioam_analyse.c
-  analyse/ip6/node.c
-  analyse/ioam_summary_export.c
-
-  # iOAM record cache and rewrite
-  ip6/ioam_cache.c
-  ip6/ioam_cache_node.c
-  ip6/ioam_cache_tunnel_select_node.c
-
-  # udp ping
-  udp-ping/udp_ping_node.c
-  udp-ping/udp_ping_util.c
-  udp-ping/udp_ping_export.c
-  udp-ping/udp_ping_api.c
-
-  MULTIARCH_SOURCES
-  ip6/ioam_cache_node.c
-  ip6/ioam_cache_tunnel_select_node.c
-
-  API_FILES
-  lib-pot/pot.api
-  export/ioam_export.api
-  lib-trace/trace.api
-  lib-vxlan-gpe/ioam_vxlan_gpe.api
-  export-vxlan-gpe/vxlan_gpe_ioam_export.api
-  ip6/ioam_cache.api
-  udp-ping/udp_ping.api
-
-  INSTALL_HEADERS
-  lib-pot/pot_util.h
-  lib-pot/math64.h
-  lib-trace/trace_util.h
-  encap/ip6_ioam_trace.h
-  lib-trace/trace_config.h
-  export-common/ioam_export.h
-  lib-vxlan-gpe/vxlan_gpe_ioam_util.h
-  lib-vxlan-gpe/vxlan_gpe_ioam_packet.h
-  lib-vxlan-gpe/vxlan_gpe_ioam.h
-  encap/ip6_ioam_e2e.h
-  encap/ip6_ioam_seqno.h
-  lib-e2e/ioam_seqno_lib.h
-  udp-ping/udp_ping_packet.h
-  udp-ping/udp_ping.h
-  udp-ping/udp_ping_util.h
-
-  API_TEST_SOURCES
-  ioam_test.c
-  lib-pot/pot_test.c
-  export/ioam_export_test.c
-  export-vxlan-gpe/vxlan_gpe_ioam_export_test.c
-  lib-trace/trace_test.c
-  lib-vxlan-gpe/vxlan_gpe_test.c
-  udp-ping/udp_ping_test.c
-)
-
diff --git a/ioam/analyse/ioam_analyse.h b/ioam/analyse/ioam_analyse.h
deleted file mode 100644
index 639d8df..0000000
--- a/ioam/analyse/ioam_analyse.h
+++ /dev/null
@@ -1,507 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef PLUGINS_IOAM_PLUGIN_IOAM_ANALYSE_IOAM_ANALYSE_H_
-#define PLUGINS_IOAM_PLUGIN_IOAM_ANALYSE_IOAM_ANALYSE_H_
-
-#include <vlib/vlib.h>
-#include <vnet/vnet.h>
-#include <vppinfra/types.h>
-#include <ioam/lib-e2e/e2e_util.h>
-#include <ioam/lib-trace/trace_util.h>
-#include <ioam/lib-trace/trace_config.h>
-#include <vppinfra/lock.h>
-
-#define IOAM_FLOW_TEMPLATE_ID    260
-#define IOAM_TRACE_MAX_NODES      10
-#define IOAM_MAX_PATHS_PER_FLOW   10
-
-typedef struct
-{
-  u16 ingress_if;
-  u16 egress_if;
-  u32 node_id;
-  u32 state_up;
-} ioam_path_map_t;
-
-/** @brief Analysed iOAM trace data.
-    @note cache aligned.
-*/
-typedef struct
-{
-  /** No of nodes in path. */
-  u8 num_nodes;
-
-  /** Data contained in trace - NodeId, TTL, Ingress & Egress Link, Timestamp. */
-  u32 trace_type;
-
-  /** Flag to indicate whether node is allocated. */
-  u8 is_free;
-
-  u8 pad[5];
-
-  /** Actual PATH flow has taken. */
-  ioam_path_map_t path[IOAM_TRACE_MAX_NODES];
-
-  /** Num of pkts in the flow going over path. */
-  u32 pkt_counter;
-
-  /** Num of bytes in the flow going over path. */
-  u32 bytes_counter;
-
-  /** Minumum Dealay for the flow. */
-  u32 min_delay;
-
-  /** Maximum Dealay for the flow. */
-  u32 max_delay;
-
-  /** Average Dealay for the flow. */
-  u32 mean_delay;
-
-  u32 reserve;
-} ioam_analyse_trace_record;
-
-typedef struct
-{
-  ioam_analyse_trace_record path_data[IOAM_MAX_PATHS_PER_FLOW];
-} ioam_analyse_trace_data;
-
-/** @brief Analysed iOAM pot data.
-    @note cache aligned.
-*/
-typedef struct
-{
-  /** Number of packets validated (passes through the service chain)
-      within the timestamps. */
-  u32 sfc_validated_count;
-
-  /** Number of packets invalidated (failed through the service chain)
-      within the timestamps. */
-  u32 sfc_invalidated_count;
-} ioam_analyse_pot_data;
-
-/** @brief Analysed iOAM data.
-    @note cache aligned.
-*/
-typedef struct ioam_analyser_data_t_
-{
-  CLIB_CACHE_LINE_ALIGN_MARK (cacheline0);
-
-  u8 is_free;
-  u8 pad[3];
-
-  /** Num of pkts sent for this flow. */
-  u32 pkt_sent;
-
-  /** Num of pkts matching this flow. */
-  u32 pkt_counter;
-
-  /** Num of bytes matching this flow. */
-  u32 bytes_counter;
-
-  /** Analysed iOAM trace data. */
-  ioam_analyse_trace_data trace_data;
-
-  /** Analysed iOAM pot data. */
-  ioam_analyse_pot_data pot_data;
-
-  /** Analysed iOAM seqno data. */
-  seqno_rx_info seqno_data;
-
-  /** Cache of previously analysed data, useful for export. */
-  struct ioam_analyser_data_t_ *chached_data_list;
-
-  /** Lock to since we use this to export the data in other thread. */
-  clib_spinlock_t writer_lock;
-} ioam_analyser_data_t;
-
-always_inline f64
-ip6_ioam_analyse_calc_delay (ioam_trace_hdr_t * trace, u16 trace_len,
-			     u8 oneway)
-{
-  u16 size_of_all_traceopts;
-  u8 size_of_traceopt_per_node;
-  u8 num_nodes;
-  u32 *start_elt, *end_elt, *uturn_elt;;
-  u32 start_time, end_time;
-  u8 done = 0;
-
-  size_of_traceopt_per_node = fetch_trace_data_size (trace_profile_find ());
-  // Unknown trace type
-  if (size_of_traceopt_per_node == 0)
-    return 0;
-  size_of_all_traceopts = trace_len;	/*ioam_trace_type,node_len_flags_remaining_len */
-
-  num_nodes = (u8) (size_of_all_traceopts / size_of_traceopt_per_node);
-  if ((num_nodes == 0) || (num_nodes <= (trace->node_len_flags_remaining_len & IOAM_REMAIN_LEN_MASK)))
-    return 0;
-
-  num_nodes -= (trace->node_len_flags_remaining_len & IOAM_REMAIN_LEN_MASK);
-
-  start_elt = trace->data_list;
-  end_elt =
-    trace->data_list +
-    (u32) ((size_of_traceopt_per_node / sizeof (u32)) * (num_nodes - 1));
-
-  if ((oneway && (trace->trace_type & IOAM_BIT_TTL_NODEID_SHORT)) || (oneway && (trace->trace_type & IOAM_BIT_TTL_NODEID_WIDE)))
-  {
-    done = 0;
-    do
-    {
-      uturn_elt = start_elt - size_of_traceopt_per_node / sizeof (u32);
-
-      if ((clib_net_to_host_u32 (*start_elt) >> 24) <=
-          (clib_net_to_host_u32 (*uturn_elt) >> 24))
-        done = 1;
-    }
-    while (!done && (start_elt = uturn_elt) != end_elt);
-  }
-  if (trace->trace_type & IOAM_BIT_TTL_NODEID_SHORT)
-  {
-    start_elt++;
-    end_elt++;
-  }
-  if (trace->trace_type & IOAM_BIT_TTL_NODEID_WIDE)
-  {
-    start_elt++;
-    end_elt++;
-  }
-  start_time = clib_net_to_host_u32 (*start_elt);
-  end_time = clib_net_to_host_u32 (*end_elt);
-
-  return (f64) (end_time - start_time);
-}
-
-always_inline void
-ip6_ioam_analyse_set_paths_down (ioam_analyser_data_t * data)
-{
-  ioam_analyse_trace_data *trace_data;
-  ioam_analyse_trace_record *trace_record;
-  ioam_path_map_t *path;
-  u8 k, i;
-
-  clib_spinlock_lock (&data->writer_lock);
-
-  trace_data = &data->trace_data;
-
-  for (i = 0; i < IOAM_MAX_PATHS_PER_FLOW; i++)
-  {
-    trace_record = trace_data->path_data + i;
-
-    if (trace_record->is_free)
-      continue;
-
-    path = trace_record->path;
-
-    for (k = 0; k < trace_record->num_nodes; k++)
-      path[k].state_up = 0;
-  }
-  clib_spinlock_unlock (&data->writer_lock);
-}
-
-always_inline void
-ip6_ioam_analyse_hbh_trace_loopback (ioam_analyser_data_t * data,
-				     ioam_trace_hdr_t * trace, u16 trace_len)
-{
-  ioam_analyse_trace_data *trace_data;
-  ioam_analyse_trace_record *trace_record;
-  ioam_path_map_t *path;
-  u8 i, j, k, num_nodes, max_nodes;
-  u8 *ptr;
-  u32 nodeid;
-  u16 ingress_if, egress_if;
-  u16 size_of_traceopt_per_node;
-  u16 size_of_all_traceopts;
-
-  clib_spinlock_lock (&data->writer_lock);
-
-  trace_data = &data->trace_data;
-  size_of_traceopt_per_node = fetch_trace_data_size (trace_profile_find ());
-  if (0 == size_of_traceopt_per_node)
-    goto end;
-
-  size_of_all_traceopts = trace_len;
-
-  ptr = (u8 *) trace->data_list;
-  max_nodes = (u8) (size_of_all_traceopts / size_of_traceopt_per_node);
-  num_nodes = max_nodes - (trace->node_len_flags_remaining_len & IOAM_REMAIN_LEN_MASK);
-
-  for (i = 0; i < IOAM_MAX_PATHS_PER_FLOW; i++)
-  {
-    trace_record = trace_data->path_data + i;
-    path = trace_record->path;
-
-    if (trace_record->is_free)
-	  continue;
-
-    for (j = max_nodes, k = 0; k < num_nodes; j--, k++)
-	  {
-	    ptr = (u8 *) ((u8 *) trace->data_list + (size_of_traceopt_per_node * (j - 1)));
-	    nodeid = clib_net_to_host_u32 (*((u32 *) ptr)) & 0x00ffffff;
-	    ptr += 4;
-
-      if (nodeid != path[k].node_id)
-        goto end;
-
-	    if (trace->trace_type == IOAM_BIT_ING_EGR_INT_SHORT)
-	    {
-	      ingress_if = clib_net_to_host_u16 (*((u16 *) ptr));
-	      ptr += 2;
-	      egress_if = clib_net_to_host_u16 (*((u16 *) ptr));
-	      if ((ingress_if != path[k].ingress_if) || (egress_if != path[k].egress_if))
-        {
-          goto end;
-        }
-	    }
-      /* Found Match - set path hop state to up */
-      path[k].state_up = 1;
-	  }
-  }
-  end:
-    clib_spinlock_unlock (&data->writer_lock);
-}
-
-always_inline int
-ip6_ioam_analyse_hbh_trace (ioam_analyser_data_t * data,
-			    ioam_trace_hdr_t * trace, u16 pak_len,
-			    u16 trace_len)
-{
-  ioam_analyse_trace_data *trace_data;
-  u16 size_of_traceopt_per_node;
-  u16 size_of_all_traceopts;
-  u8 i, j, k, num_nodes, max_nodes;
-  u8 *ptr;
-  u32 nodeid;
-  u16 ingress_if, egress_if;
-  ioam_path_map_t *path = NULL;
-  ioam_analyse_trace_record *trace_record;
-
-  clib_spinlock_lock (&data->writer_lock);
-
-  trace_data = &data->trace_data;
-
-  size_of_traceopt_per_node = fetch_trace_data_size (trace_profile_find ());
-  // Unknown trace type
-  if (size_of_traceopt_per_node == 0)
-    goto DONE;
-  size_of_all_traceopts = trace_len;
-
-  ptr = (u8 *) trace->data_list;
-  max_nodes = (u8) (size_of_all_traceopts / size_of_traceopt_per_node);
-  num_nodes = max_nodes - (trace->node_len_flags_remaining_len & IOAM_REMAIN_LEN_MASK);
-
-  for (i = 0; i < IOAM_MAX_PATHS_PER_FLOW; i++)
-  {
-    trace_record = trace_data->path_data + i;
-
-    if (trace_record->is_free || (num_nodes != trace_record->num_nodes) || (trace->trace_type != trace_record->trace_type))
-	    continue;
-
-    path = trace_record->path;
-
-    for (j = max_nodes, k = 0; k < num_nodes; j--, k++)
-	  {
-	    ptr = (u8 *) ((u8 *) trace->data_list + (size_of_traceopt_per_node * (j - 1)));
-
-	    nodeid = clib_net_to_host_u32 (*((u32 *) ptr)) & 0x00ffffff;
-	    ptr += 4;
-
-      if (nodeid != path[k].node_id)
-        break;
-
-      if(trace->trace_type == IOAM_BIT_ING_EGR_INT_SHORT)
-      {
-        ingress_if = clib_net_to_host_u16 (*((u16 *) ptr));
-        ptr += 2;
-        egress_if = clib_net_to_host_u16 (*((u16 *) ptr));
-        if ((ingress_if != path[k].ingress_if) || (egress_if != path[k].egress_if))
-        {
-          break;
-        }
-      }
-	  }
-
-    if (k == num_nodes)
-    {
-      goto found_match;
-    }
-  }
-
-  for (i = 0; i < IOAM_MAX_PATHS_PER_FLOW; i++)
-  {
-    trace_record = trace_data->path_data + i;
-    if (trace_record->is_free)
-    {
-      trace_record->is_free = 0;
-      trace_record->num_nodes = num_nodes;
-      trace_record->trace_type = trace->trace_type;
-      path = trace_data->path_data[i].path;
-      trace_record->pkt_counter = 0;
-      trace_record->bytes_counter = 0;
-      trace_record->min_delay = 0xFFFFFFFF;
-      trace_record->max_delay = 0;
-      trace_record->mean_delay = 0;
-      break;
-    }
-  }
-
-  for (j = max_nodes, k = 0; k < num_nodes; j--, k++)
-  {
-    ptr = (u8 *) ((u8 *) trace->data_list + (size_of_traceopt_per_node * (j - 1)));
-
-    path[k].node_id = clib_net_to_host_u32 (*((u32 *) ptr)) & 0x00ffffff;
-    ptr += 4;
-
-    if(trace->trace_type == IOAM_BIT_ING_EGR_INT_SHORT)
-    {
-      path[k].ingress_if = clib_net_to_host_u16 (*((u16 *) ptr));
-      ptr += 2;
-      path[k].egress_if = clib_net_to_host_u16 (*((u16 *) ptr));
-    }
-  }
-
-  found_match:
-    /* Set path state to UP */
-    for (k = 0; k < num_nodes; k++)
-      path[k].state_up = 1;
-
-    trace_record->pkt_counter++;
-    trace_record->bytes_counter += pak_len;
-    if (trace->trace_type & IOAM_BIT_TIMESTAMP_SEC)
-    {
-      /* Calculate time delay */
-      u32 delay = (u32) ip6_ioam_analyse_calc_delay (trace, trace_len, 0);
-      if (delay < trace_record->min_delay)
-        trace_record->min_delay = delay;
-      else if (delay > trace_record->max_delay)
-        trace_record->max_delay = delay;
-
-      u64 sum = (trace_record->mean_delay * data->seqno_data.rx_packets);
-      trace_record->mean_delay = (u32) ((sum + delay) / (data->seqno_data.rx_packets + 1));
-    }
-  DONE:
-    clib_spinlock_unlock (&data->writer_lock);
-    return 0;
-}
-
-always_inline int
-ip6_ioam_analyse_hbh_e2e (ioam_analyser_data_t * data,
-			  ioam_e2e_packet_t * e2e, u16 len)
-{
-  clib_spinlock_lock (&data->writer_lock);
-
-  ioam_analyze_seqno (&data->seqno_data,
-		      (u64) clib_net_to_host_u32 (e2e->e2e_data));
-
-  clib_spinlock_unlock (&data->writer_lock);
-
-  return 0;
-}
-
-always_inline u8 *
-format_path_map (u8 * s, va_list * args)
-{
-  ioam_path_map_t *pm = va_arg (*args, ioam_path_map_t *);
-  u32 num_of_elts = va_arg (*args, u32);
-  u32 i;
-
-  for (i = 0; i < num_of_elts; i++)
-  {
-    s = format (s, "node_id: 0x%x, ingress_if: 0x%x, egress_if:0x%x, state:%s\n",
-                pm->node_id, pm->ingress_if, pm->egress_if,
-                pm->state_up ? "UP" : "DOWN");
-    pm++;
-  }
-
-  return (s);
-}
-
-always_inline u8 *
-print_analyse_flow (u8 * s, ioam_analyser_data_t * record)
-{
-  int j;
-  ioam_analyse_trace_record *trace_record;
-
-  s = format (s, "pkt_sent : %u\n", record->pkt_sent);
-  s = format (s, "pkt_counter : %u\n", record->pkt_counter);
-  s = format (s, "bytes_counter : %u\n", record->bytes_counter);
-
-  s = format (s, "Trace data: \n");
-
-  for (j = 0; j < IOAM_MAX_PATHS_PER_FLOW; j++)
-  {
-    trace_record = record->trace_data.path_data + j;
-    if (trace_record->is_free)
-      continue;
-
-    s = format (s, "path_map:\n%U", format_path_map,
-    trace_record->path, trace_record->num_nodes);
-    s = format (s, "pkt_counter: %u\n", trace_record->pkt_counter);
-    s = format (s, "bytes_counter: %u\n", trace_record->bytes_counter);
-
-    s = format (s, "min_delay: %u\n", trace_record->min_delay);
-    s = format (s, "max_delay: %u\n", trace_record->max_delay);
-    s = format (s, "mean_delay: %u\n", trace_record->mean_delay);
-  }
-
-  s = format (s, "\nPOT data: \n");
-  s = format (s, "sfc_validated_count : %u\n",
-	      record->pot_data.sfc_validated_count);
-  s = format (s, "sfc_invalidated_count : %u\n",
-	      record->pot_data.sfc_invalidated_count);
-
-  s = format (s, "\nSeqno Data:\n");
-  s = format (s,
-	      "RX Packets        : %lu\n"
-	      "Lost Packets      : %lu\n"
-	      "Duplicate Packets : %lu\n"
-	      "Reordered Packets : %lu\n",
-	      record->seqno_data.rx_packets,
-	      record->seqno_data.lost_packets,
-	      record->seqno_data.dup_packets,
-	      record->seqno_data.reordered_packets);
-
-  s = format (s, "\n");
-  return s;
-}
-
-always_inline void
-ioam_analyse_init_data (ioam_analyser_data_t * data)
-{
-  u16 j;
-  ioam_analyse_trace_data *trace_data;
-
-  data->is_free = 1;
-
-  /* We maintain data corresponding to last IP-Fix export, this may
-   * get extended in future to maintain history of data */
-  vec_validate_aligned (data->chached_data_list, 0, CLIB_CACHE_LINE_BYTES);
-
-  clib_spinlock_init (&data->writer_lock);
-
-  trace_data = &(data->trace_data);
-  for (j = 0; j < IOAM_MAX_PATHS_PER_FLOW; j++)
-    trace_data->path_data[j].is_free = 1;
-}
-
-#endif /* PLUGINS_IOAM_PLUGIN_IOAM_ANALYSE_IOAM_ANALYSE_H_ */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/analyse/ioam_summary_export.c b/ioam/analyse/ioam_summary_export.c
deleted file mode 100644
index ceec155..0000000
--- a/ioam/analyse/ioam_summary_export.c
+++ /dev/null
@@ -1,445 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <vlib/vlib.h>
-#include <vnet/ip/ip6_packet.h>
-#include <vnet/udp/udp_local.h>
-#include <ioam/analyse/ioam_summary_export.h>
-#include <ioam/analyse/ip6/ip6_ioam_analyse.h>
-
-u8 *
-ioam_template_rewrite (ipfix_exporter_t *exp, flow_report_t *fr,
-		       u16 collector_port, ipfix_report_element_t *elts,
-		       u32 n_elts, u32 *stream_index)
-{
-  ip4_header_t *ip;
-  udp_header_t *udp;
-  ipfix_message_header_t *h;
-  ipfix_set_header_t *s;
-  ipfix_template_header_t *t;
-  ipfix_field_specifier_t *f;
-  ipfix_field_specifier_t *first_field;
-  u8 *rewrite = 0;
-  ip4_ipfix_template_packet_t *tp;
-  u32 field_count = 0;
-  u32 field_index = 0;
-  flow_report_stream_t *stream;
-
-  stream = &exp->streams[fr->stream_index];
-
-  /* Determine field count */
-#define _(field,mask,item,length)                                   \
-    {                                                               \
-  field_count++;                                                    \
-  fr->fields_to_send = clib_bitmap_set (fr->fields_to_send,         \
-                                        field_index, 1);            \
-    }                                                               \
-    field_index++;
-
-  foreach_ioam_ipfix_field;
-#undef _
-
-  /* Add Src address, dest address, src port, dest port
-   * path map,  number of paths manually */
-  field_count += 6;
-
-  /* allocate rewrite space */
-  vec_validate_aligned (rewrite,
-			sizeof (ip4_ipfix_template_packet_t)
-			+ field_count * sizeof (ipfix_field_specifier_t) - 1,
-			CLIB_CACHE_LINE_BYTES);
-
-  tp = (ip4_ipfix_template_packet_t *) rewrite;
-  ip = (ip4_header_t *) & tp->ip4;
-  udp = (udp_header_t *) (ip + 1);
-  h = (ipfix_message_header_t *) (udp + 1);
-  s = (ipfix_set_header_t *) (h + 1);
-  t = (ipfix_template_header_t *) (s + 1);
-  first_field = f = (ipfix_field_specifier_t *) (t + 1);
-
-  ip->ip_version_and_header_length = 0x45;
-  ip->ttl = 254;
-  ip->protocol = IP_PROTOCOL_UDP;
-  ip->src_address.as_u32 = exp->src_address.ip.ip4.as_u32;
-  ip->dst_address.as_u32 = exp->ipfix_collector.ip.ip4.as_u32;
-  udp->src_port = clib_host_to_net_u16 (collector_port);
-  udp->dst_port = clib_host_to_net_u16 (UDP_DST_PORT_ipfix);
-  udp->length = clib_host_to_net_u16 (vec_len (rewrite) - sizeof (*ip));
-
-  h->domain_id = clib_host_to_net_u32 (stream->domain_id);	//fr->domain_id);
-
-  /* Add Src address, dest address, src port, dest port
-   * path map,  number of paths manually */
-  f->e_id_length = ipfix_e_id_length (0 /* enterprise */ ,
-				      sourceIPv6Address,
-				      sizeof (ip6_address_t));
-  f++;
-
-  f->e_id_length = ipfix_e_id_length (0 /* enterprise */ ,
-				      destinationIPv6Address,
-				      sizeof (ip6_address_t));
-  f++;
-
-  f->e_id_length = ipfix_e_id_length (0 /* enterprise */ ,
-				      sourceTransportPort, 2);
-  f++;
-
-  f->e_id_length = ipfix_e_id_length (0 /* enterprise */ ,
-				      destinationTransportPort, 2);
-  f++;
-
-#define _(field,mask,item,length)                               \
-    {                                                           \
-  f->e_id_length = ipfix_e_id_length (0 /* enterprise */,       \
-    item, length);                                              \
-    f++;                                                        \
-    }
-  foreach_ioam_ipfix_field;
-#undef _
-
-  f->e_id_length = ipfix_e_id_length (0 /* enterprise */ ,
-				      ioamNumberOfPaths, 2);
-  f++;
-
-  /* Add ioamPathMap manually */
-  f->e_id_length = ipfix_e_id_length (0 /* enterprise */ ,
-				      ioamPathMap,
-				      (sizeof (ioam_path) +
-				       (sizeof (ioam_path_map_t) *
-					IOAM_TRACE_MAX_NODES)));
-  f++;
-
-  /* Back to the template packet... */
-  ip = (ip4_header_t *) & tp->ip4;
-  udp = (udp_header_t *) (ip + 1);
-
-  ASSERT (f - first_field);
-  /* Field count in this template */
-  t->id_count = ipfix_id_count (IOAM_FLOW_TEMPLATE_ID, f - first_field);
-
-  /* set length in octets */
-  s->set_id_length =
-    ipfix_set_id_length (2 /* set_id */ , (u8 *) f - (u8 *) s);
-
-  /* message length in octets */
-  h->version_length = version_length ((u8 *) f - (u8 *) h);
-
-  ip->length = clib_host_to_net_u16 ((u8 *) f - (u8 *) ip);
-  ip->checksum = ip4_header_checksum (ip);
-
-  return rewrite;
-}
-
-u16
-ioam_analyse_add_ipfix_record (flow_report_t * fr,
-			       ioam_analyser_data_t * record,
-			       vlib_buffer_t * b0, u16 offset,
-			       ip6_address_t * src, ip6_address_t * dst,
-			       u16 src_port, u16 dst_port)
-{
-  clib_spinlock_lock (&record->writer_lock);
-
-  int field_index = 0;
-  u16 tmp;
-  int i, j;
-  u16 num_paths = 0;
-  u16 num_paths_offset;
-
-
-  /* Add IPv6 source address manually */
-  memcpy (b0->data + offset, &src->as_u64[0], sizeof (u64));
-  offset += sizeof (u64);
-  memcpy (b0->data + offset, &src->as_u64[1], sizeof (u64));
-  offset += sizeof (u64);
-
-  /* Add IPv6 destination address manually */
-  memcpy (b0->data + offset, &dst->as_u64[0], sizeof (u64));
-  offset += sizeof (u64);
-  memcpy (b0->data + offset, &dst->as_u64[1], sizeof (u64));
-  offset += sizeof (u64);
-
-  /* Add source port manually */
-  tmp = clib_host_to_net_u16 (src_port);
-  memcpy (b0->data + offset, &tmp, sizeof (u16));
-  offset += sizeof (u16);
-
-  /* Add dest port manually */
-  tmp = clib_host_to_net_u16 (dst_port);
-  memcpy (b0->data + offset, &tmp, sizeof (u16));
-  offset += sizeof (u16);
-
-#define _(field,mask,item,length)                            \
-    if (clib_bitmap_get (fr->fields_to_send, field_index))   \
-    {                                                        \
-      /* Expect only 4 bytes */               \
-      u32 tmp;                                             \
-      tmp = clib_host_to_net_u32((u32)record->field - (u32)record->chached_data_list->field);\
-      memcpy (b0->data + offset, &tmp, length);       \
-      offset += length;                                 \
-    }
-  field_index++;
-  foreach_ioam_ipfix_field;
-#undef _
-
-  /* Store num_paths_offset here and update later */
-  num_paths_offset = offset;
-  offset += sizeof (u16);
-
-  /* Add ioamPathMap manually */
-  for (i = 0; i < IOAM_MAX_PATHS_PER_FLOW; i++)
-    {
-      ioam_analyse_trace_record *trace = record->trace_data.path_data + i;
-      ioam_analyse_trace_record *trace_cached =
-	record->chached_data_list->trace_data.path_data + i;
-      ioam_path *path = (ioam_path *) (b0->data + offset);
-
-      if (!trace->is_free)
-	{
-	  num_paths++;
-
-	  path->num_nodes = trace->num_nodes;
-
-	  path->trace_type = trace->trace_type;
-	  if (0 < (trace->pkt_counter - trace_cached->pkt_counter))
-	    {
-	      u64 new_sum = trace->mean_delay * record->seqno_data.rx_packets;
-	      u64 old_sum =
-		trace_cached->mean_delay *
-		record->chached_data_list->seqno_data.rx_packets;
-	      path->mean_delay =
-		(u32) ((new_sum - old_sum) / (trace->pkt_counter -
-					      trace_cached->pkt_counter));
-	      path->mean_delay = clib_host_to_net_u32 (path->mean_delay);
-	    }
-	  else
-	    path->mean_delay = 0;
-
-	  path->bytes_counter =
-	    trace->bytes_counter - trace_cached->bytes_counter;
-	  path->bytes_counter = clib_host_to_net_u32 (path->bytes_counter);
-
-	  path->pkt_counter = trace->pkt_counter - trace_cached->pkt_counter;
-	  path->pkt_counter = clib_host_to_net_u32 (path->pkt_counter);
-	  offset += sizeof (ioam_path);
-
-	  for (j = 0; j < trace->num_nodes; j++)
-	    {
-	      path->path[j].node_id =
-		clib_host_to_net_u32 (trace->path[j].node_id);
-	      path->path[j].ingress_if =
-		clib_host_to_net_u16 (trace->path[j].ingress_if);
-	      path->path[j].egress_if =
-		clib_host_to_net_u16 (trace->path[j].egress_if);
-	      path->path[j].state_up = trace->path[j].state_up;
-	    }
-
-	  //offset += (sizeof(ioam_path_map_t) * trace->num_nodes);
-	  offset += (sizeof (ioam_path_map_t) * IOAM_TRACE_MAX_NODES);	//FIXME
-	}
-    }
-
-  num_paths = clib_host_to_net_u16 (num_paths);
-  memcpy (b0->data + num_paths_offset, &num_paths, sizeof (u16));
-
-  /* Update cache */
-  *(record->chached_data_list) = *record;
-  record->chached_data_list->chached_data_list = NULL;
-
-  clib_spinlock_unlock (&record->writer_lock);
-  return offset;
-}
-
-vlib_frame_t *
-ioam_send_flows (flow_report_main_t *frm, ipfix_exporter_t *exp,
-		 flow_report_t *fr, vlib_frame_t *f, u32 *to_next,
-		 u32 node_index)
-{
-  vlib_buffer_t *b0 = NULL;
-  u32 next_offset = 0;
-  u32 bi0 = ~0;
-  int i;
-  ip4_ipfix_template_packet_t *tp;
-  ipfix_message_header_t *h;
-  ipfix_set_header_t *s = NULL;
-  ip4_header_t *ip;
-  udp_header_t *udp;
-  u32 records_this_buffer;
-  u16 new_l0, old_l0;
-  ip_csum_t sum0;
-  vlib_main_t *vm = vlib_get_main ();
-  ip6_address_t temp;
-  ioam_analyser_data_t *record = NULL;
-  flow_report_stream_t *stream;
-  ioam_analyser_data_t *aggregated_data;
-  u16 data_len;
-
-  stream = &exp->streams[fr->stream_index];
-
-  clib_memset (&temp, 0, sizeof (ip6_address_t));
-
-  aggregated_data = ioam_analyser_main.aggregated_data;
-  data_len = vec_len (aggregated_data);
-
-  vec_foreach_index (i, aggregated_data)
-  {
-    u8 flush = 0;
-    record = aggregated_data + i;
-
-    /* Flush if last entry */
-    if (i == (data_len - 1))
-      flush = 1;
-
-    if (!record->is_free)
-      {
-
-	if (PREDICT_FALSE (b0 == NULL))
-	  {
-	    if (vlib_buffer_alloc (vm, &bi0, 1) != 1)
-	      break;
-
-	    b0 = vlib_get_buffer (vm, bi0);
-	    memcpy (b0->data, fr->rewrite, vec_len (fr->rewrite));
-	    b0->current_data = 0;
-	    b0->current_length = vec_len (fr->rewrite);
-	    b0->flags |= VLIB_BUFFER_TOTAL_LENGTH_VALID;
-	    vnet_buffer (b0)->sw_if_index[VLIB_RX] = 0;
-	    vnet_buffer (b0)->sw_if_index[VLIB_TX] = ~0;
-
-	    tp = vlib_buffer_get_current (b0);
-	    ip = &tp->ip4;
-	    h = &tp->ipfix.h;
-	    s = &tp->ipfix.s;
-
-	    /* FIXUP: message header export_time */
-	    h->export_time = clib_host_to_net_u32 (((u32) time (NULL)));
-
-	    /* FIXUP: message header sequence_number */
-	    h->sequence_number = stream->sequence_number++;
-	    h->sequence_number = clib_host_to_net_u32 (h->sequence_number);
-	    next_offset = (u32) (((u8 *) (s + 1)) - (u8 *) tp);
-	    records_this_buffer = 0;
-	  }
-
-	next_offset = ioam_analyse_add_ipfix_record (fr, record,
-						     b0, next_offset,
-						     &temp, &temp, 0, 0);
-	records_this_buffer++;
-
-	/* Flush data if packet len is about to reach path mtu */
-	if (next_offset > (exp->path_mtu - 250))
-	  flush = 1;
-      }
-
-    if (PREDICT_FALSE (flush && b0))
-      {
-	s->set_id_length = ipfix_set_id_length (IOAM_FLOW_TEMPLATE_ID,
-						next_offset - (sizeof (*ip) +
-							       sizeof (*udp) +
-							       sizeof (*h)));
-	b0->current_length = next_offset;
-	b0->flags |= VLIB_BUFFER_TOTAL_LENGTH_VALID;
-	tp = vlib_buffer_get_current (b0);
-	ip = (ip4_header_t *) & tp->ip4;
-	udp = (udp_header_t *) (ip + 1);
-
-	sum0 = ip->checksum;
-	old_l0 = ip->length;
-	new_l0 = clib_host_to_net_u16 ((u16) next_offset);
-	sum0 = ip_csum_update (sum0, old_l0, new_l0, ip4_header_t,
-			       length /* changed member */ );
-
-	ip->checksum = ip_csum_fold (sum0);
-	ip->length = new_l0;
-	udp->length =
-	  clib_host_to_net_u16 (b0->current_length - sizeof (*ip));
-
-	if (exp->udp_checksum)
-	  {
-	    /* RFC 7011 section 10.3.2. */
-	    udp->checksum = ip4_tcp_udp_compute_checksum (vm, b0, ip);
-	    if (udp->checksum == 0)
-	      udp->checksum = 0xffff;
-	  }
-
-	to_next[0] = bi0;
-	f->n_vectors++;
-	to_next++;
-
-	if (f->n_vectors == VLIB_FRAME_SIZE)
-	  {
-	    vlib_put_frame_to_node (vm, node_index, f);
-	    f = vlib_get_frame_to_node (vm, node_index);
-	    f->n_vectors = 0;
-	    to_next = vlib_frame_vector_args (f);
-	  }
-	b0 = 0;
-	bi0 = ~0;
-      }
-  }
-
-  return f;
-}
-
-clib_error_t *
-ioam_flow_create (u8 del)
-{
-  vnet_flow_report_add_del_args_t args;
-  int rv;
-  u32 domain_id = 0;
-  ipfix_exporter_t *exp = &flow_report_main.exporters[0];
-  u16 template_id;
-
-  clib_memset (&args, 0, sizeof (args));
-  args.rewrite_callback = ioam_template_rewrite;
-  args.flow_data_callback = ioam_send_flows;
-  del ? (args.is_add = 0) : (args.is_add = 1);
-  args.domain_id = domain_id;
-
-  rv = vnet_flow_report_add_del (exp, &args, &template_id);
-
-  switch (rv)
-    {
-    case 0:
-      break;
-    case VNET_API_ERROR_NO_SUCH_ENTRY:
-      return clib_error_return (0, "registration not found...");
-    default:
-      return clib_error_return (0, "vnet_flow_report_add_del returned %d",
-				rv);
-    }
-
-  return 0;
-}
-
-clib_error_t *
-ioam_flow_report_init (vlib_main_t * vm)
-{
-  return 0;
-}
-
-/* *INDENT-OFF* */
-VLIB_INIT_FUNCTION (ioam_flow_report_init) =
-{
-  .runs_after = VLIB_INITS("flow_report_init"),
-};
-/* *INDENT-ON* */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/analyse/ioam_summary_export.h b/ioam/analyse/ioam_summary_export.h
deleted file mode 100644
index 7d1c5d0..0000000
--- a/ioam/analyse/ioam_summary_export.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef __included_ip6_ioam_flow_report_h__
-#define __included_ip6_ioam_flow_report_h__
-
-#include <ioam/analyse/ioam_analyse.h>
-#include <vnet/ipfix-export/flow_report.h>
-
-#define foreach_ioam_ipfix_info_element           \
-_(ioamPacketSent, 5239, u32)                     \
-_(ioamPacketCount, 5237, u32)                     \
-_(ioamByteCount, 5238, u32)                       \
-_(ioamPathMap, 5262, u32)                         \
-_(ioamNumberOfPaths, 5264, u16)                   \
-_(ioamSfcValidatedCount, 5278, u32)               \
-_(ioamSfcInValidatedCount, 5279, u32)             \
-_(ioamSeqnoRxCount, 5280, u32)                    \
-_(ioamSeqnoLostCount, 5281, u32)                  \
-_(ioamSeqnoReorderedCount, 5282, u32)             \
-_(ioamSeqnoDupCount, 5283, u32)
-
-
-typedef enum
-{
-#define _(n,v,t) n = v,
-  foreach_ioam_ipfix_info_element
-#undef _
-} ioam_ipfix_info_element_id_t;
-
-#define foreach_ioam_ipfix_field                                          \
-_(pkt_sent, 0xffffffff, ioamPacketSent, 4)                      \
-_(pkt_counter, 0xffffffff, ioamPacketCount, 4)                      \
-_(bytes_counter, 0xffffffff, ioamByteCount, 4)                      \
-_(pot_data.sfc_validated_count, 0xffffffff, ioamSfcValidatedCount, 4)     \
-_(pot_data.sfc_invalidated_count, 0xffffffff, ioamSfcInValidatedCount, 4) \
-_(seqno_data.rx_packets, 0xffffffff, ioamSeqnoRxCount, 4) \
-_(seqno_data.lost_packets, 0xffffffff, ioamSeqnoLostCount, 4) \
-_(seqno_data.reordered_packets, 0xffffffff, ioamSeqnoReorderedCount, 4) \
-_(seqno_data.dup_packets, 0xffffffff, ioamSeqnoDupCount, 4)
-
-clib_error_t *ioam_flow_report_init (vlib_main_t * vm);
-
-typedef struct
-{
-  u8 num_nodes;
-  u8 trace_type;
-  u16 reserve;
-  u32 mean_delay;
-  u32 pkt_counter;
-  u32 bytes_counter;
-  ioam_path_map_t path[0];
-} ioam_path;
-
-clib_error_t *ioam_flow_create (u8 del);
-
-u8 *ioam_template_rewrite (ipfix_exporter_t *exp, flow_report_t *fr,
-			   u16 collector_port, ipfix_report_element_t *elts,
-			   u32 n_elts, u32 *stream_index);
-
-u16 ioam_analyse_add_ipfix_record (flow_report_t * fr,
-				   ioam_analyser_data_t * record,
-				   vlib_buffer_t * b0, u16 offset,
-				   ip6_address_t * src, ip6_address_t * dst,
-				   u16 src_port, u16 dst_port);
-
-#endif /* __included_ip6_ioam_flow_report_h__ */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/analyse/ip6/ip6_ioam_analyse.c b/ioam/analyse/ip6/ip6_ioam_analyse.c
deleted file mode 100644
index 99ba329..0000000
--- a/ioam/analyse/ip6/ip6_ioam_analyse.c
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <vnet/ethernet/ethernet.h>
-#include <ioam/analyse/ioam_analyse.h>
-#include <ioam/export-common/ioam_export.h>
-#include <ioam/analyse/ip6/ip6_ioam_analyse.h>
-#include <ioam/analyse/ioam_summary_export.h>
-#include <vnet/ip/ip.h>
-#include <ioam/ipfixcollector/ipfixcollector.h>
-
-extern ioam_export_main_t ioam_export_main;
-static clib_error_t *
-ioam_analyse_enable_disable (vlib_main_t * vm,
-			     int is_add, int is_export, int remote_listen)
-{
-  ipfix_client_add_del_t ipfix_reg;
-  clib_error_t *rv = 0;
-
-  ipfix_reg.client_name = format (0, "ip6-hbh-analyse-remote");
-  ipfix_reg.client_node = analyse_node_remote.index;
-  ipfix_reg.ipfix_setid = IPFIX_IOAM_EXPORT_ID;
-
-  if (is_export)
-    {
-      rv = ioam_flow_create (!is_add);
-      if (rv)
-	goto ret;
-    }
-
-  if (is_add)
-    {
-      ip6_ioam_analyse_register_handlers ();
-      if (remote_listen)
-	{
-	  ipfix_reg.del = 0;
-	  ipfix_collector_reg_setid (vm, &ipfix_reg);
-	}
-      else
-	{
-	  ioam_export_set_next_node (&ioam_export_main,
-				     (u8 *) "ip6-hbh-analyse-local");
-	}
-    }
-  else
-    {
-      ip6_ioam_analyse_unregister_handlers ();
-      if (remote_listen)
-	{
-	  ipfix_reg.del = 1;
-	  ipfix_collector_reg_setid (vm, &ipfix_reg);
-	}
-      else
-	ioam_export_reset_next_node (&ioam_export_main);
-    }
-
-ret:
-  vec_free (ipfix_reg.client_name);
-  return rv;
-}
-
-static clib_error_t *
-set_ioam_analyse_command_fn (vlib_main_t * vm, unformat_input_t * input,
-			     vlib_cli_command_t * cmd)
-{
-  int is_export = 0;
-  int is_add = 1;
-  int remote_listen = 0;
-
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "export-ipfix-collector"))
-	is_export = 1;
-      else if (unformat (input, "disable"))
-	is_add = 0;
-      else if (unformat (input, "listen-ipfix"))
-	remote_listen = 1;
-      else
-	break;
-    }
-
-  return (ioam_analyse_enable_disable (vm, is_add, is_export, remote_listen));
-}
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (set_ioam_analyse_command, static) = {
-  .path = "set ioam analyse",
-  .short_help = "set ioam analyse [export-ipfix-collector] [disable] [listen-ipfix]",
-  .function = set_ioam_analyse_command_fn,
-};
-/* *INDENT-ON* */
-
-static clib_error_t *
-show_ioam_analyse_cmd_fn (vlib_main_t * vm, unformat_input_t * input,
-			  vlib_cli_command_t * cmd)
-{
-  ip6_ioam_analyser_main_t *am = &ioam_analyser_main;
-  ioam_analyser_data_t *record = NULL;
-  u8 i;
-  u8 *s = 0;
-
-  vec_reset_length (s);
-  s = format (0, "iOAM Analyse Information: \n");
-  vec_foreach_index (i, am->aggregated_data)
-  {
-    record = am->aggregated_data + i;
-    if (record->is_free)
-      continue;
-
-    s = format (s, "Flow Number: %u\n", i);
-    s = print_analyse_flow (s, record);
-    s = format (s, "\n");
-  }
-  vlib_cli_output (vm, "%v", s);
-
-  vec_free (s);
-
-  return 0;
-}
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (ip6_show_ioam_ipfix_cmd, static) = {
-  .path = "show ioam analyse ",
-  .short_help = "show ioam analyser information",
-  .function = show_ioam_analyse_cmd_fn,
-};
-/* *INDENT-ON* */
-
-static clib_error_t *
-ioam_analyse_init (vlib_main_t * vm)
-{
-  ip6_ioam_analyser_main_t *am = &ioam_analyser_main;
-  u16 i;
-
-  vec_validate_aligned (am->aggregated_data, 50, CLIB_CACHE_LINE_BYTES);
-  vec_foreach_index (i, am->aggregated_data)
-  {
-    ioam_analyse_init_data (am->aggregated_data + i);
-  }
-
-  return 0;
-}
-
-VLIB_INIT_FUNCTION (ioam_analyse_init);
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/analyse/ip6/ip6_ioam_analyse.h b/ioam/analyse/ip6/ip6_ioam_analyse.h
deleted file mode 100644
index 5a2a2d7..0000000
--- a/ioam/analyse/ip6/ip6_ioam_analyse.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef PLUGINS_IOAM_PLUGIN_IOAM_ANALYSE_IP6_IOAM_ANALYSE_NODE_H_
-#define PLUGINS_IOAM_PLUGIN_IOAM_ANALYSE_IP6_IOAM_ANALYSE_NODE_H_
-
-#include <ioam/analyse/ioam_analyse.h>
-#include <vnet/ip/ip6_hop_by_hop.h>
-#include <ioam/encap/ip6_ioam_trace.h>
-
-/** @brief IP6-iOAM analyser main structure.
-    @note cache aligned.
-*/
-typedef struct
-{
-  /** Array of function pointer to analyse each hop-by-hop option. */
-  int (*analyse_hbh_handler[MAX_IP6_HBH_OPTION]) (u32 flow_id,
-						  ip6_hop_by_hop_option_t *
-						  opt, u16 len);
-
-  /** This contains the aggregated data from the time VPP started analysing. */
-  ioam_analyser_data_t *aggregated_data;
-
-} ip6_ioam_analyser_main_t;
-
-extern ip6_ioam_analyser_main_t ioam_analyser_main;
-
-extern vlib_node_registration_t analyse_node_local;
-extern vlib_node_registration_t analyse_node_remote;
-
-void ip6_ioam_analyse_register_handlers (void);
-
-void ip6_ioam_analyse_unregister_handlers (void);
-
-clib_error_t *ip6_ioam_analyse_init (vlib_main_t * vm);
-
-inline static ioam_analyser_data_t *
-ioam_analyse_get_data_from_flow_id (u32 flow_id)
-{
-  if (flow_id >= vec_len (ioam_analyser_main.aggregated_data))
-    return NULL;
-
-  if (ioam_analyser_main.aggregated_data[flow_id].is_free)
-    ioam_analyser_main.aggregated_data[flow_id].is_free = 0;
-
-  return (ioam_analyser_main.aggregated_data + flow_id);
-}
-
-always_inline void *
-ip6_ioam_find_hbh_option (ip6_hop_by_hop_header_t * hbh0, u8 option)
-{
-  ip6_hop_by_hop_option_t *opt0, *limit0;
-  u8 type0;
-
-  opt0 = (ip6_hop_by_hop_option_t *) (hbh0 + 1);
-  limit0 =
-    (ip6_hop_by_hop_option_t *) ((u8 *) hbh0 + ((hbh0->length + 1) << 3));
-
-  while (opt0 < limit0)
-    {
-      type0 = opt0->type;
-      if (type0 == option)
-	return ((void *) opt0);
-
-      if (0 == type0)
-	{
-	  opt0 = (ip6_hop_by_hop_option_t *) ((u8 *) opt0) + 1;
-	  continue;
-	}
-      opt0 = (ip6_hop_by_hop_option_t *)
-	(((u8 *) opt0) + opt0->length + sizeof (ip6_hop_by_hop_option_t));
-    }
-
-  return NULL;
-}
-
-always_inline int
-ip6_ioam_analyse_compare_path_delay (ip6_hop_by_hop_header_t * hbh0,
-				     ip6_hop_by_hop_header_t * hbh1,
-				     bool oneway)
-{
-  ioam_trace_option_t *trace0 = NULL, *trace1 = NULL;
-  f64 delay0, delay1;
-
-  trace0 =
-    ip6_ioam_find_hbh_option (hbh0, HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST);
-  trace1 =
-    ip6_ioam_find_hbh_option (hbh1, HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST);
-
-  if (PREDICT_FALSE ((trace0 == NULL) && (trace1 == NULL)))
-    return 0;
-
-  if (PREDICT_FALSE (trace1 == NULL))
-    return 1;
-
-  if (PREDICT_FALSE (trace0 == NULL))
-    return -1;
-
-  delay0 = ip6_ioam_analyse_calc_delay (&trace0->trace_hdr,
-					trace0->hdr.length - 2, oneway);
-  delay1 = ip6_ioam_analyse_calc_delay (&trace1->trace_hdr,
-					trace1->hdr.length - 2, oneway);
-
-  return (delay0 - delay1);
-}
-
-#endif /* PLUGINS_IOAM_PLUGIN_IOAM_ANALYSE_IP6_IOAM_ANALYSE_NODE_H_ */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/analyse/ip6/node.c b/ioam/analyse/ip6/node.c
deleted file mode 100644
index ef35d0a..0000000
--- a/ioam/analyse/ip6/node.c
+++ /dev/null
@@ -1,518 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <vlib/vlib.h>
-#include <vnet/vnet.h>
-#include <vppinfra/error.h>
-#include <vnet/ethernet/ethernet.h>
-#include <vnet/ip/ip.h>
-#include <ioam/export-common/ioam_export.h>
-#include <ioam/encap/ip6_ioam_trace.h>
-#include <ioam/encap/ip6_ioam_pot.h>
-#include <ioam/lib-pot/pot_util.h>
-#include <ioam/encap/ip6_ioam_e2e.h>
-#include <ioam/analyse/ioam_analyse.h>
-#include <ioam/analyse/ip6/ip6_ioam_analyse.h>
-#include <vnet/plugin/plugin.h>
-
-typedef struct
-{
-  u32 next_index;
-  u32 flow_id;
-} analyse_trace_t;
-
-vlib_node_registration_t analyse_node_local;
-vlib_node_registration_t analyse_node_remote;
-
-#define foreach_analyse_error \
-_(ANALYSED, "Packets analysed for summarization") \
-_(FAILED, "Packets analysis failed") \
-
-typedef enum
-{
-#define _(sym,str) ANALYSE_ERROR_##sym,
-  foreach_analyse_error
-#undef _
-    ANALYSE_N_ERROR,
-} analyse_error_t;
-
-static char *analyse_error_strings[] = {
-#define _(sym,string) string,
-  foreach_analyse_error
-#undef _
-};
-
-typedef enum
-{
-  ANALYSE_NEXT_IP4_LOOKUP,
-  ANALYSE_NEXT_IP4_DROP,
-  ANALYSE_N_NEXT,
-} analyse_next_t;
-
-ip6_ioam_analyser_main_t ioam_analyser_main;
-
-/* packet trace format function */
-static u8 *
-format_analyse_trace (u8 * s, va_list * args)
-{
-  CLIB_UNUSED (vlib_main_t * vm) = va_arg (*args, vlib_main_t *);
-  CLIB_UNUSED (vlib_node_t * node) = va_arg (*args, vlib_node_t *);
-  analyse_trace_t *t = va_arg (*args, analyse_trace_t *);
-
-  s = format (s, "IP6-ioam-analyse: flow_id %d, next index %d",
-	      t->flow_id, t->next_index);
-  return s;
-}
-
-always_inline u8
-ioam_analyse_hbh (u32 flow_id,
-		  ip6_hop_by_hop_header_t * hbh0,
-		  ip6_hop_by_hop_option_t * opt0,
-		  ip6_hop_by_hop_option_t * limit0, u16 len)
-{
-  ip6_ioam_analyser_main_t *am = &ioam_analyser_main;
-  u8 type0;
-  u8 error0 = 0;
-
-  while (opt0 < limit0)
-    {
-      type0 = opt0->type;
-      switch (type0)
-	{
-	case 0:		/* Pad1 */
-	  opt0 = (ip6_hop_by_hop_option_t *) ((u8 *) opt0) + 1;
-	  continue;
-	case 1:		/* PadN */
-	  break;
-	default:
-	  if (am->analyse_hbh_handler[type0])
-	    {
-	      if (PREDICT_TRUE
-		  ((*am->analyse_hbh_handler[type0]) (flow_id, opt0,
-						      len) < 0))
-		{
-		  error0 = ANALYSE_ERROR_FAILED;
-		  return (error0);
-		}
-	    }
-	}
-      opt0 =
-	(ip6_hop_by_hop_option_t *) (((u8 *) opt0) + opt0->length +
-				     sizeof (ip6_hop_by_hop_option_t));
-    }
-  return (error0);
-}
-
-/**
- * @brief IPv6 InBandOAM Analyse node.
- * @node ip6-hbh-analyse-local, ip6-hbh-analyse-remote
- *
- * This function receives IP-FIX packets containing IPv6-iOAM records, analyses
- * them and collects/aggregates the statistics.
- *
- * @param vm    vlib_main_t corresponding to the current thread.
- * @param node  vlib_node_runtime_t data for this node.
- * @param frame vlib_frame_t whose contents should be dispatched.
- *
- * @par Graph mechanics: buffer, next index usage
- *
- * <em>Uses:</em>
- * - <code>vlib_buffer_get_current(p0)</code>
- *     - Walks on each ioam record present in IP-Fix record, analyse them and
- *       store the statistics.
- *
- * <em>Next Index:</em>
- * - Dispatches the packet to ip4-lookup if executed under ip6-hbh-analyse-local
- *   node context and to ip4-drop if executed under ip6-hbh-analyse-remote node
- *   context.
- */
-static uword
-ip6_ioam_analyse_node_fn (vlib_main_t * vm, vlib_node_runtime_t * node,
-			  vlib_frame_t * frame)
-{
-  u32 n_left_from, *from, *to_next;
-  analyse_next_t next_index;
-  u32 pkts_analysed = 0;
-  u32 pkts_failed = 0;
-  u8 remote = 0;
-  u32 next0 = ANALYSE_NEXT_IP4_LOOKUP;
-
-  from = vlib_frame_vector_args (frame);
-  n_left_from = frame->n_vectors;
-  next_index = node->cached_next_index;
-
-  if (PREDICT_FALSE (analyse_node_remote.index == node->node_index))
-    {
-      remote = 1;
-      next0 = ANALYSE_NEXT_IP4_DROP;
-    }
-
-  while (n_left_from > 0)
-    {
-      u32 n_left_to_next;
-
-      vlib_get_next_frame (vm, node, next_index, to_next, n_left_to_next);
-
-      while (n_left_from > 0 && n_left_to_next > 0)
-	{
-	  u32 bi0;
-	  vlib_buffer_t *p0;
-	  ip4_header_t *ip40;
-	  u8 *data, *limit;
-	  u16 num_ioam_records;
-
-	  /* speculatively enqueue p0 to the current next frame */
-	  bi0 = from[0];
-	  to_next[0] = bi0;
-	  from += 1;
-	  to_next += 1;
-	  n_left_from -= 1;
-	  n_left_to_next -= 1;
-
-	  p0 = vlib_get_buffer (vm, bi0);
-	  if (PREDICT_FALSE (remote))
-	    {
-	      vlib_buffer_advance (p0, -(word) (sizeof (udp_header_t) +
-						sizeof (ip4_header_t) +
-						sizeof
-						(ipfix_message_header_t) +
-						sizeof (ipfix_set_header_t)));
-	    }
-	  data = (u8 *) vlib_buffer_get_current (p0);
-	  ip40 = (ip4_header_t *) vlib_buffer_get_current (p0);
-	  limit = data + clib_net_to_host_u16 (ip40->length);
-	  data += sizeof (ip4_header_t) + sizeof (udp_header_t)
-	    + sizeof (ipfix_message_header_t) + sizeof (ipfix_set_header_t);
-
-	  num_ioam_records = (limit - data) / DEFAULT_EXPORT_SIZE;
-
-	  while (num_ioam_records >= 4)
-	    {
-	      /* Prefetch next 2 ioam records */
-	      {
-		CLIB_PREFETCH (data + (2 * DEFAULT_EXPORT_SIZE),
-			       (DEFAULT_EXPORT_SIZE), LOAD);
-		CLIB_PREFETCH (data + (3 * DEFAULT_EXPORT_SIZE),
-			       (DEFAULT_EXPORT_SIZE), LOAD);
-	      }
-
-	      num_ioam_records -= 2;
-
-	      ip6_header_t *ip60, *ip61;
-	      ip6_hop_by_hop_header_t *hbh0, *hbh1;
-	      ip6_hop_by_hop_option_t *opt0, *limit0, *opt1, *limit1;
-	      u32 flow_id0, flow_id1;
-	      u8 error0, error1;
-	      ioam_analyser_data_t *data0, *data1;
-	      u16 p_len0, p_len1;
-
-	      ip60 = (ip6_header_t *) data;
-	      ip61 = (ip6_header_t *) (data + DEFAULT_EXPORT_SIZE);
-
-	      data += (2 * DEFAULT_EXPORT_SIZE);
-
-	      hbh0 = (ip6_hop_by_hop_header_t *) (ip60 + 1);
-	      hbh1 = (ip6_hop_by_hop_header_t *) (ip61 + 1);
-
-	      opt0 = (ip6_hop_by_hop_option_t *) (hbh0 + 1);
-	      opt1 = (ip6_hop_by_hop_option_t *) (hbh1 + 1);
-
-	      limit0 =
-		(ip6_hop_by_hop_option_t *) ((u8 *) hbh0 +
-					     ((hbh0->length + 1) << 3));
-	      limit1 =
-		(ip6_hop_by_hop_option_t *) ((u8 *) hbh1 +
-					     ((hbh1->length + 1) << 3));
-
-	      flow_id0 =
-		clib_net_to_host_u32
-		(ip60->ip_version_traffic_class_and_flow_label) & 0xFFFFF;
-	      flow_id1 =
-		clib_net_to_host_u32
-		(ip61->ip_version_traffic_class_and_flow_label) & 0xFFFFF;
-
-	      p_len0 = clib_net_to_host_u16 (ip60->payload_length);
-	      p_len1 = clib_net_to_host_u16 (ip61->payload_length);
-
-	      error0 =
-		ioam_analyse_hbh (flow_id0, hbh0, opt0, limit0, p_len0);
-	      error1 =
-		ioam_analyse_hbh (flow_id1, hbh1, opt1, limit1, p_len0);
-
-	      if (PREDICT_TRUE ((error0 == 0) && (error1 == 0)))
-		{
-		  pkts_analysed += 2;
-		  data0 = ioam_analyse_get_data_from_flow_id (flow_id0);
-		  data1 = ioam_analyse_get_data_from_flow_id (flow_id1);
-
-		  clib_spinlock_lock (&data0->writer_lock);
-		  data0->pkt_counter++;
-		  data0->bytes_counter += p_len0;
-		  clib_spinlock_unlock (&data0->writer_lock);
-
-		  clib_spinlock_lock (&data1->writer_lock);
-		  data1->pkt_counter++;
-		  data1->bytes_counter += p_len1;
-		  clib_spinlock_unlock (&data1->writer_lock);
-		}
-	      else if (error0 == 0)
-		{
-		  pkts_analysed++;
-		  pkts_failed++;
-
-		  data0 = ioam_analyse_get_data_from_flow_id (flow_id0);
-		  clib_spinlock_lock (&data0->writer_lock);
-		  data0->pkt_counter++;
-		  data0->bytes_counter += p_len0;
-		  clib_spinlock_unlock (&data0->writer_lock);
-		}
-	      else if (error1 == 0)
-		{
-		  pkts_analysed++;
-		  pkts_failed++;
-
-		  data1 = ioam_analyse_get_data_from_flow_id (flow_id1);
-		  clib_spinlock_lock (&data1->writer_lock);
-		  data1->pkt_counter++;
-		  data1->bytes_counter += p_len1;
-		  clib_spinlock_unlock (&data1->writer_lock);
-		}
-	      else
-		pkts_failed += 2;
-	    }
-
-	  while (num_ioam_records > 0)
-	    {
-	      num_ioam_records--;
-
-	      ip6_header_t *ip60;
-	      ip6_hop_by_hop_header_t *hbh0;
-	      ip6_hop_by_hop_option_t *opt0, *limit0;
-	      u32 flow_id0;
-	      u8 error0;
-	      ioam_analyser_data_t *data0;
-	      u16 p_len0;
-
-	      ip60 = (ip6_header_t *) data;
-	      data += (1 * DEFAULT_EXPORT_SIZE);
-	      hbh0 = (ip6_hop_by_hop_header_t *) (ip60 + 1);
-	      opt0 = (ip6_hop_by_hop_option_t *) (hbh0 + 1);
-	      limit0 =
-		(ip6_hop_by_hop_option_t *) ((u8 *) hbh0 +
-					     ((hbh0->length + 1) << 3));
-
-	      flow_id0 =
-		clib_net_to_host_u32
-		(ip60->ip_version_traffic_class_and_flow_label) & 0xFFFFF;
-	      p_len0 = clib_net_to_host_u16 (ip60->payload_length);
-	      error0 =
-		ioam_analyse_hbh (flow_id0, hbh0, opt0, limit0, p_len0);
-
-	      if (PREDICT_TRUE (error0 == 0))
-		{
-		  pkts_analysed++;
-		  data0 = ioam_analyse_get_data_from_flow_id (flow_id0);
-		  clib_spinlock_lock (&data0->writer_lock);
-		  data0->pkt_counter++;
-		  data0->bytes_counter +=
-		    clib_net_to_host_u16 (ip60->payload_length);
-		  clib_spinlock_unlock (&data0->writer_lock);
-		}
-	      else
-		pkts_failed++;
-	    }
-
-	  /* verify speculative enqueue, maybe switch current next frame */
-	  vlib_validate_buffer_enqueue_x1 (vm, node, next_index, to_next,
-					   n_left_to_next, bi0, next0);
-	}
-
-      vlib_put_next_frame (vm, node, next_index, n_left_to_next);
-    }
-
-  vlib_node_increment_counter (vm, node->node_index, ANALYSE_ERROR_ANALYSED,
-			       pkts_analysed);
-
-  if (PREDICT_FALSE (pkts_failed))
-    vlib_node_increment_counter (vm, node->node_index, ANALYSE_ERROR_FAILED,
-				 pkts_failed);
-
-  return frame->n_vectors;
-}
-
-int
-ip6_ioam_analyse_hbh_trace_internal (u32 flow_id,
-				     ip6_hop_by_hop_option_t * opt, u16 len)
-{
-  ioam_analyser_data_t *data;
-  ioam_trace_option_t *trace = (ioam_trace_option_t *) opt;
-
-  data = ioam_analyse_get_data_from_flow_id (flow_id);
-  ASSERT (data != NULL);
-
-  (void) ip6_ioam_analyse_hbh_trace (data, &trace->trace_hdr, len,
-				     (trace->hdr.length - 2)
-				     /*ioam_trace_type,data_list_elts_left */
-    );
-  return 0;
-}
-
-int
-ip6_ioam_analyse_hbh_pot (u32 flow_id, ip6_hop_by_hop_option_t * opt0,
-			  u16 len)
-{
-
-  ioam_pot_option_t *pot0;
-  u64 random = 0;
-  u64 cumulative = 0;
-  pot_profile *pot_profile = 0;
-  int ret;
-  ioam_analyser_data_t *data;
-
-  data = ioam_analyse_get_data_from_flow_id (flow_id);
-
-  pot0 = (ioam_pot_option_t *) opt0;
-  random = clib_net_to_host_u64 (pot0->random);
-  cumulative = clib_net_to_host_u64 (pot0->cumulative);
-  pot_profile = pot_profile_get_active ();
-  ret = pot_validate (pot_profile, cumulative, random);
-
-  clib_spinlock_lock (&data->writer_lock);
-
-  (0 == ret) ? (data->pot_data.sfc_validated_count++) :
-    (data->pot_data.sfc_invalidated_count++);
-
-  clib_spinlock_unlock (&data->writer_lock);
-  return 0;
-}
-
-int
-ip6_ioam_analyse_hbh_e2e_internal (u32 flow_id, ip6_hop_by_hop_option_t * opt,
-				   u16 len)
-{
-  ioam_analyser_data_t *data;
-  ioam_e2e_option_t *e2e;
-
-  data = ioam_analyse_get_data_from_flow_id (flow_id);
-  e2e = (ioam_e2e_option_t *) opt;
-  ip6_ioam_analyse_hbh_e2e (data, &e2e->e2e_hdr, len);
-  return 0;
-}
-
-int
-ip6_ioam_analyse_register_hbh_handler (u8 option,
-				       int options (u32 flow_id,
-						    ip6_hop_by_hop_option_t *
-						    opt, u16 len))
-{
-  ip6_ioam_analyser_main_t *am = &ioam_analyser_main;
-
-  ASSERT ((u32) option < ARRAY_LEN (am->analyse_hbh_handler));
-
-  /* Already registered */
-  if (am->analyse_hbh_handler[option])
-    return (-1);
-
-  am->analyse_hbh_handler[option] = options;
-
-  return (0);
-}
-
-int
-ip6_ioam_analyse_unregister_hbh_handler (u8 option)
-{
-  ip6_ioam_analyser_main_t *am = &ioam_analyser_main;
-
-  ASSERT ((u32) option < ARRAY_LEN (am->analyse_hbh_handler));
-
-  /* Not registered */
-  if (!am->analyse_hbh_handler[option])
-    return (-1);
-
-  am->analyse_hbh_handler[option] = NULL;
-  return (0);
-}
-
-void
-ip6_ioam_analyse_register_handlers ()
-{
-  ip6_ioam_analyse_register_hbh_handler (HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST,
-					 ip6_ioam_analyse_hbh_trace_internal);
-  ip6_ioam_analyse_register_hbh_handler
-    (HBH_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT, ip6_ioam_analyse_hbh_pot);
-  ip6_ioam_analyse_register_hbh_handler (HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE,
-					 ip6_ioam_analyse_hbh_e2e_internal);
-}
-
-void
-ip6_ioam_analyse_unregister_handlers ()
-{
-  ip6_ioam_analyse_unregister_hbh_handler
-    (HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST);
-  ip6_ioam_analyse_unregister_hbh_handler
-    (HBH_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT);
-  ip6_ioam_analyse_unregister_hbh_handler (HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE);
-}
-
-/* *INDENT-OFF* */
-
-/*
- * Node for IP6 analyse - packets
- */
-VLIB_REGISTER_NODE (analyse_node_local) = {
-  .function = ip6_ioam_analyse_node_fn,
-  .name = "ip6-hbh-analyse-local",
-  .vector_size = sizeof (u32),
-  .format_trace = format_analyse_trace,
-  .type = VLIB_NODE_TYPE_INTERNAL,
-  .n_errors = ARRAY_LEN (analyse_error_strings),
-  .error_strings = analyse_error_strings,
-  .n_next_nodes = ANALYSE_N_NEXT,
-  /* edit / add dispositions here */
-  .next_nodes = {
-    [ANALYSE_NEXT_IP4_LOOKUP] = "ip4-lookup",
-    [ANALYSE_NEXT_IP4_DROP] = "ip4-drop",
-  },
-};
-
-/*
- * Node for IP6 analyse - packets
- */
-VLIB_REGISTER_NODE (analyse_node_remote) =
-{
-  .function = ip6_ioam_analyse_node_fn,
-  .name = "ip6-hbh-analyse-remote",
-  .vector_size = sizeof (u32),
-  .format_trace = format_analyse_trace,
-  .type = VLIB_NODE_TYPE_INTERNAL,
-  .n_errors = ARRAY_LEN (analyse_error_strings),
-  .error_strings = analyse_error_strings,
-  .n_next_nodes = ANALYSE_N_NEXT,
-  /* edit / add dispositions here */
-  .next_nodes = {
-    [ANALYSE_NEXT_IP4_LOOKUP] = "ip4-lookup",
-    [ANALYSE_NEXT_IP4_DROP] = "ip4-drop",
-  },
-};
-
-/* *INDENT-ON* */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/dir.dox b/ioam/dir.dox
deleted file mode 100644
index f3389b5..0000000
--- a/ioam/dir.dox
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/**
- @dir
- @brief Inband OAM (iOAM) implementation
-*/
diff --git a/ioam/encap/ip6_ioam_e2e.c b/ioam/encap/ip6_ioam_e2e.c
deleted file mode 100644
index a3dd048..0000000
--- a/ioam/encap/ip6_ioam_e2e.c
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <vlib/vlib.h>
-#include <vnet/vnet.h>
-#include <vppinfra/error.h>
-
-#include <vnet/ip/ip.h>
-
-#include <vppinfra/hash.h>
-#include <vppinfra/error.h>
-#include <vppinfra/elog.h>
-
-#include <vnet/ip/ip6_hop_by_hop.h>
-#include "ip6_ioam_e2e.h"
-
-ioam_e2e_main_t ioam_e2e_main;
-
-static u8 * ioam_e2e_trace_handler (u8 * s,
-                                    ip6_hop_by_hop_option_t *opt)
-{
-  ioam_e2e_option_t * e2e = (ioam_e2e_option_t *)opt;
-  u32 seqno = 0;
-
-  if (e2e)
-    {
-      seqno = clib_net_to_host_u32 (e2e->e2e_hdr.e2e_data);
-    }
-
-  s = format (s, "SeqNo = 0x%Lx", seqno);
-  return s;
-}
-
-int
-ioam_e2e_config_handler (void *data, u8 disable)
-{
-  int *analyse = data;
-
-  /* Register hanlders if enabled */
-  if (!disable)
-    {
-      /* If encap node register for encap handler */
-      if (0 == *analyse)
-        {
-          if (ip6_hbh_register_option(HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE,
-                                      ioam_seqno_encap_handler,
-                                      ioam_e2e_trace_handler) < 0)
-            {
-              return (-1);
-            }
-        }
-      /* If analyze node then register for decap handler */
-      else
-        {
-          if (ip6_hbh_pop_register_option(HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE,
-                                          ioam_seqno_decap_handler) < 0)
-            {
-              return (-1);
-            }
-        }
-      return 0;
-    }
-
-  /* UnRegister handlers */
-  (void) ip6_hbh_unregister_option(HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE);
-  (void) ip6_hbh_pop_unregister_option(HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE);
-  return 0;
-}
-
-int
-ioam_e2e_rewrite_handler (u8 *rewrite_string,
-                          u8 *rewrite_size)
-{
-  ioam_e2e_option_t *e2e_option;
-
-  if (rewrite_string && *rewrite_size == sizeof(ioam_e2e_option_t))
-    {
-      e2e_option = (ioam_e2e_option_t *)rewrite_string;
-      e2e_option->hdr.type = HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE
-          | HBH_OPTION_TYPE_SKIP_UNKNOWN;
-      e2e_option->hdr.length = sizeof (ioam_e2e_option_t) -
-          sizeof (ip6_hop_by_hop_option_t);
-      return(0);
-    }
-  return(-1);
-}
-
-u32
-ioam_e2e_flow_handler (u32 ctx, u8 add)
-{
-  ioam_e2e_data_t *data;
-  u16 i;
-
-  if (add)
-    {
-      pool_get(ioam_e2e_main.e2e_data, data);
-      data->flow_ctx =  ctx;
-      ioam_seqno_init_data(&data->seqno_data);
-      return ((u32) (data - ioam_e2e_main.e2e_data));
-    }
-
-  /* Delete case */
-  for (i = 0; i < vec_len(ioam_e2e_main.e2e_data); i++)
-    {
-      if (pool_is_free_index(ioam_e2e_main.e2e_data, i))
-        continue;
-
-      data = pool_elt_at_index(ioam_e2e_main.e2e_data, i);
-      if (data && (data->flow_ctx == ctx))
-        {
-          pool_put_index(ioam_e2e_main.e2e_data, i);
-          return (0);
-        }
-    }
-  return 0;
-}
-
-static clib_error_t *
-ioam_show_e2e_cmd_fn (vlib_main_t * vm,
-                      unformat_input_t * input,
-                      vlib_cli_command_t * cmd)
-{
-  ioam_e2e_data_t *e2e_data;
-  u8 *s = 0;
-  int i;
-
-  vec_reset_length(s);
-
-  s = format(0, "IOAM E2E information: \n");
-  for (i = 0; i < vec_len(ioam_e2e_main.e2e_data); i++)
-    {
-      if (pool_is_free_index(ioam_e2e_main.e2e_data, i))
-        continue;
-
-      e2e_data = pool_elt_at_index(ioam_e2e_main.e2e_data, i);
-      s = format(s, "Flow name: %s\n", get_flow_name_from_flow_ctx(e2e_data->flow_ctx));
-
-      s = show_ioam_seqno_cmd_fn(s,
-                                 &e2e_data->seqno_data,
-                                 !IOAM_DEAP_ENABLED(e2e_data->flow_ctx));
-    }
-
-  vlib_cli_output(vm, "%v", s);
-  return 0;
-}
-
-
-VLIB_CLI_COMMAND (ioam_show_e2e_cmd, static) = {
-    .path = "show ioam e2e ",
-    .short_help = "show ioam e2e information",
-    .function = ioam_show_e2e_cmd_fn,
-};
-
-/*
- * Init handler E2E headet handling.
- * Init hanlder registers encap, decap, trace and Rewrite handlers.
- */
-static clib_error_t *
-ioam_e2e_init (vlib_main_t * vm)
-{
-  /*
-   * As of now we have only PPC under E2E header.
-   */
-  if (ip6_hbh_config_handler_register(HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE,
-                                      ioam_e2e_config_handler) < 0)
-    {
-      return (clib_error_create("Registration of "
-          "HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE for rewrite failed"));
-    }
-
-  if (ip6_hbh_add_register_option(HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE,
-                                  sizeof(ioam_e2e_option_t),
-                                  ioam_e2e_rewrite_handler) < 0)
-    {
-      return (clib_error_create("Registration of "
-          "HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE for rewrite failed"));
-    }
-
-  if (ip6_hbh_flow_handler_register(HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE,
-                                    ioam_e2e_flow_handler) < 0)
-    {
-      return (clib_error_create("Registration of "
-          "HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE Flow handler failed"));
-    }
-
-  ioam_e2e_main.vlib_main = vm;
-  ioam_e2e_main.vnet_main = vnet_get_main();
-
-  return (0);
-}
-
-/*
- * Init function for the E2E lib.
- * ip6_hop_by_hop_ioam_e2e_init gets called during init.
- */
-/* *INDENT-OFF* */
-VLIB_INIT_FUNCTION (ioam_e2e_init) =
-{
-    .runs_after = VLIB_INITS("ip6_hop_by_hop_ioam_init"),
-};
-/* *INDENT-ON* */
diff --git a/ioam/encap/ip6_ioam_e2e.h b/ioam/encap/ip6_ioam_e2e.h
deleted file mode 100644
index fb83403..0000000
--- a/ioam/encap/ip6_ioam_e2e.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef __included_ip6_ioam_e2e_h__
-#define __included_ip6_ioam_e2e_h__
-
-#include <ioam/lib-e2e/e2e_util.h>
-#include "ip6_ioam_seqno.h"
-
-/* *INDENT-OFF* */
-typedef CLIB_PACKED(struct {
-  ip6_hop_by_hop_option_t hdr;
-  ioam_e2e_packet_t e2e_hdr;
-}) ioam_e2e_option_t;
-/* *INDENT-ON* */
-
-typedef struct ioam_e2e_data_t_ {
-  u32 flow_ctx;
-  u32 pad;
-  ioam_seqno_data seqno_data;
-} ioam_e2e_data_t;
-
-typedef struct {
-  ioam_e2e_data_t *e2e_data;
-  vlib_main_t *vlib_main;
-  vnet_main_t *vnet_main;
-} ioam_e2e_main_t;
-
-extern ioam_e2e_main_t ioam_e2e_main;
-
-static inline ioam_seqno_data *
-ioam_e2ec_get_seqno_data_from_flow_ctx (u32 flow_ctx)
-{
-  ioam_e2e_data_t *data = NULL;
-  u32 index;
-
-  index =  get_flow_data_from_flow_ctx(flow_ctx,
-                                       HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE);
-  data = &ioam_e2e_main.e2e_data[index];
-  return &(data->seqno_data);
-}
-
-static inline u32
-ioam_e2e_get_cur_seqno_from_flow_ctx (u32 flow_ctx)
-{
-  ioam_seqno_data *data = NULL;
-
-  data =  ioam_e2ec_get_seqno_data_from_flow_ctx(flow_ctx);
-  return data->seq_num;
-}
-
-#endif /* __included_ioam_e2e_h__ */
diff --git a/ioam/encap/ip6_ioam_pot.c b/ioam/encap/ip6_ioam_pot.c
deleted file mode 100644
index 99c21b5..0000000
--- a/ioam/encap/ip6_ioam_pot.c
+++ /dev/null
@@ -1,263 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <vlib/vlib.h>
-#include <vnet/vnet.h>
-#include <vppinfra/error.h>
-#include <vnet/ip/ip6.h>
-
-#include <vppinfra/hash.h>
-#include <vppinfra/error.h>
-#include <vppinfra/elog.h>
-
-#include <ioam/encap/ip6_ioam_pot.h>
-#include <ioam/lib-pot/pot_util.h>
-
-#define foreach_ip6_hop_by_hop_ioam_pot_stats				\
-  _(PROCESSED, "Pkts with ip6 hop-by-hop pot options")			\
-  _(PROFILE_MISS, "Pkts with ip6 hop-by-hop pot options but no profile set") \
-  _(PASSED, "Pkts with POT in Policy")					\
-  _(FAILED, "Pkts with POT out of Policy")
-
-static char * ip6_hop_by_hop_ioam_pot_stats_strings[] = {
-#define _(sym,string) string,
-  foreach_ip6_hop_by_hop_ioam_pot_stats
-#undef _
-};
-
-typedef enum {
-#define _(sym,str) IP6_IOAM_POT_##sym,
-  foreach_ip6_hop_by_hop_ioam_pot_stats
-#undef _
-  IP6_IOAM_POT_N_STATS,
-} ip6_ioam_pot_stats_t;
-
-typedef struct {
-  /* stats */
-  u64 counters[ARRAY_LEN(ip6_hop_by_hop_ioam_pot_stats_strings)];
-
-  /* convenience */
-  vlib_main_t * vlib_main;
-  vnet_main_t * vnet_main;
-} ip6_hop_by_hop_ioam_pot_main_t;
-
-ip6_hop_by_hop_ioam_pot_main_t ip6_hop_by_hop_ioam_pot_main;
-
-always_inline void
-ip6_ioam_stats_increment_counter (u32 counter_index, u64 increment)
-{
-  ip6_hop_by_hop_ioam_pot_main_t *hm = &ip6_hop_by_hop_ioam_pot_main;
-
-  hm->counters[counter_index] += increment;
-}
-
-
-static u8 * format_ioam_pot (u8 * s, va_list * args)
-{
-  ioam_pot_option_t * pot0 = va_arg (*args, ioam_pot_option_t *);
-  u64 random, cumulative;
-  random = cumulative = 0;
-  if (pot0)
-    {
-      random = clib_net_to_host_u64 (pot0->random);
-      cumulative = clib_net_to_host_u64 (pot0->cumulative);
-    }
-
-  s = format (s, "random = 0x%Lx, Cumulative = 0x%Lx, Index = 0x%x",
-	      random, cumulative, pot0 ? pot0->reserved_profile_id : ~0);
-  return s;
-}
-
-u8 *
-ip6_hbh_ioam_proof_of_transit_trace_handler (u8 *s, ip6_hop_by_hop_option_t *opt)
-{
-  ioam_pot_option_t *pot;
-
-  s = format (s, "    POT opt present\n");
-  pot = (ioam_pot_option_t *) opt;
-  s = format (s, "         %U\n", format_ioam_pot, pot);
-  return (s);
-}
-
-int
-ip6_hbh_ioam_proof_of_transit_handler (vlib_buffer_t *b,
-				       ip6_header_t *ip,
-				       ip6_hop_by_hop_option_t *opt0)
-{
-  ioam_pot_option_t * pot0;
-  u64 random = 0, cumulative = 0;
-  int rv = 0;
-  u8 pot_profile_index;
-  pot_profile *pot_profile = 0, *new_profile = 0;
-  u8 pot_encap = 0;
-
-  pot0 = (ioam_pot_option_t *) opt0;
-  pot_encap = (pot0->random == 0);
-  pot_profile_index = pot_profile_get_active_id();
-  pot_profile = pot_profile_get_active();
-  if (pot_encap && PREDICT_FALSE(!pot_profile))
-    {
-      ip6_ioam_stats_increment_counter (IP6_IOAM_POT_PROFILE_MISS, 1);
-      return(-1);
-    }
-  if (pot_encap)
-    {
-      pot0->reserved_profile_id =
-	pot_profile_index & PROFILE_ID_MASK;
-      pot_profile_incr_usage_stats(pot_profile);
-    }
-  else
-    { /* Non encap node */
-      if (PREDICT_FALSE(pot0->reserved_profile_id !=
-			pot_profile_index || pot_profile == 0))
-	{
-	  /* New profile announced by encap node. */
-	  new_profile =
-	    pot_profile_find(pot0->reserved_profile_id);
-	  if (PREDICT_FALSE(new_profile == 0 ||
-			    new_profile->valid == 0))
-	    {
-	      ip6_ioam_stats_increment_counter (IP6_IOAM_POT_PROFILE_MISS, 1);
-	      return(-1);
- 	    }
-	  else
-	    {
-	      pot_profile_index = pot0->reserved_profile_id;
-	      pot_profile = new_profile;
-	      pot_profile_set_active(pot_profile_index);
-	      pot_profile_reset_usage_stats(pot_profile);
-	    }
-	}
-      pot_profile_incr_usage_stats(pot_profile);
-    }
-
-  if (pot0->random == 0)
-    {
-      pot0->random = clib_host_to_net_u64(pot_generate_random(pot_profile));
-      pot0->cumulative = 0;
-    }
-  random = clib_net_to_host_u64(pot0->random);
-  cumulative = clib_net_to_host_u64(pot0->cumulative);
-  pot0->cumulative = clib_host_to_net_u64(
-					  pot_update_cumulative(pot_profile,
-								cumulative,
-								random));
-  ip6_ioam_stats_increment_counter (IP6_IOAM_POT_PROCESSED, 1);
-
-  return (rv);
-}
-
-int
-ip6_hbh_ioam_proof_of_transit_pop_handler (vlib_buffer_t *b, ip6_header_t *ip,
-					   ip6_hop_by_hop_option_t *opt0)
-{
-  ioam_pot_option_t * pot0;
-  u64 random = 0;
-  u64 cumulative = 0;
-  int rv = 0;
-  pot_profile *pot_profile = 0;
-  u8 result = 0;
-
-  pot0 = (ioam_pot_option_t *) opt0;
-  random = clib_net_to_host_u64(pot0->random);
-  cumulative = clib_net_to_host_u64(pot0->cumulative);
-  pot_profile = pot_profile_get_active();
-  result =  pot_validate (pot_profile,
-			  cumulative, random);
-
-  if (result == 1)
-    {
-      ip6_ioam_stats_increment_counter (IP6_IOAM_POT_PASSED, 1);
-    }
-  else
-    {
-      ip6_ioam_stats_increment_counter (IP6_IOAM_POT_FAILED, 1);
-    }
-  return (rv);
-}
-
-int ip6_hop_by_hop_ioam_pot_rewrite_handler (u8 *rewrite_string, u8 *rewrite_size)
-{
-  ioam_pot_option_t * pot_option;
-  if (rewrite_string && *rewrite_size == sizeof(ioam_pot_option_t))
-    {
-      pot_option = (ioam_pot_option_t *)rewrite_string;
-      pot_option->hdr.type = HBH_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT
-        | HBH_OPTION_TYPE_DATA_CHANGE_ENROUTE;
-      pot_option->hdr.length = sizeof (ioam_pot_option_t) -
-        sizeof (ip6_hop_by_hop_option_t);
-      return(0);
-    }
-  return(-1);
-}
-
-static clib_error_t *
-ip6_show_ioam_pot_cmd_fn (vlib_main_t * vm,
-			  unformat_input_t * input,
-			  vlib_cli_command_t * cmd)
-{
-  ip6_hop_by_hop_ioam_pot_main_t *hm = &ip6_hop_by_hop_ioam_pot_main;
-  u8 *s = 0;
-  int i = 0;
-
-  for ( i = 0; i < IP6_IOAM_POT_N_STATS; i++)
-    {
-      s = format(s, " %s - %lu\n", ip6_hop_by_hop_ioam_pot_stats_strings[i],
-	       hm->counters[i]);
-    }
-
-  vlib_cli_output(vm, "%v", s);
-  vec_free(s);
-  return 0;
-}
-
-
-VLIB_CLI_COMMAND (ip6_show_ioam_pot_cmd, static) = {
-  .path = "show ioam pot",
-  .short_help = "iOAM pot statistics",
-  .function = ip6_show_ioam_pot_cmd_fn,
-};
-
-
-static clib_error_t *
-ip6_hop_by_hop_ioam_pot_init (vlib_main_t * vm)
-{
-  ip6_hop_by_hop_ioam_pot_main_t * hm = &ip6_hop_by_hop_ioam_pot_main;
-
-  hm->vlib_main = vm;
-  hm->vnet_main = vnet_get_main();
-  clib_memset(hm->counters, 0, sizeof(hm->counters));
-
-  if (ip6_hbh_register_option(HBH_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT, ip6_hbh_ioam_proof_of_transit_handler,
-			      ip6_hbh_ioam_proof_of_transit_trace_handler) < 0)
-    return (clib_error_create("registration of HBH_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT failed"));
-
-  if (ip6_hbh_add_register_option(HBH_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT,
-				  sizeof(ioam_pot_option_t),
-				  ip6_hop_by_hop_ioam_pot_rewrite_handler) < 0)
-    return (clib_error_create("registration of HBH_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT for rewrite failed"));
-
-  if (ip6_hbh_pop_register_option(HBH_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT,
-				  ip6_hbh_ioam_proof_of_transit_pop_handler) < 0)
-    return (clib_error_create("registration of HBH_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT POP failed"));
-
-  return (0);
-}
-
-/* *INDENT-OFF* */
-VLIB_INIT_FUNCTION (ip6_hop_by_hop_ioam_pot_init) =
-{
-  .runs_after = VLIB_INITS("ip6_hop_by_hop_ioam_init"),
-};
-/* *INDENT-OFF* */
diff --git a/ioam/encap/ip6_ioam_pot.h b/ioam/encap/ip6_ioam_pot.h
deleted file mode 100644
index 01ce4ac..0000000
--- a/ioam/encap/ip6_ioam_pot.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef PLUGINS_IOAM_PLUGIN_IOAM_ENCAP_IP6_IOAM_POT_H_
-#define PLUGINS_IOAM_PLUGIN_IOAM_ENCAP_IP6_IOAM_POT_H_
-
-#include <vnet/ip/ip6_hop_by_hop_packet.h>
-
-/* *INDENT-OFF* */
-typedef CLIB_PACKED (struct {
-  ip6_hop_by_hop_option_t hdr;
-  u8 pot_type;
-  #define PROFILE_ID_MASK 0xF
-  u8 reserved_profile_id;	/* 4 bits reserved, 4 bits to carry profile id */
-  u64 random;
-  u64 cumulative;
-}) ioam_pot_option_t;
-/* *INDENT-ON* */
-
-#endif /* PLUGINS_IOAM_PLUGIN_IOAM_ENCAP_IP6_IOAM_POT_H_ */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/encap/ip6_ioam_seqno.c b/ioam/encap/ip6_ioam_seqno.c
deleted file mode 100644
index d1349f7..0000000
--- a/ioam/encap/ip6_ioam_seqno.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#include <vlib/vlib.h>
-#include <vnet/vnet.h>
-#include <vppinfra/error.h>
-
-#include <vnet/ip/ip.h>
-
-#include <vppinfra/hash.h>
-#include <vppinfra/error.h>
-#include <vppinfra/elog.h>
-
-#include "ip6_ioam_seqno.h"
-#include "ip6_ioam_e2e.h"
-
-
-/*
- * This Routine gets called from IPv6 hop-by-hop option handling.
- * Only if we are encap node, then add PPC data.
- * On a Transit(MID) node we dont do anything with E2E headers.
- * On decap node decap is handled by seperate function.
- */
-int
-ioam_seqno_encap_handler (vlib_buffer_t *b, ip6_header_t *ip,
-                          ip6_hop_by_hop_option_t *opt)
-{
-  u32 opaque_index = vnet_buffer(b)->l2_classify.opaque_index;
-  ioam_e2e_option_t * e2e;
-  int rv = 0;
-  ioam_seqno_data *data;
-
-  /* Bypass seqno processing */
-  if (PREDICT_FALSE(opaque_index == 0x7FFFFFFF))
-    return rv;
-
-  data = ioam_e2ec_get_seqno_data_from_flow_ctx(opaque_index);
-  e2e = (ioam_e2e_option_t *) opt;
-  e2e->e2e_hdr.e2e_data = clib_host_to_net_u32(++data->seq_num);
-
-  return (rv);
-}
-
-/*
- * This Routine gets called on POP/Decap node.
- */
-int
-ioam_seqno_decap_handler (vlib_buffer_t *b, ip6_header_t *ip,
-                          ip6_hop_by_hop_option_t *opt)
-{
-  u32 opaque_index = vnet_buffer(b)->l2_classify.opaque_index;
-  ioam_e2e_option_t * e2e;
-  int rv = 0;
-  ioam_seqno_data *data;
-
-  data = ioam_e2ec_get_seqno_data_from_flow_ctx(opaque_index);
-  e2e = (ioam_e2e_option_t *) opt;
-  ioam_analyze_seqno(&data->seqno_rx,
-                     (u64) clib_net_to_host_u32(e2e->e2e_hdr.e2e_data));
-
-  return (rv);
-}
diff --git a/ioam/encap/ip6_ioam_seqno.h b/ioam/encap/ip6_ioam_seqno.h
deleted file mode 100644
index 5c14024..0000000
--- a/ioam/encap/ip6_ioam_seqno.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef __included_ip6_ioam_seqno_h__
-#define __included_ip6_ioam_seqno_h__
-
-#include <vnet/ip/ip6_packet.h>
-#include <vnet/ip/ip6_hop_by_hop.h>
-#include <ioam/lib-e2e/e2e_util.h>
-
-int ioam_seqno_encap_handler(vlib_buffer_t *b, ip6_header_t *ip,
-                             ip6_hop_by_hop_option_t *opt);
-
-int
-ioam_seqno_decap_handler(vlib_buffer_t *b, ip6_header_t *ip,
-                         ip6_hop_by_hop_option_t *opt);
-
-#endif
diff --git a/ioam/encap/ip6_ioam_trace.c b/ioam/encap/ip6_ioam_trace.c
deleted file mode 100644
index fbd9d60..0000000
--- a/ioam/encap/ip6_ioam_trace.c
+++ /dev/null
@@ -1,730 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <vlib/vlib.h>
-#include <vnet/vnet.h>
-#include <vnet/pg/pg.h>
-#include <vppinfra/error.h>
-#include <vpp/app/version.h>
-
-#include <vnet/ip/ip6.h>
-#include <vnet/ip/ip6_hop_by_hop.h>
-#include <vnet/ip/ip6_hop_by_hop_packet.h>
-
-#include <vppinfra/hash.h>
-#include <vppinfra/error.h>
-#include <vppinfra/elog.h>
-#include <vnet/plugin/plugin.h>
-
-#include <ioam/lib-trace/trace_util.h>
-#include <ioam/lib-trace/trace_config.h>
-#include <ioam/encap/ip6_ioam_trace.h>
-#include <ioam/udp-ping/udp_ping.h>
-#include <ioam/udp-ping/udp_ping_packet.h>
-#include <ioam/udp-ping/udp_ping_util.h>
-
-// For transit delay
-#include <timestamp/timestamp.h>
-// For queue depth
-#include <linux/if_packet.h>
-#include <vnet/devices/af_packet/af_packet.h>
-/* Timestamp precision multipliers for seconds, milliseconds, microseconds
- * and nanoseconds respectively.
- */
-static f64 trace_tsp_mul[IOAM_TSP_OPTION_SIZE] = { 1, 1e3, 1e6, 1e9 };
-
-typedef union
-{
-  u64 as_u64;
-  u32 as_u32[2];
-} time_u64_t;
-
-extern ip6_hop_by_hop_ioam_main_t ip6_hop_by_hop_ioam_main;
-extern ip6_main_t ip6_main;
-
-#define foreach_ip6_hop_by_hop_ioam_trace_stats                                \
-  _(PROCESSED, "Pkts with ip6 hop-by-hop trace options")                        \
-  _(PROFILE_MISS, "Pkts with ip6 hop-by-hop trace options but no profile set") \
-  _(UPDATED, "Pkts with trace updated")                                        \
-  _(FULL, "Pkts with trace options but no space")                              \
-  _(LOOPBACK, "Pkts with trace options Loopback")                              \
-  _(LOOPBACK_REPLY, "Pkts with trace options Loopback Reply")
-
-static char *ip6_hop_by_hop_ioam_trace_stats_strings[] = {
-#define _(sym,string) string,
-  foreach_ip6_hop_by_hop_ioam_trace_stats
-#undef _
-};
-
-typedef enum
-{
-#define _(sym,str) IP6_IOAM_TRACE_##sym,
-  foreach_ip6_hop_by_hop_ioam_trace_stats
-#undef _
-    IP6_IOAM_TRACE_N_STATS,
-} ip6_ioam_trace_stats_t;
-
-
-typedef struct
-{
-  /* stats */
-  u64 counters[ARRAY_LEN (ip6_hop_by_hop_ioam_trace_stats_strings)];
-
-  /* convenience */
-  vlib_main_t *vlib_main;
-  vnet_main_t *vnet_main;
-} ip6_hop_by_hop_ioam_trace_main_t;
-
-ip6_hop_by_hop_ioam_trace_main_t ip6_hop_by_hop_ioam_trace_main;
-
-always_inline void
-ip6_ioam_trace_stats_increment_counter (u32 counter_index, u64 increment)
-{
-  ip6_hop_by_hop_ioam_trace_main_t *hm = &ip6_hop_by_hop_ioam_trace_main;
-
-  hm->counters[counter_index] += increment;
-}
-static u8 *
-format_ioam_data_list_element (u8 * s, va_list * args)
-{
-  u32 *elt = va_arg (*args, u32 *);
-  u32 *trace_type_p = va_arg (*args, u32 *);
-  u32 trace_type = *trace_type_p;
-
-  if (trace_type & IOAM_BIT_TTL_NODEID_SHORT)
-  {
-    u32 ttl_node_id_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, ", ttl: 0x%x, node id short: 0x%x",
-    ttl_node_id_host_byte_order >> 24,
-    ttl_node_id_host_byte_order & IOAM_EMPTY_FIELD_U24);
-
-    elt++;
-  }
-  if (trace_type & IOAM_BIT_ING_EGR_INT_SHORT)
-  {
-    u32 ingress_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, ", ingress sw: %d, egress sw: %d",
-    ingress_host_byte_order >> 16,
-    ingress_host_byte_order & IOAM_EMPTY_FIELD_U16);
-    elt++;
-  }
-  if (trace_type & IOAM_BIT_TIMESTAMP_SEC)
-  {
-    u32 ts_in_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, ", timestamp (s): 0x%x", ts_in_host_byte_order);
-    elt++;
-  }
-
-  if (trace_type & IOAM_BIT_TIMESTAMP_SUB_SEC)
-  {
-    u32 ts_sub_in_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, ", timestamp (sub-sec): 0x%x", ts_sub_in_host_byte_order);
-    elt++;
-  }
-
-  if (trace_type & IOAM_BIT_TRANSIT_DELAY)
-  {
-    u32 transit_delay_in_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, ", transit delay (ns): 0x%x", transit_delay_in_host_byte_order);
-    elt++;
-  }
-
-  if (trace_type & IOAM_BIT_APPDATA_SHORT_DATA)
-  {
-    u32 appdata_in_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, ", appdata: 0x%x", appdata_in_host_byte_order);
-    elt++;
-  }
-
-  if (trace_type & IOAM_BIT_QUEUE_DEPTH)
-  {
-    u32 queue_in_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, ", queue depth: 0x%x", queue_in_host_byte_order);
-    elt++;
-  }
-
-  if (trace_type & IOAM_BIT_CHECKSUM_COMPLEMENT)
-  {
-    u32 cc_in_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, ", checksum complement: 0x%x", cc_in_host_byte_order);
-    elt++;
-  }
-
-  if (trace_type & IOAM_BIT_TTL_NODEID_WIDE)
-  {
-    u64 *ttl_node_id_p = (u64 *)elt;
-    u64 ttl_node_id = clib_net_to_host_u64 (*ttl_node_id_p);
-    elt += 2;
-
-    s = format (s, ", ttl: 0x%x, node id wide: 0x%Lx",
-                ttl_node_id >> 56,
-                (ttl_node_id & IOAM_EMPTY_FIELD_U56));
-
-  }
-
-  if (trace_type & IOAM_BIT_ING_EGR_INT_WIDE)
-  {
-    u32 ingress_wide_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, ", ingress hw: %d", ingress_wide_host_byte_order);
-    elt++;
-
-    u32 egress_wide_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, ", egress hw: %d", egress_wide_host_byte_order);
-    elt++;
-  }
-
-  if (trace_type & IOAM_BIT_APPDATA_WIDE_DATA)
-  {
-    u64 *app_data_wide_host_byte_order_p = (u64 *)elt;
-    u64 app_data_wide_host_byte_order = clib_net_to_host_u64 (*app_data_wide_host_byte_order_p);
-    s = format (s, ", appdata wide: 0x%x", app_data_wide_host_byte_order);
-    elt += 2;
-  }
-
-  if (trace_type & IOAM_BIT_BUFFER_OCCUPANCY)
-  {
-    u32 buffer_occ_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, ", buffers available: %d", buffer_occ_host_byte_order);
-    elt++;
-  }
-
-  if (trace_type & IOAM_BIT_VAR_LEN_OP_ST_SNSH)
-  {
-    u32 opaque_len_id_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, ", opaque len: %d , opaque id: 0x%x", \
-    IOAM_GET_OPAQUE_LEN(opaque_len_id_host_byte_order), IOAM_OPAQUE_SCHEMEID_MASK & opaque_len_id_host_byte_order);
-    elt++;
-  }
-  return s;
-}
-
-int
-ip6_ioam_trace_get_sizeof_handler (u32 * result)
-{
-  u32 size = 0;
-  u32 trace_data_size = 0;
-  trace_profile *profile = NULL;
-
-  *result = 0;
-
-  profile = trace_profile_find ();
-
-  if (PREDICT_FALSE (!profile))
-  {
-    ip6_ioam_trace_stats_increment_counter (IP6_IOAM_TRACE_PROFILE_MISS, 1);
-    return (-1);
-  }
-
-  trace_data_size = fetch_trace_data_size (profile);
-  if (PREDICT_FALSE (trace_data_size == 0))
-  {
-    return VNET_API_ERROR_INVALID_VALUE;
-  }
-
-  if (PREDICT_FALSE (profile->num_elts * trace_data_size > 254))
-  {
-    return VNET_API_ERROR_INVALID_VALUE;
-  }
-  size += sizeof (ioam_trace_option_t) + (profile->num_elts * trace_data_size);
-  *result = size;
-
-  return 0;
-}
-
-int
-ip6_hop_by_hop_ioam_trace_rewrite_handler (u8 * rewrite_string, u8 * rewrite_size)
-{
-  ioam_trace_option_t *trace_option = NULL;
-  u32 trace_data_size = 0;
-  u8 trace_option_elts = 0;
-  trace_profile *profile = NULL;
-
-  profile = trace_profile_find ();
-
-  if (PREDICT_FALSE (!profile))
-  {
-    ip6_ioam_trace_stats_increment_counter (IP6_IOAM_TRACE_PROFILE_MISS, 1);
-    return (-1);
-  }
-
-  if (PREDICT_FALSE (!rewrite_string))
-  {
-    return -1;
-  }
-
-  trace_option_elts = profile->num_elts;
-  trace_data_size = fetch_trace_data_size (profile);
-  trace_option = (ioam_trace_option_t *) rewrite_string;
-
-  trace_option->hdr.type = HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST | HBH_OPTION_TYPE_DATA_CHANGE_ENROUTE;
-  // LENGTH
-  trace_option->hdr.length = sizeof(ioam_trace_hdr_t) + (trace_option_elts * trace_data_size) + 2; /* ip6_hop_by_hop_option_t: reserved and ioam_type */
-  trace_option->hdr.ioam_type = profile->option_type;
-  // ioam_trace_hdr_t things
-  trace_option->trace_hdr.namespace_id = clib_host_to_net_u16(profile->namespace_id);
-  u16 node_len = trace_data_size >> 2; // In 4-octets
-  if(IOAM_GET_OPAQUE_LEN(profile->opaque.len_schemeid))
-  {
-    node_len += IOAM_GET_OPAQUE_LEN(profile->opaque.len_schemeid); // Should already be in 4 octets
-  }
-  u16 nlfrl = IOAM_SET_NODE_LEN(node_len);
-  nlfrl |= (IOAM_REMAIN_LEN_MASK & trace_option_elts);
-  trace_option->trace_hdr.node_len_flags_remaining_len = clib_host_to_net_u16(nlfrl);
-  trace_option->trace_hdr.trace_type = IOAM_SET_TRACETYPE(profile->trace_type);
-  // LENGTH
-  *rewrite_size = sizeof (ioam_trace_option_t) + (trace_option_elts * trace_data_size);
-  return 0;
-}
-always_inline void
-ip6_hbh_ioam_loopback_handler (vlib_buffer_t * b, ip6_header_t * ip, ioam_trace_option_t * trace)
-{
-  u32 buf_index;
-  ip6_hop_by_hop_ioam_main_t *hm = &ip6_hop_by_hop_ioam_main;
-  vlib_buffer_t *b0;
-  vlib_frame_t *nf = 0;
-  u32 *to_next;
-  vlib_node_t *next_node;
-  ip6_header_t *ip6;
-  ip6_hop_by_hop_header_t *hbh;
-  ioam_trace_option_t *opt;
-  udp_ping_t *udp;
-
-  b0 = vlib_buffer_copy (hm->vlib_main, b);
-  if (b0 == NULL)
-    return;
-
-  buf_index = vlib_get_buffer_index (hm->vlib_main, b0);
-  next_node = vlib_get_node_by_name (hm->vlib_main, (u8 *) "ip6-lookup");
-  nf = vlib_get_frame_to_node (hm->vlib_main, next_node->index);
-  nf->n_vectors = 0;
-  to_next = vlib_frame_vector_args (nf);
-
-  vnet_buffer (b0)->sw_if_index[VLIB_RX] = 0;
-  vnet_buffer (b0)->sw_if_index[VLIB_TX] = ~0;
-
-  ip6 = vlib_buffer_get_current (b0);
-  hbh = (ip6_hop_by_hop_header_t *) (ip6 + 1);
-  opt = (ioam_trace_option_t *)ip6_hbh_get_option (hbh, HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST);
-
-  udp = (udp_ping_t *) ((u8 *) hbh + ((hbh->length + 1) << 3));
-  udp_ping_create_reply_from_probe_ip6 (ip6, hbh, udp);
-  ip6_hbh_ioam_trace_set_flag_bit (opt, IOAM_BIT_FLAG_LOOPBACK_REPLY);
-
-  *to_next = buf_index;
-  nf->n_vectors++;
-  to_next++;
-
-  vlib_put_frame_to_node (hm->vlib_main, next_node->index, nf);
-  ip6_ioam_trace_stats_increment_counter (IP6_IOAM_TRACE_LOOPBACK, 1);
-}
-int
-ip6_hbh_ioam_trace_data_list_handler (vlib_buffer_t * b, ip6_header_t * ip, ip6_hop_by_hop_option_t * opt)
-{
-  ip6_hop_by_hop_ioam_main_t *hm = &ip6_hop_by_hop_ioam_main;
-  u8 elt_index = 0;
-  ioam_trace_option_t *trace = (ioam_trace_option_t *) opt;
-  u32 adj_index = vnet_buffer (b)->ip.adj_index[VLIB_TX];
-  ip_adjacency_t *adj = adj_get (adj_index);
-  u32 *elt;
-  int rv = 0;
-  trace_profile *profile = NULL;
-
-  profile = trace_profile_find ();
-
-  if (PREDICT_FALSE (!profile))
-  {
-    ip6_ioam_trace_stats_increment_counter (IP6_IOAM_TRACE_PROFILE_MISS, 1);
-    return (-1);
-  }
-
-  // Ignore if namespace ID is different
-  if(clib_net_to_host_u16(trace->trace_hdr.namespace_id) != profile->namespace_id)
-  {
-    return rv;
-  }
-
-  if(profile->node_type & IOAM_NODE_DECAP)
-  {
-    vnet_buffer (b)->l2_classify.opaque_index |= 0x80000000;
-  }
-
-  /* Don't trace loopback reply packets */
-  u16 nlfrl_host = clib_net_to_host_u16(trace->trace_hdr.node_len_flags_remaining_len);
-  if ((IOAM_FLAGS_MASK & nlfrl_host) & IOAM_BIT_FLAG_LOOPBACK_REPLY)
-  {
-    ip6_ioam_trace_stats_increment_counter (IP6_IOAM_TRACE_LOOPBACK_REPLY, 1);
-    return rv;
-  }
-
-  u32 data_list_elts_left = IOAM_REMAIN_LEN_MASK & nlfrl_host;
-
-  if (PREDICT_TRUE (data_list_elts_left))
-  {
-    data_list_elts_left--;
-    nlfrl_host &= (~IOAM_REMAIN_LEN_MASK);
-    nlfrl_host |= data_list_elts_left;
-    trace->trace_hdr.node_len_flags_remaining_len = clib_host_to_net_u16(nlfrl_host);
-    /* fetch_trace_data_size returns in bytes. Convert it to 4-bytes
-      * to skip to this node's location.
-      */
-    elt_index = data_list_elts_left * fetch_trace_data_size (profile) / 4;
-    elt = &trace->trace_hdr.data_list[elt_index];
-
-    // START writing the telemtry info
-    u32 trace_type = IOAM_GET_TRACETYPE(trace->trace_hdr.trace_type);
-
-    time_u64_t time_u64;
-    // reports TTL and user defined node-id-short, different from -wide
-    if (trace_type & IOAM_BIT_TTL_NODEID_SHORT)
-    {
-      u32 node_id = profile->node_id_short;
-      if(!node_id)
-      {
-        node_id = IOAM_EMPTY_FIELD_U24;
-      }
-      *elt = clib_host_to_net_u32 ((ip->hop_limit << 24) | node_id);
-      elt++;
-    }
-    // reports software interface index
-    if (trace_type & IOAM_BIT_ING_EGR_INT_SHORT)
-    {
-      u32 rxid = (vnet_buffer (b)->sw_if_index[VLIB_RX] & 0xFFFF);
-      u32 txid = (adj->rewrite_header.sw_if_index & 0xFFFF);
-      if(!rxid)
-      {
-        rxid = IOAM_EMPTY_FIELD_U16;
-      }
-      if(!txid)
-      {
-        txid = IOAM_EMPTY_FIELD_U16;
-      }
-      *elt = clib_host_to_net_u32((rxid << 16) | txid);
-      elt++;
-    }
-    // time stamp in secs
-    if (trace_type & IOAM_BIT_TIMESTAMP_SEC)
-    {
-      /* Send least significant 32 bits */
-      f64 time_f64 = (f64) (((f64) hm->unix_time_0) + (vlib_time_now (hm->vlib_main) - hm->vlib_time_0));
-      time_u64.as_u64 = time_f64 * trace_tsp_mul[IOAM_TSP_SECONDS];
-      if(!time_u64.as_u32[0])
-      {
-        time_u64.as_u32[0] = IOAM_EMPTY_FIELD_U32;
-      }
-      *elt = clib_host_to_net_u32 (time_u64.as_u32[0]);
-      elt++;
-    }
-    // time stamp in user defined ts-format
-    if (trace_type & IOAM_BIT_TIMESTAMP_SUB_SEC)
-    {
-      /* Send least significant 32 bits */
-      f64 time_sub_f64 = (f64) (((f64) hm->unix_time_0) + (vlib_time_now (hm->vlib_main) - hm->vlib_time_0));
-      time_u64.as_u64 = time_sub_f64 * trace_tsp_mul[profile->ts_format];
-      if(!time_u64.as_u32[0])
-      {
-        time_u64.as_u32[0] = IOAM_EMPTY_FIELD_U32;
-      }
-      *elt = clib_host_to_net_u32 (time_u64.as_u32[0]);
-      elt++;
-    }
-    // reports hop delay from ingress (uses timestamp plugin) to here, though
-    // not exactly the 'egress' time, but close to it and provides good insight in nano secs
-    if (trace_type & IOAM_BIT_TRANSIT_DELAY)
-    {
-      /* Ingress timestamp meta in buffer2->unused data */
-      timestamp_meta_t *time_meta = (void *)  &vnet_buffer2 (b)->unused[0];
-      // Copy the ptr to the location it needs to be stored in the packet, egress timestamp node will handle the rest
-      time_meta->ptr_to_ioam_transit_delay = elt;
-      // could mean CLIB_UNIX not defined, always added in case it's not possible to add stamp
-      *elt = clib_host_to_net_u32 (IOAM_EMPTY_FIELD_U32);
-      elt++;
-    }
-    // user defined app data, different from app-data-wide
-    if (trace_type & IOAM_BIT_APPDATA_SHORT_DATA)
-    {
-      *elt = clib_host_to_net_u32(profile->app_data_short);
-      elt++;
-    }
-    /*
-    * Reporting is dependent on what device is selected, see device_driver_info.c
-    */
-    if (trace_type & IOAM_BIT_QUEUE_DEPTH)
-    {
-      u32 depth = IOAM_EMPTY_FIELD_U32;
-      if (profile->queue_depth_type & QUEUE_DEPTH_AF_PACKET)
-      {
-        // Get TX hardware interface index
-        u32 txid = adj->rewrite_header.sw_if_index;
-        txid = (vnet_get_sup_hw_interface (hm->vnet_main, txid))->hw_if_index;
-        af_packet_main_t *am = &af_packet_main;
-        /* Maybe there's a better way to obtain apif from hw_if_index */
-        vnet_hw_interface_t *hw = vnet_get_hw_interface (hm->vnet_main, txid);
-        af_packet_if_t *apif = pool_elt_at_index (am->interfaces, hw->dev_instance);
-        u8 *tx_block_start = apif->rings->ring_start_addr; // modify
-        struct tpacket2_hdr *tph_tx = (struct tpacket2_hdr *)tx_block_start;
-        u32 frame_size = apif->tx_queues->tx_req->tp_frame_size;
-        u32 frame_num = apif->tx_queues->tx_req->tp_frame_nr;
-        do
-        {
-          if (tph_tx->tp_status == TP_STATUS_AVAILABLE)
-          {
-            depth++;
-          }
-          tph_tx = (struct tpacket2_hdr *) (((u8 *)tph_tx) + frame_size);
-        } while (--frame_num);
-      }
-      // Trick here is similar to transit delay except, the queue depth is saved in unused[7]
-      else if (profile->queue_depth_type & QUEUE_DEPTH_DPDK)
-      {
-        u32 *queueSize_queueDepth = &vnet_buffer2 (b)->unused[7];
-        // Upper bytes is the total queue size, we only intrested in lower
-        depth = 0x0000FFFF & clib_net_to_host_u32(*queueSize_queueDepth);
-      }
-      *elt = clib_host_to_net_u32 (depth);
-      elt++;
-    }
-    /* TODO */
-    if (trace_type & IOAM_BIT_CHECKSUM_COMPLEMENT)
-    {
-      *elt = IOAM_EMPTY_FIELD_U32;
-      elt++;
-    }
-    // reports TTL and user defined node id (different from node-id-short)
-    if (trace_type & IOAM_BIT_TTL_NODEID_WIDE)
-    {
-      u64 *elt_tmp = (u64 *)elt;
-      u64 node_id = profile->node_id_wide;
-      if(!node_id)
-      {
-        node_id = IOAM_EMPTY_FIELD_U56;
-      }
-      *elt_tmp = clib_host_to_net_u64 ( ( ((u64)ip->hop_limit) << 56 ) | node_id);
-      elt += 2;
-    }
-    // reports hardware interface index
-    if (trace_type & IOAM_BIT_ING_EGR_INT_WIDE)
-    {
-      ip6_hop_by_hop_ioam_trace_main_t *hm = &ip6_hop_by_hop_ioam_trace_main;
-      u32 rxid = vnet_buffer (b)->sw_if_index[VLIB_RX];
-      u32 txid = adj->rewrite_header.sw_if_index;
-      rxid = (vnet_get_sup_hw_interface (hm->vnet_main, rxid))->hw_if_index;
-      txid = (vnet_get_sup_hw_interface (hm->vnet_main, txid))->hw_if_index;
-      if(!rxid)
-      {
-        rxid = IOAM_EMPTY_FIELD_U32;
-      }
-      if(!txid)
-      {
-        txid = IOAM_EMPTY_FIELD_U32;
-      }
-      *elt = clib_host_to_net_u32 (rxid);
-      elt++;
-      *elt = clib_host_to_net_u32 (txid);
-      elt++;
-    }
-    // user defined app data, different from -short
-    if (trace_type & IOAM_BIT_APPDATA_WIDE_DATA)
-    {
-      u64 *elt_tmp = (u64 *)elt;
-      *elt_tmp = clib_host_to_net_u64 (profile->app_data_wide);
-      elt += 2;
-    }
-    // reports the number of buffer available in this packet's mem pool
-    if (trace_type & IOAM_BIT_BUFFER_OCCUPANCY)
-    {
-      vlib_buffer_pool_t *bp = vlib_get_buffer_pool (vlib_get_main(), b->buffer_pool_index);
-      u32 buff_avail = IOAM_EMPTY_FIELD_U32;
-      if(bp)
-      {
-        buff_avail = bp->n_avail;
-      }
-      *elt = clib_host_to_net_u32(buff_avail);
-      elt++;
-    }
-    // user defined opaque data
-    if (trace_type & IOAM_BIT_VAR_LEN_OP_ST_SNSH)
-    {
-      u32 schema = profile->opaque.len_schemeid & IOAM_OPAQUE_SCHEMEID_MASK;
-      u32 len = IOAM_GET_OPAQUE_LEN(profile->opaque.len_schemeid);
-      opaque_scheme_t *opq = (opaque_scheme_t *)elt;
-      if(!schema || !len)
-      {
-        opq->len_schemeid = IOAM_EMPTY_FIELD_U32;
-      }
-      else
-      {
-        opq->len_schemeid = clib_host_to_net_u32(profile->opaque.len_schemeid);
-        // Endianess taken care in trace_profile_create
-        clib_memcpy_fast (opq->data, profile->opaque.data, len << 2);
-        // (1+) for opaque header and len is in 4 octet multipes
-        elt += 1 + len;
-      }
-    }
-
-    if (PREDICT_FALSE ((nlfrl_host & IOAM_FLAGS_MASK) & IOAM_BIT_FLAG_LOOPBACK))
-    {
-      /* if loopback flag set then copy the packet
-      * and send it back to source */
-      ip6_hbh_ioam_loopback_handler (b, ip, trace);
-    }
-
-    ip6_ioam_trace_stats_increment_counter (IP6_IOAM_TRACE_UPDATED, 1);
-  }
-  else
-  {
-    ip6_ioam_trace_stats_increment_counter (IP6_IOAM_TRACE_FULL, 1);
-  }
-  return (rv);
-}
-
-u8 *
-ip6_hbh_ioam_trace_data_list_trace_handler (u8 * s, ip6_hop_by_hop_option_t * opt)
-{
-  ioam_trace_option_t *trace;
-  u8 trace_data_size_in_words = 0;
-  u32 *elt;
-  int elt_index = 0;
-
-  trace = (ioam_trace_option_t *) opt;
-
-  s = format (s, " namespace id %d, trace type 0x%x, %d elts left, %d bytes per node\n",
-                clib_net_to_host_u16(trace->trace_hdr.namespace_id),
-                IOAM_GET_TRACETYPE(trace->trace_hdr.trace_type),
-                clib_net_to_host_u16(trace->trace_hdr.node_len_flags_remaining_len) & IOAM_REMAIN_LEN_MASK,
-                IOAM_GET_NODE_LEN(clib_net_to_host_u16(trace->trace_hdr.node_len_flags_remaining_len))<<2);
-  trace_data_size_in_words = fetch_trace_data_size (trace_profile_find()) / 4;
-  elt = &trace->trace_hdr.data_list[0];
-  u32 trace_type = IOAM_GET_TRACETYPE(trace->trace_hdr.trace_type);
-  while ((u8 *) elt <
-	 ((u8 *) (&trace->trace_hdr.data_list[0]) + trace->hdr.length - sizeof(ioam_trace_hdr_t) - 2)) /* ip6_hop_by_hop_option_t: reserved and ioam_type */
-  {
-    s = format (s, "    [%d]%U\n", elt_index, format_ioam_data_list_element, elt, &trace_type);
-    elt_index++;
-    elt += trace_data_size_in_words;
-  }
-  return (s);
-}
-
-
-static clib_error_t *
-ip6_show_ioam_trace_cmd_fn (vlib_main_t * vm, unformat_input_t * input, vlib_cli_command_t * cmd)
-{
-  ip6_hop_by_hop_ioam_trace_main_t *hm = &ip6_hop_by_hop_ioam_trace_main;
-  u8 *s = 0;
-  int i = 0;
-
-  for (i = 0; i < IP6_IOAM_TRACE_N_STATS; i++)
-  {
-    s =
-      format (s, " %s - %lu\n", ip6_hop_by_hop_ioam_trace_stats_strings[i], hm->counters[i]);
-  }
-
-  vlib_cli_output (vm, "%v", s);
-  vec_free (s);
-  return 0;
-}
-
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (ip6_show_ioam_trace_cmd, static) = {
-  .path = "show ioam trace",
-  .short_help = "iOAM trace statistics",
-  .function = ip6_show_ioam_trace_cmd_fn,
-};
-/* *INDENT-ON* */
-
-/* *INDENT-OFF* */
-VLIB_PLUGIN_REGISTER () = {
-    .version = VPP_BUILD_VER,
-    .description = "Inbound Operations, Administration, and Maintenance (OAM)",
-};
-/* *INDENT-ON* */
-
-static clib_error_t *
-ip6_hop_by_hop_ioam_trace_init (vlib_main_t * vm)
-{
-  ip6_hop_by_hop_ioam_trace_main_t *hm = &ip6_hop_by_hop_ioam_trace_main;
-
-  hm->vlib_main = vm;
-  hm->vnet_main = vnet_get_main ();
-  clib_memset (hm->counters, 0, sizeof (hm->counters));
-
-  if (ip6_hbh_register_option
-      (HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST,
-       ip6_hbh_ioam_trace_data_list_handler,
-       ip6_hbh_ioam_trace_data_list_trace_handler) < 0)
-    return (clib_error_create
-	    ("registration of HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST failed"));
-
-  if (ip6_hbh_add_register_option (HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST,
-				   sizeof (ioam_trace_option_t),
-				   ip6_hop_by_hop_ioam_trace_rewrite_handler)
-      < 0)
-    return (clib_error_create
-	    ("registration of HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST for rewrite failed"));
-
-  return (0);
-}
-
-/* *INDENT-OFF* */
-VLIB_INIT_FUNCTION (ip6_hop_by_hop_ioam_trace_init) =
-{
-  .runs_after = VLIB_INITS ("ip_main_init", "ip6_lookup_init",
-                            "ip6_hop_by_hop_ioam_init"),
-};
-/* *INDENT-ON* */
-
-int
-ip6_trace_profile_cleanup (void)
-{
-  ip6_hop_by_hop_ioam_main_t *hm = &ip6_hop_by_hop_ioam_main;
-
-  hm->options_size[HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST] = 0;
-  return 0;
-
-}
-
-int
-ip6_trace_profile_setup (void)
-{
-  u32 trace_size = 0;
-  ip6_hop_by_hop_ioam_main_t *hm = &ip6_hop_by_hop_ioam_main;
-
-  trace_profile *profile = NULL;
-
-  profile = trace_profile_find ();
-
-  if (PREDICT_FALSE (!profile))
-  {
-    ip6_ioam_trace_stats_increment_counter (IP6_IOAM_TRACE_PROFILE_MISS, 1);
-    return (-1);
-  }
-
-  if (ip6_ioam_trace_get_sizeof_handler (&trace_size) < 0)
-  {
-    return (-1);
-  }
-  // rewrite size for rewrite handler is set here
-  // LENGTH
-  hm->options_size[HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST] = trace_size;
-  return (0);
-}
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/encap/ip6_ioam_trace.h b/ioam/encap/ip6_ioam_trace.h
deleted file mode 100644
index 57ff755..0000000
--- a/ioam/encap/ip6_ioam_trace.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * trace_util.h -- Trace Profile Utility header
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef PLUGINS_IOAM_PLUGIN_IOAM_ENCAP_IP6_IOAM_TRACE_H_
-#define PLUGINS_IOAM_PLUGIN_IOAM_ENCAP_IP6_IOAM_TRACE_H_
-
-#include <vnet/ip/ip6_hop_by_hop_packet.h>
-#include <ioam/lib-trace/trace_util.h>
-
-/* *INDENT-OFF* */
-typedef CLIB_PACKED(struct {
-  ip6_hop_by_hop_option_t hdr;
-  ioam_trace_hdr_t trace_hdr;
-}) ioam_trace_option_t;
-/* *INDENT-ON* */
-
-always_inline void
-ip6_hbh_ioam_trace_set_bit (ioam_trace_option_t * trace, u32 trace_bit)
-{
-  ioam_tracetype_set_bit (&trace->trace_hdr, trace_bit);
-}
-
-always_inline void
-ip6_hbh_ioam_trace_set_flag_bit (ioam_trace_option_t * trace, u32 flag_bit)
-{
-  ioam_traceflag_set_bit (&trace->trace_hdr, flag_bit);
-}
-
-always_inline void
-ip6_hbh_ioam_trace_reset_bit (ioam_trace_option_t * trace, u32 trace_bit)
-{
-  ioam_tracetype_reset_bit (&trace->trace_hdr, trace_bit);
-}
-
-always_inline void
-ip6_hbh_ioam_trace_reset_flag_bit (ioam_trace_option_t * trace, u32 flag_bit)
-{
-  ioam_traceflag_reset_bit (&trace->trace_hdr, flag_bit);
-}
-
-#endif /* PLUGINS_IOAM_PLUGIN_IOAM_ENCAP_IP6_IOAM_TRACE_H_ */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/export-common/ioam_export.h b/ioam/export-common/ioam_export.h
deleted file mode 100644
index 1b764f6..0000000
--- a/ioam/export-common/ioam_export.h
+++ /dev/null
@@ -1,635 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef __included_ioam_export_h__
-#define __included_ioam_export_h__
-
-#include <vnet/vnet.h>
-#include <vnet/ip/ip.h>
-#include <vnet/ip/ip_packet.h>
-#include <vnet/ip/ip4_packet.h>
-#include <vnet/ip/ip6_packet.h>
-#include <vnet/ip/ip6_hop_by_hop.h>
-#include <vnet/udp/udp_local.h>
-#include <vnet/udp/udp_packet.h>
-#include <vnet/ipfix-export/ipfix_packet.h>
-
-#include <vppinfra/pool.h>
-#include <vppinfra/hash.h>
-#include <vppinfra/error.h>
-#include <vppinfra/elog.h>
-#include <vppinfra/lock.h>
-
-#include <vlib/threads.h>
-
-typedef struct ioam_export_buffer
-{
-  /** Required for pool_get_aligned */
-  CLIB_CACHE_LINE_ALIGN_MARK (cacheline0);
-  /* Allocated buffer */
-  u32 buffer_index;
-  u64 touched_at;
-  u8 records_in_this_buffer;
-} ioam_export_buffer_t;
-
-
-typedef struct
-{
-  /* API message ID base */
-  u16 msg_id_base;
-  u16 set_id;
-
-  /* TODO: to support multiple collectors all this has to be grouped and create a vector here */
-  u8 *record_header;
-  u32 sequence_number;
-  u32 domain_id;
-
-  /* ipfix collector, our ip address */
-  ip4_address_t ipfix_collector;
-  ip4_address_t src_address;
-
-  /* Pool of ioam_export_buffer_t */
-  ioam_export_buffer_t *buffer_pool;
-  /* Vector of per thread ioam_export_buffer_t to buffer pool index */
-  u32 *buffer_per_thread;
-  /* Lock per thread to swap buffers between worker and timer process */
-  clib_spinlock_t *lockp;
-
-  /* time scale transform */
-  u32 unix_time_0;
-  f64 vlib_time_0;
-
-  /* convenience */
-  vlib_main_t *vlib_main;
-  vnet_main_t *vnet_main;
-  ethernet_main_t *ethernet_main;
-  u32 next_node_index;
-
-  uword my_hbh_slot;
-  u32 export_process_node_index;
-} ioam_export_main_t;
-
-
-#define DEFAULT_EXPORT_SIZE (3 * CLIB_CACHE_LINE_BYTES)
-/*
- *  Number of records in a buffer
- * ~(MTU (1500) - [ip hdr(40) + UDP(8) + ipfix (24)]) / DEFAULT_EXPORT_SIZE
- */
-#define DEFAULT_EXPORT_RECORDS 7
-
-inline static void
-ioam_export_set_next_node (ioam_export_main_t * em, u8 * next_node_name)
-{
-  vlib_node_t *next_node;
-
-  next_node = vlib_get_node_by_name (em->vlib_main, next_node_name);
-  em->next_node_index = next_node->index;
-}
-
-inline static void
-ioam_export_reset_next_node (ioam_export_main_t * em)
-{
-  vlib_node_t *next_node;
-
-  next_node = vlib_get_node_by_name (em->vlib_main, (u8 *) "ip4-lookup");
-  em->next_node_index = next_node->index;
-}
-
-always_inline ioam_export_buffer_t *
-ioam_export_get_my_buffer (ioam_export_main_t * em, u32 thread_id)
-{
-
-  if (vec_len (em->buffer_per_thread) > thread_id)
-    return (pool_elt_at_index
-	    (em->buffer_pool, em->buffer_per_thread[thread_id]));
-  return (0);
-}
-
-inline static int
-ioam_export_buffer_add_header (ioam_export_main_t * em, vlib_buffer_t * b0)
-{
-  clib_memcpy_fast (b0->data, em->record_header, vec_len (em->record_header));
-  b0->current_data = 0;
-  b0->current_length = vec_len (em->record_header);
-  b0->flags |= VLIB_BUFFER_TOTAL_LENGTH_VALID;
-  return (1);
-}
-
-inline static int
-ioam_export_init_buffer (ioam_export_main_t * em, vlib_main_t * vm,
-			 ioam_export_buffer_t * eb)
-{
-  vlib_buffer_t *b = 0;
-
-  if (!eb)
-    return (-1);
-  /* TODO: Perhaps buffer init from template here */
-  if (vlib_buffer_alloc (vm, &(eb->buffer_index), 1) != 1)
-    return (-2);
-  eb->records_in_this_buffer = 0;
-  eb->touched_at = vlib_time_now (vm);
-  b = vlib_get_buffer (vm, eb->buffer_index);
-  (void) ioam_export_buffer_add_header (em, b);
-  vnet_buffer (b)->sw_if_index[VLIB_RX] = 0;
-  vnet_buffer (b)->sw_if_index[VLIB_TX] = ~0;
-  return (1);
-}
-
-inline static void
-ioam_export_thread_buffer_free (ioam_export_main_t * em)
-{
-  vlib_main_t *vm = em->vlib_main;
-  ioam_export_buffer_t *eb = 0;
-  int i;
-  for (i = 0; i < vec_len (em->buffer_per_thread); i++)
-    {
-      eb = pool_elt_at_index (em->buffer_pool, em->buffer_per_thread[i]);
-      if (eb)
-	vlib_buffer_free (vm, &(eb->buffer_index), 1);
-    }
-  for (i = 0; i < vec_len (em->lockp); i++)
-    clib_mem_free ((void *) em->lockp[i]);
-  vec_free (em->buffer_per_thread);
-  pool_free (em->buffer_pool);
-  vec_free (em->lockp);
-  em->buffer_per_thread = 0;
-  em->buffer_pool = 0;
-  em->lockp = 0;
-}
-
-inline static int
-ioam_export_thread_buffer_init (ioam_export_main_t * em, vlib_main_t * vm)
-{
-  int no_of_threads = vec_len (vlib_worker_threads);
-  int i;
-  ioam_export_buffer_t *eb = 0;
-
-  pool_alloc_aligned (em->buffer_pool,
-		      no_of_threads - 1, CLIB_CACHE_LINE_BYTES);
-  vec_validate_aligned (em->buffer_per_thread,
-			no_of_threads - 1, CLIB_CACHE_LINE_BYTES);
-  vec_validate_aligned (em->lockp, no_of_threads - 1, CLIB_CACHE_LINE_BYTES);
-
-  if (!em->buffer_per_thread || !em->buffer_pool || !em->lockp)
-    {
-      return (-1);
-    }
-  for (i = 0; i < no_of_threads; i++)
-    {
-      eb = 0;
-      pool_get_aligned (em->buffer_pool, eb, CLIB_CACHE_LINE_BYTES);
-      clib_memset (eb, 0, sizeof (*eb));
-      em->buffer_per_thread[i] = eb - em->buffer_pool;
-      if (ioam_export_init_buffer (em, vm, eb) != 1)
-	{
-	  ioam_export_thread_buffer_free (em);
-	  return (-2);
-	}
-      clib_spinlock_init (&em->lockp[i]);
-    }
-  return (1);
-}
-
-#define IPFIX_IOAM_EXPORT_ID 272
-#define IPFIX_VXLAN_IOAM_EXPORT_ID 273
-
-/* Used to build the rewrite */
-/* data set packet */
-typedef struct
-{
-  ipfix_message_header_t h;
-  ipfix_set_header_t s;
-} ipfix_data_packet_t;
-
-typedef struct
-{
-  ip4_header_t ip4;
-  udp_header_t udp;
-  ipfix_data_packet_t ipfix;
-} ip4_ipfix_data_packet_t;
-
-
-inline static void
-ioam_export_header_cleanup (ioam_export_main_t * em,
-			    ip4_address_t * collector_address,
-			    ip4_address_t * src_address)
-{
-  vec_free (em->record_header);
-  em->record_header = 0;
-}
-
-inline static int
-ioam_export_header_create (ioam_export_main_t * em,
-			   ip4_address_t * collector_address,
-			   ip4_address_t * src_address)
-{
-  ip4_header_t *ip;
-  udp_header_t *udp;
-  ipfix_message_header_t *h;
-  ipfix_set_header_t *s;
-  u8 *rewrite = 0;
-  ip4_ipfix_data_packet_t *tp;
-
-
-  /* allocate rewrite space */
-  vec_validate_aligned (rewrite,
-			sizeof (ip4_ipfix_data_packet_t) - 1,
-			CLIB_CACHE_LINE_BYTES);
-
-  tp = (ip4_ipfix_data_packet_t *) rewrite;
-  ip = (ip4_header_t *) & tp->ip4;
-  udp = (udp_header_t *) (ip + 1);
-  h = (ipfix_message_header_t *) (udp + 1);
-  s = (ipfix_set_header_t *) (h + 1);
-
-  ip->ip_version_and_header_length = 0x45;
-  ip->ttl = 254;
-  ip->protocol = IP_PROTOCOL_UDP;
-  ip->src_address.as_u32 = src_address->as_u32;
-  ip->dst_address.as_u32 = collector_address->as_u32;
-  udp->src_port = clib_host_to_net_u16 (UDP_DST_PORT_ipfix);
-  udp->dst_port = clib_host_to_net_u16 (UDP_DST_PORT_ipfix);
-  /* FIXUP: UDP length */
-  udp->length = clib_host_to_net_u16 (vec_len (rewrite) +
-				      (DEFAULT_EXPORT_RECORDS *
-				       DEFAULT_EXPORT_SIZE) - sizeof (*ip));
-
-  /* FIXUP: message header export_time */
-  /* FIXUP: message header sequence_number */
-  h->domain_id = clib_host_to_net_u32 (em->domain_id);
-
-  /*FIXUP: Setid length in octets if records exported are not default */
-  s->set_id_length = ipfix_set_id_length (em->set_id,
-					  (sizeof (*s) +
-					   (DEFAULT_EXPORT_RECORDS *
-					    DEFAULT_EXPORT_SIZE)));
-
-  /* FIXUP: h version and length length in octets if records exported are not default */
-  h->version_length = version_length (sizeof (*h) +
-				      (sizeof (*s) +
-				       (DEFAULT_EXPORT_RECORDS *
-					DEFAULT_EXPORT_SIZE)));
-
-  /* FIXUP: ip length if records exported are not default */
-  /* FIXUP: ip checksum if records exported are not default */
-  ip->length = clib_host_to_net_u16 (vec_len (rewrite) +
-				     (DEFAULT_EXPORT_RECORDS *
-				      DEFAULT_EXPORT_SIZE));
-  ip->checksum = ip4_header_checksum (ip);
-  vec_set_len (rewrite, sizeof (ip4_ipfix_data_packet_t));
-  em->record_header = rewrite;
-  return (1);
-}
-
-inline static int
-ioam_export_send_buffer (ioam_export_main_t * em, vlib_main_t * vm,
-			 ioam_export_buffer_t * eb)
-{
-  ip4_header_t *ip;
-  udp_header_t *udp;
-  ipfix_message_header_t *h;
-  ipfix_set_header_t *s;
-  ip4_ipfix_data_packet_t *tp;
-  vlib_buffer_t *b0;
-  u16 new_l0, old_l0;
-  ip_csum_t sum0;
-  vlib_frame_t *nf = 0;
-  u32 *to_next;
-
-  b0 = vlib_get_buffer (vm, eb->buffer_index);
-  tp = vlib_buffer_get_current (b0);
-  ip = (ip4_header_t *) & tp->ip4;
-  udp = (udp_header_t *) (ip + 1);
-  h = (ipfix_message_header_t *) (udp + 1);
-  s = (ipfix_set_header_t *) (h + 1);
-
-  /* FIXUP: message header export_time */
-  h->export_time = clib_host_to_net_u32 ((u32)
-					 (((f64) em->unix_time_0) +
-					  (vlib_time_now (em->vlib_main) -
-					   em->vlib_time_0)));
-
-  /* FIXUP: message header sequence_number */
-  h->sequence_number = clib_host_to_net_u32 (em->sequence_number++);
-
-  /* FIXUP: lengths if different from default */
-  if (PREDICT_FALSE (eb->records_in_this_buffer != DEFAULT_EXPORT_RECORDS))
-    {
-      s->set_id_length = ipfix_set_id_length (em->set_id /* set_id */ ,
-					      b0->current_length -
-					      (sizeof (*ip) + sizeof (*udp) +
-					       sizeof (*h)));
-      h->version_length =
-	version_length (b0->current_length - (sizeof (*ip) + sizeof (*udp)));
-      sum0 = ip->checksum;
-      old_l0 = ip->length;
-      new_l0 = clib_host_to_net_u16 ((u16) b0->current_length);
-      sum0 = ip_csum_update (sum0, old_l0, new_l0, ip4_header_t,
-			     length /* changed member */ );
-      ip->checksum = ip_csum_fold (sum0);
-      ip->length = new_l0;
-      udp->length = clib_host_to_net_u16 (b0->current_length - sizeof (*ip));
-    }
-
-  /* Enqueue pkts to ip4-lookup */
-
-  nf = vlib_get_frame_to_node (vm, em->next_node_index);
-  nf->n_vectors = 0;
-  to_next = vlib_frame_vector_args (nf);
-  nf->n_vectors = 1;
-  to_next[0] = eb->buffer_index;
-  vlib_put_frame_to_node (vm, em->next_node_index, nf);
-  return (1);
-
-}
-
-#define EXPORT_TIMEOUT (20.0)
-#define THREAD_PERIOD (30.0)
-inline static uword
-ioam_export_process_common (ioam_export_main_t * em, vlib_main_t * vm,
-			    vlib_node_runtime_t * rt, vlib_frame_t * f,
-			    u32 index)
-{
-  f64 now;
-  f64 timeout = 30.0;
-  uword event_type;
-  uword *event_data = 0;
-  int i;
-  ioam_export_buffer_t *eb = 0, *new_eb = 0;
-  u32 *vec_buffer_indices = 0;
-  u32 *vec_buffer_to_be_sent = 0;
-  u32 *thread_index = 0;
-  u32 new_pool_index = 0;
-
-  em->export_process_node_index = index;
-  /* Wait for Godot... */
-  vlib_process_wait_for_event_or_clock (vm, 1e9);
-  event_type = vlib_process_get_events (vm, &event_data);
-  if (event_type != 1)
-    clib_warning ("bogus kickoff event received, %d", event_type);
-  vec_reset_length (event_data);
-
-  while (1)
-    {
-      vlib_process_wait_for_event_or_clock (vm, timeout);
-      event_type = vlib_process_get_events (vm, &event_data);
-      switch (event_type)
-	{
-	case 2:		/* Stop and Wait for kickoff again */
-	  timeout = 1e9;
-	  break;
-	case 1:		/* kickoff : Check for unsent buffers */
-	  timeout = THREAD_PERIOD;
-	  break;
-	case ~0:		/* timeout */
-	  break;
-	}
-      vec_reset_length (event_data);
-      now = vlib_time_now (vm);
-      /*
-       * Create buffers for threads that are not active enough
-       * to send out the export records
-       */
-      for (i = 0; i < vec_len (em->buffer_per_thread); i++)
-	{
-	  /* If the worker thread is processing export records ignore further checks */
-	  if (CLIB_SPINLOCK_IS_LOCKED (&em->lockp[i]))
-	    continue;
-	  eb = pool_elt_at_index (em->buffer_pool, em->buffer_per_thread[i]);
-	  if (eb->records_in_this_buffer > 0
-	      && now > (eb->touched_at + EXPORT_TIMEOUT))
-	    {
-	      pool_get_aligned (em->buffer_pool, new_eb,
-				CLIB_CACHE_LINE_BYTES);
-	      clib_memset (new_eb, 0, sizeof (*new_eb));
-	      if (ioam_export_init_buffer (em, vm, new_eb) == 1)
-		{
-		  new_pool_index = new_eb - em->buffer_pool;
-		  vec_add (vec_buffer_indices, &new_pool_index, 1);
-		  vec_add (vec_buffer_to_be_sent, &em->buffer_per_thread[i],
-			   1);
-		  vec_add (thread_index, &i, 1);
-		}
-	      else
-		{
-		  pool_put (em->buffer_pool, new_eb);
-		  /*Give up */
-		  goto CLEANUP;
-		}
-	    }
-	}
-      if (vec_len (thread_index) != 0)
-	{
-	  /*
-	   * Now swap the buffers out
-	   */
-	  for (i = 0; i < vec_len (thread_index); i++)
-	    {
-	      clib_spinlock_lock (&em->lockp[thread_index[i]]);
-	      em->buffer_per_thread[thread_index[i]] =
-		vec_pop (vec_buffer_indices);
-	      clib_spinlock_unlock (&em->lockp[thread_index[i]]);
-	    }
-
-	  /* Send the buffers */
-	  for (i = 0; i < vec_len (vec_buffer_to_be_sent); i++)
-	    {
-	      eb =
-		pool_elt_at_index (em->buffer_pool, vec_buffer_to_be_sent[i]);
-	      ioam_export_send_buffer (em, vm, eb);
-	      pool_put (em->buffer_pool, eb);
-	    }
-	}
-
-    CLEANUP:
-      /* Free any leftover/unused buffers and everything that was allocated */
-      for (i = 0; i < vec_len (vec_buffer_indices); i++)
-	{
-	  new_eb = pool_elt_at_index (em->buffer_pool, vec_buffer_indices[i]);
-	  vlib_buffer_free (vm, &new_eb->buffer_index, 1);
-	  pool_put (em->buffer_pool, new_eb);
-	}
-      vec_free (vec_buffer_indices);
-      vec_free (vec_buffer_to_be_sent);
-      vec_free (thread_index);
-    }
-  return 0;			/* not so much */
-}
-
-#define ioam_export_node_common(EM, VM, N, F, HTYPE, L, V, NEXT, FIXUP_FUNC)   \
-do {                                                                           \
-  u32 n_left_from, *from, *to_next;                                            \
-  export_next_t next_index;                                                    \
-  u32 pkts_recorded = 0;                                                       \
-  ioam_export_buffer_t *my_buf = 0;                                            \
-  vlib_buffer_t *eb0 = 0;                                                      \
-  u32 ebi0 = 0;                                                                \
-  from = vlib_frame_vector_args (F);                                           \
-  n_left_from = (F)->n_vectors;                                                \
-  next_index = (N)->cached_next_index;                                         \
-  clib_spinlock_lock (&(EM)->lockp[(VM)->thread_index]);	               \
-  my_buf = ioam_export_get_my_buffer (EM, (VM)->thread_index);                 \
-  my_buf->touched_at = vlib_time_now (VM);                                     \
-  while (n_left_from > 0)                                                      \
-    {                                                                          \
-      u32 n_left_to_next;                                                      \
-      vlib_get_next_frame (VM, N, next_index, to_next, n_left_to_next);        \
-      while (n_left_from >= 4 && n_left_to_next >= 2)                          \
-	{                                                                      \
-	  u32 next0 = NEXT;                                                    \
-	  u32 next1 = NEXT;                                                    \
-	  u32 bi0, bi1;                                                        \
-	  HTYPE *ip0, *ip1;                                                    \
-	  vlib_buffer_t *p0, *p1;                                              \
-	  u32 ip_len0, ip_len1;                                                \
-	  {                                                                    \
-	    vlib_buffer_t *p2, *p3;                                            \
-	    p2 = vlib_get_buffer (VM, from[2]);                                \
-	    p3 = vlib_get_buffer (VM, from[3]);                                \
-	    vlib_prefetch_buffer_header (p2, LOAD);                            \
-	    vlib_prefetch_buffer_header (p3, LOAD);                            \
-	    CLIB_PREFETCH (p2->data, 3 * CLIB_CACHE_LINE_BYTES, LOAD);         \
-	    CLIB_PREFETCH (p3->data, 3 * CLIB_CACHE_LINE_BYTES, LOAD);         \
-	  }                                                                    \
-	  to_next[0] = bi0 = from[0];                                          \
-	  to_next[1] = bi1 = from[1];                                          \
-	  from += 2;                                                           \
-	  to_next += 2;                                                        \
-	  n_left_from -= 2;                                                    \
-	  n_left_to_next -= 2;                                                 \
-	  p0 = vlib_get_buffer (VM, bi0);                                      \
-	  p1 = vlib_get_buffer (VM, bi1);                                      \
-	  ip0 = vlib_buffer_get_current (p0);                                  \
-	  ip1 = vlib_buffer_get_current (p1);                                  \
-	  ip_len0 =                                                            \
-	    clib_net_to_host_u16 (ip0->L) + sizeof (HTYPE);                    \
-	  ip_len1 =                                                            \
-	    clib_net_to_host_u16 (ip1->L) + sizeof (HTYPE);                    \
-	  ebi0 = my_buf->buffer_index;                                         \
-	  eb0 = vlib_get_buffer (VM, ebi0);                                    \
-	  if (PREDICT_FALSE (eb0 == 0))                                        \
-	    goto NO_BUFFER1;                                                   \
-	  ip_len0 =                                                            \
-	    ip_len0 > DEFAULT_EXPORT_SIZE ? DEFAULT_EXPORT_SIZE : ip_len0;     \
-	  ip_len1 =                                                            \
-	    ip_len1 > DEFAULT_EXPORT_SIZE ? DEFAULT_EXPORT_SIZE : ip_len1;     \
-	  copy3cachelines (eb0->data + eb0->current_length, ip0, ip_len0);     \
-	  FIXUP_FUNC(eb0, p0);                                                 \
-	  eb0->current_length += DEFAULT_EXPORT_SIZE;                          \
-	  my_buf->records_in_this_buffer++;                                    \
-	  if (my_buf->records_in_this_buffer >= DEFAULT_EXPORT_RECORDS)        \
-	    {                                                                  \
-	      ioam_export_send_buffer (EM, VM, my_buf);                        \
-	      ioam_export_init_buffer (EM, VM, my_buf);                        \
-	    }                                                                  \
-	  ebi0 = my_buf->buffer_index;                                         \
-	  eb0 = vlib_get_buffer (VM, ebi0);                                    \
-	  if (PREDICT_FALSE (eb0 == 0))                                        \
-	    goto NO_BUFFER1;                                                   \
-	  copy3cachelines (eb0->data + eb0->current_length, ip1, ip_len1);     \
-	  FIXUP_FUNC(eb0, p1);                                                 \
-	  eb0->current_length += DEFAULT_EXPORT_SIZE;                          \
-	  my_buf->records_in_this_buffer++;                                    \
-	  if (my_buf->records_in_this_buffer >= DEFAULT_EXPORT_RECORDS)        \
-	    {                                                                  \
-	      ioam_export_send_buffer (EM, VM, my_buf);                        \
-	      ioam_export_init_buffer (EM, VM, my_buf);                        \
-	    }                                                                  \
-	  pkts_recorded += 2;                                                  \
-	  if (PREDICT_FALSE (((node)->flags & VLIB_NODE_FLAG_TRACE)))          \
-	    {                                                                  \
-	      if (p0->flags & VLIB_BUFFER_IS_TRACED)                           \
-		{                                                              \
-		  export_trace_t *t =                                          \
-		    vlib_add_trace (VM, node, p0, sizeof (*t));                \
-		  t->flow_label =                                              \
-		    clib_net_to_host_u32 (ip0->V);                             \
-		  t->next_index = next0;                                       \
-		}                                                              \
-	      if (p1->flags & VLIB_BUFFER_IS_TRACED)                           \
-		{                                                              \
-		  export_trace_t *t =                                          \
-		    vlib_add_trace (VM, N, p1, sizeof (*t));                   \
-		  t->flow_label =                                              \
-		    clib_net_to_host_u32 (ip1->V);                             \
-		  t->next_index = next1;                                       \
-		}                                                              \
-	    }                                                                  \
-	NO_BUFFER1:                                                            \
-	  vlib_validate_buffer_enqueue_x2 (VM, N, next_index,                  \
-					   to_next, n_left_to_next,            \
-					   bi0, bi1, next0, next1);            \
-	}                                                                      \
-      while (n_left_from > 0 && n_left_to_next > 0)                            \
-	{                                                                      \
-	  u32 bi0;                                                             \
-	  vlib_buffer_t *p0;                                                   \
-	  u32 next0 = NEXT;                                                    \
-	  HTYPE *ip0;                                                          \
-	  u32 ip_len0;                                                         \
-	  bi0 = from[0];                                                       \
-	  to_next[0] = bi0;                                                    \
-	  from += 1;                                                           \
-	  to_next += 1;                                                        \
-	  n_left_from -= 1;                                                    \
-	  n_left_to_next -= 1;                                                 \
-	  p0 = vlib_get_buffer (VM, bi0);                                      \
-	  ip0 = vlib_buffer_get_current (p0);                                  \
-	  ip_len0 =                                                            \
-	    clib_net_to_host_u16 (ip0->L) + sizeof (HTYPE);                    \
-	  ebi0 = my_buf->buffer_index;                                         \
-	  eb0 = vlib_get_buffer (VM, ebi0);                                    \
-	  if (PREDICT_FALSE (eb0 == 0))                                        \
-	    goto NO_BUFFER;                                                    \
-	  ip_len0 =                                                            \
-	    ip_len0 > DEFAULT_EXPORT_SIZE ? DEFAULT_EXPORT_SIZE : ip_len0;     \
-	  copy3cachelines (eb0->data + eb0->current_length, ip0, ip_len0);     \
-	  FIXUP_FUNC(eb0, p0);                                                 \
-	  eb0->current_length += DEFAULT_EXPORT_SIZE;                          \
-	  my_buf->records_in_this_buffer++;                                    \
-	  if (my_buf->records_in_this_buffer >= DEFAULT_EXPORT_RECORDS)        \
-	    {                                                                  \
-	      ioam_export_send_buffer (EM, VM, my_buf);                        \
-	      ioam_export_init_buffer (EM, VM, my_buf);                        \
-	    }                                                                  \
-	  if (PREDICT_FALSE (((N)->flags & VLIB_NODE_FLAG_TRACE)               \
-			     && (p0->flags & VLIB_BUFFER_IS_TRACED)))          \
-	    {                                                                  \
-	      export_trace_t *t = vlib_add_trace (VM, (N), p0, sizeof (*t));   \
-	      t->flow_label =                                                  \
-		clib_net_to_host_u32 (ip0->V);                                 \
-	      t->next_index = next0;                                           \
-	    }                                                                  \
-	  pkts_recorded += 1;                                                  \
-	NO_BUFFER:                                                             \
-	  vlib_validate_buffer_enqueue_x1 (VM, N, next_index,                  \
-					   to_next, n_left_to_next,            \
-					   bi0, next0);                        \
-	}                                                                      \
-      vlib_put_next_frame (VM, N, next_index, n_left_to_next);                 \
-    }                                                                          \
-  vlib_node_increment_counter (VM, export_node.index,                          \
-			       EXPORT_ERROR_RECORDED, pkts_recorded);          \
-  clib_spinlock_unlock (&(EM)->lockp[(VM)->thread_index]);                     \
-} while(0)
-
-#endif /* __included_ioam_export_h__ */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.api b/ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.api
deleted file mode 100644
index 64a36b8..0000000
--- a/ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.api
+++ /dev/null
@@ -1,37 +0,0 @@
-/* Hey Emacs use -*- mode: C -*- */
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-option version = "1.0.0";
-import "vnet/ip/ip_types.api";
-
-/* Define a simple binary API to control the feature */
-
-autoreply define vxlan_gpe_ioam_export_enable_disable {
-    /* Client identifier, set from api_main.my_client_index */
-    u32 client_index;
-
-    /* Arbitrary context, so client can match reply to request */
-    u32 context;
-
-    /* Enable / disable the feature */
-    bool is_disable;
-
-    /* Collector ip address */
-    vl_api_ip4_address_t collector_address;
-    vl_api_ip4_address_t src_address;
-
-    /* Src ip address */
-};
diff --git a/ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.c b/ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.c
deleted file mode 100644
index f802a04..0000000
--- a/ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.c
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- *------------------------------------------------------------------
- * vxlan_gpe_ioam_export.c - ioam export API / debug CLI handling
- *------------------------------------------------------------------
- */
-
-#include <vnet/vnet.h>
-#include <vnet/plugin/plugin.h>
-#include <ioam/export-common/ioam_export.h>
-#include <vnet/vxlan-gpe/vxlan_gpe.h>
-
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-#include <vnet/format_fns.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam.h>
-
-/* define message IDs */
-#include <ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.api_enum.h>
-#include <ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.api_types.h>
-
-#define REPLY_MSG_ID_BASE sm->msg_id_base
-#include <vlibapi/api_helper_macros.h>
-
-ioam_export_main_t vxlan_gpe_ioam_export_main;
-extern vlib_node_registration_t vxlan_export_node;
-
-extern void vxlan_gpe_set_next_override (uword next);
-/* Action function shared between message handler and debug CLI */
-int
-vxlan_gpe_ioam_export_enable_disable (ioam_export_main_t * em,
-				      u8 is_disable,
-				      ip4_address_t * collector_address,
-				      ip4_address_t * src_address)
-{
-  vlib_main_t *vm = em->vlib_main;
-  u32 node_index = vxlan_export_node.index;
-  vlib_node_t *vxlan_gpe_decap_ioam_node = NULL;
-
-  if (is_disable == 0)
-    {
-      if (em->my_hbh_slot == ~0)
-	{
-	  /* Hook this export node to vxlan-gpe-decap-ioam-v4 */
-	  vxlan_gpe_decap_ioam_node =
-	    vlib_get_node_by_name (vm, (u8 *) "vxlan-gpe-decap-ioam-v4");
-	  if (!vxlan_gpe_decap_ioam_node)
-	    {
-	      /* node does not exist give up */
-	      return (-1);
-	    }
-	  em->my_hbh_slot =
-	    vlib_node_add_next (vm, vxlan_gpe_decap_ioam_node->index,
-				node_index);
-	}
-      if (1 == ioam_export_header_create (em, collector_address, src_address))
-	{
-	  ioam_export_thread_buffer_init (em, vm);
-	  vxlan_gpe_set_next_override (em->my_hbh_slot);
-	  /* Turn on the export buffer check process */
-	  vlib_process_signal_event (vm, em->export_process_node_index, 1, 0);
-
-	}
-      else
-	{
-	  return (-2);
-	}
-    }
-  else
-    {
-      vxlan_gpe_set_next_override (VXLAN_GPE_DECAP_IOAM_V4_NEXT_POP);
-      ioam_export_header_cleanup (em, collector_address, src_address);
-      ioam_export_thread_buffer_free (em);
-      /* Turn off the export buffer check process */
-      vlib_process_signal_event (vm, em->export_process_node_index, 2, 0);
-
-    }
-
-  return 0;
-}
-
-/* API message handler */
-static void vl_api_vxlan_gpe_ioam_export_enable_disable_t_handler
-  (vl_api_vxlan_gpe_ioam_export_enable_disable_t * mp)
-{
-  vl_api_vxlan_gpe_ioam_export_enable_disable_reply_t *rmp;
-  ioam_export_main_t *sm = &vxlan_gpe_ioam_export_main;
-  int rv;
-
-  rv = vxlan_gpe_ioam_export_enable_disable (sm, (int) (mp->is_disable),
-					     (ip4_address_t *)
-					     mp->collector_address,
-					     (ip4_address_t *)
-					     mp->src_address);
-
-  REPLY_MACRO (VL_API_VXLAN_GPE_IOAM_EXPORT_ENABLE_DISABLE_REPLY);
-}				/* API message handler */
-
-static clib_error_t *
-set_vxlan_gpe_ioam_export_ipfix_command_fn (vlib_main_t * vm,
-					    unformat_input_t * input,
-					    vlib_cli_command_t * cmd)
-{
-  ioam_export_main_t *em = &vxlan_gpe_ioam_export_main;
-  ip4_address_t collector, src;
-  u8 is_disable = 0;
-
-  collector.as_u32 = 0;
-  src.as_u32 = 0;
-
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "collector %U", unformat_ip4_address, &collector))
-	;
-      else if (unformat (input, "src %U", unformat_ip4_address, &src))
-	;
-      else if (unformat (input, "disable"))
-	is_disable = 1;
-      else
-	break;
-    }
-
-  if (collector.as_u32 == 0)
-    return clib_error_return (0, "collector address required");
-
-  if (src.as_u32 == 0)
-    return clib_error_return (0, "src address required");
-
-  em->ipfix_collector.as_u32 = collector.as_u32;
-  em->src_address.as_u32 = src.as_u32;
-
-  vlib_cli_output (vm, "Collector %U, src address %U",
-		   format_ip4_address, &em->ipfix_collector,
-		   format_ip4_address, &em->src_address);
-
-  /* Turn on the export timer process */
-  // vlib_process_signal_event (vm, flow_report_process_node.index,
-  //1, 0);
-  if (0 !=
-      vxlan_gpe_ioam_export_enable_disable (em, is_disable, &collector, &src))
-    {
-      return clib_error_return (0, "Unable to set ioam vxlan-gpe export");
-    }
-
-  return 0;
-}
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (set_vxlan_gpe_ioam_ipfix_command, static) =
-{
-.path = "set vxlan-gpe-ioam export ipfix",
-.short_help = "set vxlan-gpe-ioam export ipfix collector <ip4-address> src <ip4-address>",
-.function = set_vxlan_gpe_ioam_export_ipfix_command_fn,
-};
-/* *INDENT-ON* */
-
-#include <ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.api.c>
-static clib_error_t *
-vxlan_gpe_ioam_export_init (vlib_main_t * vm)
-{
-  ioam_export_main_t *em = &vxlan_gpe_ioam_export_main;
-
-  em->set_id = IPFIX_VXLAN_IOAM_EXPORT_ID;
-
-  /* Ask for a correctly-sized block of API message decode slots */
-  em->msg_id_base = setup_message_id_table ();
-  em->unix_time_0 = (u32) time (0);	/* Store starting time */
-  em->vlib_time_0 = vlib_time_now (vm);
-
-  em->my_hbh_slot = ~0;
-  em->vlib_main = vm;
-  em->vnet_main = vnet_get_main ();
-  ioam_export_reset_next_node (em);
-
-  return 0;
-}
-
-VLIB_INIT_FUNCTION (vxlan_gpe_ioam_export_init);
-
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/export-vxlan-gpe/vxlan_gpe_ioam_export_test.c b/ioam/export-vxlan-gpe/vxlan_gpe_ioam_export_test.c
deleted file mode 100644
index 1fc48f7..0000000
--- a/ioam/export-vxlan-gpe/vxlan_gpe_ioam_export_test.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- *------------------------------------------------------------------
- * vxlan_gpe_ioam_export_test.c - test harness plugin
- *------------------------------------------------------------------
- */
-
-#include <vat/vat.h>
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-#include <vppinfra/error.h>
-#include <vnet/format_fns.h>
-
-#define __plugin_msg_base vxlan_gpe_ioam_export_test_main.msg_id_base
-#include <vlibapi/vat_helper_macros.h>
-
-/* Declare message IDs */
-#include <ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.api_enum.h>
-#include <ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.api_types.h>
-
-typedef struct
-{
-  /* API message ID base */
-  u16 msg_id_base;
-  vat_main_t *vat_main;
-} vxlan_gpe_ioam_export_test_main_t;
-
-vxlan_gpe_ioam_export_test_main_t vxlan_gpe_ioam_export_test_main;
-
-static int
-api_vxlan_gpe_ioam_export_enable_disable (vat_main_t * vam)
-{
-  unformat_input_t *i = vam->input;
-  int is_disable = 0;
-  vl_api_vxlan_gpe_ioam_export_enable_disable_t *mp;
-  int ret;
-
-  /* Parse args required to build the message */
-  while (unformat_check_input (i) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (i, "disable"))
-	is_disable = 1;
-      else
-	break;
-    }
-
-  /* Construct the API message */
-  M (VXLAN_GPE_IOAM_EXPORT_ENABLE_DISABLE, mp);
-  mp->is_disable = is_disable;
-
-  /* send it... */
-  S (mp);
-
-  /* Wait for a reply... */
-  W (ret);
-  return ret;
-}
-
-/* Override generated plugin register symbol */
-#define vat_plugin_register vxlan_gpe_ioam_export_vat_plugin_register
-#include <ioam/export-vxlan-gpe/vxlan_gpe_ioam_export.api_test.c>
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/export-vxlan-gpe/vxlan_gpe_ioam_export_thread.c b/ioam/export-vxlan-gpe/vxlan_gpe_ioam_export_thread.c
deleted file mode 100644
index 7d66bd4..0000000
--- a/ioam/export-vxlan-gpe/vxlan_gpe_ioam_export_thread.c
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- * ioam_export_thread.c
- */
-#include <vnet/api_errno.h>
-#include <vppinfra/pool.h>
-#include <vnet/ethernet/ethernet.h>
-#include <ioam/export-common/ioam_export.h>
-
-static vlib_node_registration_t vxlan_gpe_ioam_export_process_node;
-extern ioam_export_main_t vxlan_gpe_ioam_export_main;
-
-static uword
-vxlan_gpe_ioam_export_process (vlib_main_t * vm,
-			       vlib_node_runtime_t * rt, vlib_frame_t * f)
-{
-  return (ioam_export_process_common (&vxlan_gpe_ioam_export_main,
-				      vm, rt, f,
-				      vxlan_gpe_ioam_export_process_node.index));
-}
-
-
-/* *INDENT-OFF* */
-VLIB_REGISTER_NODE (vxlan_gpe_ioam_export_process_node, static) =
-{
- .function = vxlan_gpe_ioam_export_process,
- .type = VLIB_NODE_TYPE_PROCESS,
- .name = "vxlan-gpe-ioam-export-process",
-};
-/* *INDENT-ON* */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/export-vxlan-gpe/vxlan_gpe_node.c b/ioam/export-vxlan-gpe/vxlan_gpe_node.c
deleted file mode 100644
index f8d9033..0000000
--- a/ioam/export-vxlan-gpe/vxlan_gpe_node.c
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <vlib/vlib.h>
-#include <vnet/vnet.h>
-#include <vppinfra/error.h>
-#include <vnet/ip/ip.h>
-#include <vnet/vxlan-gpe/vxlan_gpe.h>
-#include <vnet/vxlan-gpe/vxlan_gpe_packet.h>
-#include <ioam/export-common/ioam_export.h>
-
-typedef struct
-{
-  u32 next_index;
-  u32 flow_label;
-} export_trace_t;
-
-/* packet trace format function */
-static u8 *
-format_export_trace (u8 * s, va_list * args)
-{
-  CLIB_UNUSED (vlib_main_t * vm) = va_arg (*args, vlib_main_t *);
-  CLIB_UNUSED (vlib_node_t * node) = va_arg (*args, vlib_node_t *);
-  export_trace_t *t = va_arg (*args, export_trace_t *);
-
-  s = format (s, "EXPORT: flow_label %d, next index %d",
-	      t->flow_label, t->next_index);
-  return s;
-}
-
-vlib_node_registration_t vxlan_export_node;
-extern vlib_node_registration_t export_node;
-extern ioam_export_main_t vxlan_gpe_ioam_export_main;
-
-#define foreach_export_error \
-_(RECORDED, "Packets recorded for export")
-
-typedef enum
-{
-#define _(sym,str) EXPORT_ERROR_##sym,
-  foreach_export_error
-#undef _
-    EXPORT_N_ERROR,
-} export_error_t;
-
-static char *export_error_strings[] = {
-#define _(sym,string) string,
-  foreach_export_error
-#undef _
-};
-
-typedef enum
-{
-  EXPORT_NEXT_VXLAN_GPE_INPUT,
-  EXPORT_N_NEXT,
-} export_next_t;
-
-always_inline void
-copy3cachelines (void *dst, const void *src, size_t n)
-{
-#if 0
-  if (PREDICT_FALSE (n < DEFAULT_EXPORT_SIZE))
-    {
-      /* Copy only the first 1/2 cache lines whatever is available */
-      if (n >= 64)
-	clib_mov64 ((u8 *) dst, (const u8 *) src);
-      if (n >= 128)
-	clib_mov64 ((u8 *) dst + 64, (const u8 *) src + 64);
-      return;
-    }
-  clib_mov64 ((u8 *) dst, (const u8 *) src);
-  clib_mov64 ((u8 *) dst + 64, (const u8 *) src + 64);
-  clib_mov64 ((u8 *) dst + 128, (const u8 *) src + 128);
-#endif
-#if 1
-
-  u64 *copy_dst, *copy_src;
-  int i;
-  copy_dst = (u64 *) dst;
-  copy_src = (u64 *) src;
-  if (PREDICT_FALSE (n < DEFAULT_EXPORT_SIZE))
-    {
-      for (i = 0; i < n / 64; i++)
-	{
-	  copy_dst[0] = copy_src[0];
-	  copy_dst[1] = copy_src[1];
-	  copy_dst[2] = copy_src[2];
-	  copy_dst[3] = copy_src[3];
-	  copy_dst[4] = copy_src[4];
-	  copy_dst[5] = copy_src[5];
-	  copy_dst[6] = copy_src[6];
-	  copy_dst[7] = copy_src[7];
-	  copy_dst += 8;
-	  copy_src += 8;
-	}
-      return;
-    }
-  for (i = 0; i < 3; i++)
-    {
-      copy_dst[0] = copy_src[0];
-      copy_dst[1] = copy_src[1];
-      copy_dst[2] = copy_src[2];
-      copy_dst[3] = copy_src[3];
-      copy_dst[4] = copy_src[4];
-      copy_dst[5] = copy_src[5];
-      copy_dst[6] = copy_src[6];
-      copy_dst[7] = copy_src[7];
-      copy_dst += 8;
-      copy_src += 8;
-    }
-#endif
-}
-
-static void
-vxlan_gpe_export_fixup_func (vlib_buffer_t * export_buf,
-			     vlib_buffer_t * pak_buf)
-{
-  /* Todo: on implementing VXLAN GPE analyse */
-}
-
-static uword
-vxlan_gpe_export_node_fn (vlib_main_t * vm,
-			  vlib_node_runtime_t * node, vlib_frame_t * frame)
-{
-  ioam_export_main_t *em = &vxlan_gpe_ioam_export_main;
-  ioam_export_node_common (em, vm, node, frame, ip4_header_t, length,
-			   ip_version_and_header_length,
-			   EXPORT_NEXT_VXLAN_GPE_INPUT,
-			   vxlan_gpe_export_fixup_func);
-  return frame->n_vectors;
-}
-
-/*
- * Node for VXLAN-GPE export
- */
-/* *INDENT-OFF* */
-VLIB_REGISTER_NODE (vxlan_export_node) =
-{
-  .function = vxlan_gpe_export_node_fn,
-  .name = "vxlan-gpe-ioam-export",
-  .vector_size = sizeof (u32),
-  .format_trace = format_export_trace,
-  .type = VLIB_NODE_TYPE_INTERNAL,
-  .n_errors = ARRAY_LEN (export_error_strings),
-  .error_strings = export_error_strings,
-  .n_next_nodes = EXPORT_N_NEXT,
-    /* edit / add dispositions here */
-    .next_nodes =
-  {[EXPORT_NEXT_VXLAN_GPE_INPUT] = "vxlan-gpe-pop-ioam-v4"},
-};
-/* *INDENT-ON* */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/export/ioam_export.api b/ioam/export/ioam_export.api
deleted file mode 100644
index 2e77ded..0000000
--- a/ioam/export/ioam_export.api
+++ /dev/null
@@ -1,37 +0,0 @@
-/* Hey Emacs use -*- mode: C -*- */
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-option version = "1.0.0";
-import "vnet/ip/ip_types.api";
-
-/* Define a simple binary API to control the feature */
-
-autoreply define ioam_export_ip6_enable_disable {
-    /* Client identifier, set from api_main.my_client_index */
-    u32 client_index;
-
-    /* Arbitrary context, so client can match reply to request */
-    u32 context;
-
-    /* Enable / disable the feature */
-    bool is_disable;
-
-    /* Collector ip address */
-    vl_api_ip4_address_t collector_address;
-    vl_api_ip4_address_t src_address;
-
-    /* Src ip address */
-};
diff --git a/ioam/export/ioam_export.c b/ioam/export/ioam_export.c
deleted file mode 100644
index 21695af..0000000
--- a/ioam/export/ioam_export.c
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- *------------------------------------------------------------------
- * ioam_export.c - ioam export API / debug CLI handling
- *------------------------------------------------------------------
- */
-
-#include <vnet/vnet.h>
-#include <vnet/plugin/plugin.h>
-#include <ioam/export-common/ioam_export.h>
-
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-#include <vnet/ip/ip6_hop_by_hop.h>
-#include <vnet/format_fns.h>
-
-/* define message IDs */
-#include <ioam/export/ioam_export.api_enum.h>
-#include <ioam/export/ioam_export.api_types.h>
-
-#define REPLY_MSG_ID_BASE sm->msg_id_base
-#include <vlibapi/api_helper_macros.h>
-
-ioam_export_main_t ioam_export_main;
-
-extern vlib_node_registration_t export_node;
-
-/* Action function shared between message handler and debug CLI */
-
-int
-ioam_export_ip6_enable_disable (ioam_export_main_t * em,
-				u8 is_disable,
-				ip4_address_t * collector_address,
-				ip4_address_t * src_address)
-{
-  vlib_main_t *vm = em->vlib_main;
-
-  if (is_disable == 0)
-    {
-      if (1 == ioam_export_header_create (em, collector_address, src_address))
-	{
-	  ioam_export_thread_buffer_init (em, vm);
-	  ip6_hbh_set_next_override (em->my_hbh_slot);
-	  /* Turn on the export buffer check process */
-	  vlib_process_signal_event (vm, em->export_process_node_index, 1, 0);
-
-	}
-      else
-	{
-	  return (-2);
-	}
-    }
-  else
-    {
-      ip6_hbh_set_next_override (IP6_LOOKUP_NEXT_POP_HOP_BY_HOP);
-      ioam_export_header_cleanup (em, collector_address, src_address);
-      ioam_export_thread_buffer_free (em);
-      /* Turn off the export buffer check process */
-      vlib_process_signal_event (vm, em->export_process_node_index, 2, 0);
-
-    }
-
-  return 0;
-}
-
-/* API message handler */
-static void vl_api_ioam_export_ip6_enable_disable_t_handler
-  (vl_api_ioam_export_ip6_enable_disable_t * mp)
-{
-  vl_api_ioam_export_ip6_enable_disable_reply_t *rmp;
-  ioam_export_main_t *sm = &ioam_export_main;
-  int rv;
-
-  rv = ioam_export_ip6_enable_disable (sm, (int) (mp->is_disable),
-				       (ip4_address_t *)
-				       mp->collector_address,
-				       (ip4_address_t *) mp->src_address);
-
-  REPLY_MACRO (VL_API_IOAM_EXPORT_IP6_ENABLE_DISABLE_REPLY);
-}
-
-static clib_error_t *
-set_ioam_export_ipfix_command_fn (vlib_main_t * vm,
-				  unformat_input_t * input,
-				  vlib_cli_command_t * cmd)
-{
-  ioam_export_main_t *em = &ioam_export_main;
-  ip4_address_t collector, src;
-  u8 is_disable = 0;
-
-  collector.as_u32 = 0;
-  src.as_u32 = 0;
-
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "collector %U", unformat_ip4_address, &collector))
-	;
-      else if (unformat (input, "src %U", unformat_ip4_address, &src))
-	;
-      else if (unformat (input, "disable"))
-	is_disable = 1;
-      else
-	break;
-    }
-
-  if (collector.as_u32 == 0)
-    return clib_error_return (0, "collector address required");
-
-  if (src.as_u32 == 0)
-    return clib_error_return (0, "src address required");
-
-  em->ipfix_collector.as_u32 = collector.as_u32;
-  em->src_address.as_u32 = src.as_u32;
-
-  vlib_cli_output (vm, "Collector %U, src address %U",
-		   format_ip4_address, &em->ipfix_collector,
-		   format_ip4_address, &em->src_address);
-
-  /* Turn on the export timer process */
-  // vlib_process_signal_event (vm, flow_report_process_node.index,
-  //1, 0);
-  ioam_export_ip6_enable_disable (em, is_disable, &collector, &src);
-
-  return 0;
-}
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (set_ipfix_command, static) =
-{
-.path = "set ioam export ipfix",.short_help =
-    "set ioam export ipfix collector <ip4-address> src <ip4-address>",.
-    function = set_ioam_export_ipfix_command_fn,};
-/* *INDENT-ON* */
-
-#include <ioam/export/ioam_export.api.c>
-static clib_error_t *
-ioam_export_init (vlib_main_t * vm)
-{
-  ioam_export_main_t *em = &ioam_export_main;
-  u32 node_index = export_node.index;
-  vlib_node_t *ip6_hbyh_node = NULL;
-
-  em->vlib_main = vm;
-  em->vnet_main = vnet_get_main ();
-  em->set_id = IPFIX_IOAM_EXPORT_ID;
-  ioam_export_reset_next_node (em);
-
-  /* Ask for a correctly-sized block of API message decode slots */
-  em->msg_id_base = setup_message_id_table ();
-
-  em->unix_time_0 = (u32) time (0);	/* Store starting time */
-  em->vlib_time_0 = vlib_time_now (vm);
-
-  /* Hook this export node to ip6-hop-by-hop */
-  ip6_hbyh_node = vlib_get_node_by_name (vm, (u8 *) "ip6-hop-by-hop");
-  em->my_hbh_slot = vlib_node_add_next (vm, ip6_hbyh_node->index, node_index);
-
-  return 0;
-}
-
-VLIB_INIT_FUNCTION (ioam_export_init);
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/export/ioam_export_test.c b/ioam/export/ioam_export_test.c
deleted file mode 100644
index a98a5f5..0000000
--- a/ioam/export/ioam_export_test.c
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- *------------------------------------------------------------------
- * ioam_export_test.c - test harness plugin
- *------------------------------------------------------------------
- */
-
-#include <vat/vat.h>
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-#include <vppinfra/error.h>
-#include <vnet/format_fns.h>
-
-#define __plugin_msg_base ioam_export_test_main.msg_id_base
-#include <vlibapi/vat_helper_macros.h>
-
-/* Declare message IDs */
-#include <ioam/export/ioam_export.api_enum.h>
-#include <ioam/export/ioam_export.api_types.h>
-
-typedef struct
-{
-  /* API message ID base */
-  u16 msg_id_base;
-  vat_main_t *vat_main;
-} ioam_export_test_main_t;
-
-static ioam_export_test_main_t ioam_export_test_main;
-
-static int
-api_ioam_export_ip6_enable_disable (vat_main_t * vam)
-{
-  unformat_input_t *i = vam->input;
-  int is_disable = 0;
-  vl_api_ioam_export_ip6_enable_disable_t *mp;
-  int ret;
-
-  /* Parse args required to build the message */
-  while (unformat_check_input (i) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (i, "disable"))
-	is_disable = 1;
-      else
-	break;
-    }
-
-  /* Construct the API message */
-  M(IOAM_EXPORT_IP6_ENABLE_DISABLE, mp);
-  mp->is_disable = is_disable;
-
-  /* send it... */
-  S(mp);
-
-  /* Wait for a reply... */
-  W (ret);
-  return ret;
-}
-
-/* Override generated plugin register symbol */
-#define vat_plugin_register ioam_export_vat_plugin_register
-#include <ioam/export/ioam_export.api_test.c>
diff --git a/ioam/export/ioam_export_thread.c b/ioam/export/ioam_export_thread.c
deleted file mode 100644
index be1a2be..0000000
--- a/ioam/export/ioam_export_thread.c
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- * ioam_export_thread.c
- */
-#include <vnet/api_errno.h>
-#include <vppinfra/pool.h>
-#include <vnet/ethernet/ethernet.h>
-#include <ioam/export-common/ioam_export.h>
-
-static vlib_node_registration_t ioam_export_process_node;
-extern ioam_export_main_t ioam_export_main;
-
-static uword
-ioam_export_process (vlib_main_t * vm,
-		     vlib_node_runtime_t * rt, vlib_frame_t * f)
-{
-   return (ioam_export_process_common(&ioam_export_main,
-                                      vm, rt, f,
-                                      ioam_export_process_node.index));
-}
-
-VLIB_REGISTER_NODE (ioam_export_process_node, static) =
-{
- .function = ioam_export_process,
- .type = VLIB_NODE_TYPE_PROCESS,
- .name = "ioam-export-process",
-};
diff --git a/ioam/export/node.c b/ioam/export/node.c
deleted file mode 100644
index 518fadd..0000000
--- a/ioam/export/node.c
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <vlib/vlib.h>
-#include <vnet/vnet.h>
-#include <vppinfra/error.h>
-#include <vnet/ethernet/ethernet.h>
-#include <vnet/ip/ip.h>
-#include <vnet/ip/ip6_hop_by_hop.h>
-#include <ioam/export-common/ioam_export.h>
-
-
-typedef struct
-{
-  u32 next_index;
-  u32 flow_label;
-} export_trace_t;
-
-/* packet trace format function */
-static u8 *
-format_export_trace (u8 * s, va_list * args)
-{
-  CLIB_UNUSED (vlib_main_t * vm) = va_arg (*args, vlib_main_t *);
-  CLIB_UNUSED (vlib_node_t * node) = va_arg (*args, vlib_node_t *);
-  export_trace_t *t = va_arg (*args, export_trace_t *);
-
-  s = format (s, "EXPORT: flow_label %d, next index %d",
-	      t->flow_label, t->next_index);
-  return s;
-}
-
-vlib_node_registration_t export_node;
-extern ioam_export_main_t ioam_export_main;
-
-#define foreach_export_error \
-_(RECORDED, "Packets recorded for export")
-
-typedef enum
-{
-#define _(sym,str) EXPORT_ERROR_##sym,
-  foreach_export_error
-#undef _
-    EXPORT_N_ERROR,
-} export_error_t;
-
-static char *export_error_strings[] = {
-#define _(sym,string) string,
-  foreach_export_error
-#undef _
-};
-
-typedef enum
-{
-  EXPORT_NEXT_POP_HBYH,
-  EXPORT_N_NEXT,
-} export_next_t;
-
-always_inline void
-copy3cachelines (void *dst, const void *src, size_t n)
-{
-#if 0
-  if (PREDICT_FALSE (n < DEFAULT_EXPORT_SIZE))
-    {
-      /* Copy only the first 1/2 cache lines whatever is available */
-      if (n >= 64)
-	clib_mov64 ((u8 *) dst, (const u8 *) src);
-      if (n >= 128)
-	clib_mov64 ((u8 *) dst + 64, (const u8 *) src + 64);
-      return;
-    }
-  clib_mov64 ((u8 *) dst, (const u8 *) src);
-  clib_mov64 ((u8 *) dst + 64, (const u8 *) src + 64);
-  clib_mov64 ((u8 *) dst + 128, (const u8 *) src + 128);
-#endif
-#if 1
-
-  u64 *copy_dst, *copy_src;
-  int i;
-  copy_dst = (u64 *) dst;
-  copy_src = (u64 *) src;
-  if (PREDICT_FALSE (n < DEFAULT_EXPORT_SIZE))
-    {
-      for (i = 0; i < n / 64; i++)
-	{
-	  copy_dst[0] = copy_src[0];
-	  copy_dst[1] = copy_src[1];
-	  copy_dst[2] = copy_src[2];
-	  copy_dst[3] = copy_src[3];
-	  copy_dst[4] = copy_src[4];
-	  copy_dst[5] = copy_src[5];
-	  copy_dst[6] = copy_src[6];
-	  copy_dst[7] = copy_src[7];
-	  copy_dst += 8;
-	  copy_src += 8;
-	}
-      return;
-    }
-  for (i = 0; i < 3; i++)
-    {
-      copy_dst[0] = copy_src[0];
-      copy_dst[1] = copy_src[1];
-      copy_dst[2] = copy_src[2];
-      copy_dst[3] = copy_src[3];
-      copy_dst[4] = copy_src[4];
-      copy_dst[5] = copy_src[5];
-      copy_dst[6] = copy_src[6];
-      copy_dst[7] = copy_src[7];
-      copy_dst += 8;
-      copy_src += 8;
-    }
-#endif
-}
-
-static void
-ip6_export_fixup_func (vlib_buffer_t * export_buf, vlib_buffer_t * pak_buf)
-{
-  ip6_header_t *ip6_temp =
-      (ip6_header_t *) (export_buf->data + export_buf->current_length);
-  u32 flow_label_temp =
-      clib_net_to_host_u32(ip6_temp->ip_version_traffic_class_and_flow_label)
-      & 0xFFF00000;
-  flow_label_temp |=
-      IOAM_MASK_DECAP_BIT((vnet_buffer(pak_buf)->l2_classify.opaque_index));
-  ip6_temp->ip_version_traffic_class_and_flow_label =
-      clib_host_to_net_u32(flow_label_temp);
-}
-
-static uword
-ip6_export_node_fn (vlib_main_t * vm,
-		    vlib_node_runtime_t * node, vlib_frame_t * frame)
-{
-  ioam_export_main_t *em = &ioam_export_main;
-  ioam_export_node_common(em, vm, node, frame, ip6_header_t, payload_length,
-                          ip_version_traffic_class_and_flow_label, 
-                          EXPORT_NEXT_POP_HBYH, ip6_export_fixup_func);
-  return frame->n_vectors;
-}
-
-/*
- * Node for IP6 export
- */
-VLIB_REGISTER_NODE (export_node) =
-{
-  .function = ip6_export_node_fn,
-  .name = "ip6-export",
-  .vector_size = sizeof (u32),
-  .format_trace = format_export_trace,
-  .type = VLIB_NODE_TYPE_INTERNAL,
-  .n_errors = ARRAY_LEN (export_error_strings),
-  .error_strings = export_error_strings,
-  .n_next_nodes = EXPORT_N_NEXT,
-  /* edit / add dispositions here */
-  .next_nodes =
-  {
-    [EXPORT_NEXT_POP_HBYH] = "ip6-pop-hop-by-hop"
-  },
-};
diff --git a/ioam/ioam_plugin_doc.rst b/ioam/ioam_plugin_doc.rst
deleted file mode 100644
index 0f84d5f..0000000
--- a/ioam/ioam_plugin_doc.rst
+++ /dev/null
@@ -1,490 +0,0 @@
-Inband OAM (iOAM)
-=================
-
-In-band OAM (iOAM) is an implementation study to record operational
-information in the packet while the packet traverses a path between two
-points in the network.
-
-Overview of iOAM can be found in
-`iOAM-Devnet <https://github.com/ciscodevnet/iOAM>`__ page. The
-following IETF drafts detail the motivation and mechanism for recording
-operational information: -
-`iOAM-ietf-requirements <https://tools.ietf.org/html/draft-brockners-inband-oam-requirements-01>`__
-- Describes motivation and usecases for iOAM -
-`iOAM-ietf-data <https://tools.ietf.org/html/draft-brockners-inband-oam-data-01>`__
-- Describes data records that can be collected using iOAM -
-`iOAM-ietf-transport <https://tools.ietf.org/html/draft-brockners-inband-oam-transport-01>`__
-- Lists out the transport protocols and mechanism to carry iOAM data
-records -
-`iOAM-ietf-proof-of-transit <https://tools.ietf.org/html/draft-brockners-proof-of-transit-01>`__
-- Describes the idea of Proof of Transit (POT) and mechanisms to
-operationalize the idea
-
-Terminology
------------
-
-In-band OAM is expected to be deployed in a specific domain rather than
-on the overall Internet. The part of the network which employs in-band
-OAM is referred to as **in-band OAM-domain**.
-
-In-band OAM data is added to a packet on entering the in-band OAM-domain
-and is removed from the packet when exiting the domain. Within the
-in-band OAM-domain, network nodes that the packet traverses may update
-the in-band OAM data records.
-
--  The node which adds in-band OAM data to the packet is called the
-   **in-band OAM encapsulating node**.
-
--  The node which removes the in-band OAM data is referred to as the
-   **in-band OAM decapsulating node**.
-
--  Nodes within the domain which are aware of in-band OAM data and read
-   and/or write or process the in-band OAM data are called **in-band
-   OAM transit nodes**.
-
-Features supported in the current release
------------------------------------------
-
-VPP can function as in-band OAM encapsulating, transit and decapsulating
-node. In this version of VPP in-band OAM data is transported as options
-in an IPv6 hop-by-hop extension header. Hence in-band OAM can be enabled
-for IPv6 traffic.
-
-The following iOAM features are supported:
-
--  **In-band OAM Tracing** : In-band OAM supports multiple data records
-   to be recorded in the packet as the packet traverses the network.
-   These data records offer insights into the operational behavior of
-   the network. The following information can be collected in the
-   tracing data from the nodes a packet traverses:
-
-   -  Node ID
-   -  Ingress interface ID
-   -  Egress interface ID
-   -  Timestamp
-   -  Pre-configured application data
-
--  **In-band OAM Proof of Transit (POT)**: Proof of transit iOAM data is
-   added to every packet for verifying that a packet traverses a
-   specific set of nodes. In-band OAM data is updated at every node that
-   is enabled with iOAM proof of transit and is used to verify whether a
-   packet traversed all the specified nodes. When the verifier receives
-   each packet, it can validate whether the packet traversed the
-   specified nodes.
-
-Configuration
--------------
-
-Configuring iOAM involves: - Selecting the packets for which iOAM data
-must be inserted, updated or removed - Selection of packets for iOAM
-data insertion on iOAM encapsulating node. Selection of packets is done
-by 5-tuple based classification - Selection of packets for updating iOAM
-data is implicitly done on the presence of iOAM options in the packet -
-Selection of packets for removing the iOAM data is done on 5-tuple based
-classification - The kind of data to be collected - Tracing data - Proof
-of transit - Additional details for processing iOAM data to be collected
-- For trace data - trace type, number of nodes to be recorded in the
-trace, time stamp precision, etc. - For POT data - configuration of POT
-profile required to process the POT data
-
-The CLI for configuring iOAM is explained here followed by detailed
-steps and examples to deploy iOAM on VPP as an encapsulating, transit or
-decapsulating iOAM node in the subsequent sub-sections.
-
-VPP iOAM configuration for enabling trace and POT is as follows:
-
-::
-
-   set ioam rewrite trace-type <0x1f|0x7|0x9|0x11|0x19>
-   trace-elts <number of trace elements> trace-tsp <0|1|2|3>
-   node-id <node ID in hex> app-data <application data in hex> [pot]
-
-A description of each of the options of the CLI follows: - trace-type :
-An entry in the Node data List array of the trace option can have
-different formats, following the needs of the a deployment. For example:
-Some deployments might only be interested in recording the node
-identifiers, whereas others might be interested in recording node
-identifier and timestamp. The following types are currently supported: -
-0x1f : Node data to include hop limit (8 bits), node ID (24 bits),
-ingress and egress interface IDs (16 bits each), timestamp (32 bits),
-application data (32 bits) - 0x7 : Node data to include hop limit (8
-bits), node ID (24 bits), ingress and egress interface IDs (16 bits
-each) - 0x9 : Node data to include hop limit (8 bits), node ID (24
-bits), timestamp (32 bits) - 0x11: Node data to include hop limit (8
-bits), node ID (24 bits), application data (32 bits) - 0x19: Node data
-to include hop limit (8 bits), node ID (24 bits), timestamp (32 bits),
-application data (32 bits) - trace-elts : Defines the length of the node
-data array in the trace option. - trace-tsp : Defines the timestamp
-precision to use with the enumerated value for precision as follows: - 0
-: 32bits timestamp in seconds - 1 : 32bits timestamp in milliseconds - 2
-: 32bits timestamp in microseconds - 3 : 32bits timestamp in nanoseconds
-- node-id : Unique identifier for the node, included in the node ID
-field of the node data in trace option. - app-data : The value
-configured here is included as is in application data field of node data
-in trace option. - pot : Enables POT option to be included in the iOAM
-options.
-
-Trace configuration
-~~~~~~~~~~~~~~~~~~~
-
-On in-band OAM encapsulating node
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
--  **Configure classifier and apply ACL** to select packets for iOAM
-   data insertion
-
-   -  Example to enable iOAM data insertion for all the packets towards
-      IPv6 address db06::06:
-
-   vpp# classify table miss-next node ip6-lookup mask l3 ip6 dst
-
-   vpp# classify session acl-hit-next node ip6-add-hop-by-hop
-   table-index 0 match l3 ip6 dst db06::06
-
-   vpp# set int input acl intfc GigabitEthernet0/0/0 ip6-table 0
-
--  **Enable tracing** : Specify node ID, maximum number of nodes for
-   which trace data should be recorded, type of data to be included for
-   recording, optionally application data to be included
-
-   -  Example to enable tracing with a maximum of 4 nodes recorded and
-      the data to be recorded to include - hop limit, node id, ingress
-      and egress interface IDs, timestamp (millisecond precision),
-      application data (0x1234):
-
-   vpp# set ioam rewrite trace-type 0x1f trace-elts 4 trace-tsp 1
-   node-id 0x1 app-data 0x1234
-
-On in-band OAM transit node
-^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
--  The transit node requires trace type, timestamp precision, node ID
-   and optionally application data to be configured, to update its node
-   data in the trace option.
-
-Example:
-
-::
-
-   vpp# set ioam rewrite trace-type 0x1f trace-elts 4 trace-tsp 1
-   node-id 0x2 app-data 0x1234
-
-On the In-band OAM decapsulating node
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
--  The decapsulating node similar to encapsulating node requires
-   **classification** of the packets to remove iOAM data from.
-
-   -  Example to decapsulate iOAM data for packets towards db06::06,
-      configure classifier and enable it as an ACL as follows:
-
-   vpp# classify table miss-next node ip6-lookup mask l3 ip6 dst
-
-   vpp# classify session acl-hit-next node ip6-lookup table-index 0
-   match l3 ip6 dst db06::06 opaque-index 100
-
-   vpp# set int input acl intfc GigabitEthernet0/0/0 ip6-table 0
-
--  Decapsulating node requires trace type, timestamp precision, node ID
-   and optionally application data to be configured, to update its node
-   data in the trace option before it is decapsulated.
-
-Example:
-
-::
-
-   vpp# set ioam rewrite trace-type 0x1f trace-elts 4
-   trace-tsp 1 node-id 0x3 app-data 0x1234
-
-Proof of Transit configuration
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-For details on proof-of-transit, see the IETF draft
-`iOAM-ietf-proof-of-transit <https://tools.ietf.org/html/draft-brockners-proof-of-transit-01>`__.
-To enable Proof of Transit all the nodes that participate and hence are
-verified for transit need a proof of transit profile. A script to
-generate a proof of transit profile as per the mechanism described in
-`iOAM-ietf-proof-of-transit <https://tools.ietf.org/html/draft-brockners-proof-of-transit-01>`__
-will be available at
-`iOAM-Devnet <https://github.com/ciscodevnet/iOAM>`__.
-
-The Proof of transit mechanism implemented here is based on Shamirs
-Secret Sharing algorithm. The overall algorithm uses two polynomials
-POLY-1 and POLY-2. The degree of polynomials depends on number of nodes
-to be verified for transit. POLY-1 is secret and constant. Each node
-gets a point on POLY-1 at setup-time and keeps it secret. POLY-2 is
-public, random and per packet. Each node is assigned a point on POLY-1
-and POLY-2 with the same x index. Each node derives its point on POLY-2
-each time a packet arrives at it. A node then contributes its points on
-POLY-1 and POLY-2 to construct POLY-3 (POLY-3 = POLY-1 + POLY-2) using
-lagrange extrapolation and forwards it towards the verifier by updating
-POT data in the packet. The verifier constructs POLY-3 from the
-accumulated value from all the nodes and its own points on POLY-1 and
-POLY-2 and verifies whether POLY-3 = POLY-1 + POLY-2. Only the verifier
-knows POLY-1. The solution leverages finite field arithmetic in a field
-of size prime number for reasons explained in description of Shamirs
-secret sharing algorithm.
-
-| Here is an explanation of POT profile list and profile configuration
-  CLI to realize the above mechanism. It is best to use the script
-  provided at `iOAM-Devnet <https://github.com/ciscodevnet/iOAM>`__ to
-  generate this configuration. - **Create POT profile** : set pot
-  profile name id [0-1]
-| [validator-key 0xu64] prime-number 0xu64 secret_share 0xu64
-| lpc 0xu64 polynomial2 0xu64 bits-in-random [0-64]
-| - name : Profile list name. - id : Profile id, it can be 0 or 1. A
-  maximum of two profiles can be configured per profile list. -
-  validator-key : Secret key configured only on the
-  verifier/decapsulating node used to compare and verify proof of
-  transit. - prime-number : Prime number for finite field arithmetic as
-  required by the proof of transit mechanism. - secret_share : Unique
-  point for each node on the secret polynomial POLY-1. - lpc : Lagrange
-  Polynomial Constant(LPC) calculated per node based on its point (x
-  value used for evaluating the points on the polynomial) on the
-  polynomial used in lagrange extrapolation for reconstructing
-  polynomial (POLY-3). - polynomial2 : Is the pre-evaluated value of the
-  point on 2nd polynomial(POLY-2). This is unique for each node. It is
-  pre-evaluated for all the coefficients of POLY-2 except for the
-  constant part of the polynomial that changes per packet and is
-  received as part of the POT data in the packet. - bits-in-random : To
-  control the size of the random number to be generated. This number has
-  to match the other numbers generated and used in the profile as per
-  the algorithm.
-
--  **Set a configured profile as active/in-use** :
-   set pot profile-active name ID [0-1]
-
-   -  name : Name of the profile list to be used for computing POT data
-      per packet.
-   -  ID : Identifier of the profile within the list to be used.
-
-.. _on-in-band-oam-encapsulating-node-1:
-
-On In-band OAM encapsulating node
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
--  Configure the classifier and apply ACL to select packets for iOAM
-   data insertion.
-
-   -  Example to enable iOAM data insertion for all the packet towards
-      IPv6 address db06::06 -
-
-   vpp# classify table miss-next node ip6-lookup mask l3 ip6 dst
-
-   vpp# classify session acl-hit-next node ip6-add-hop-by-hop
-   table-index 0 match l3 ip6 dst db06::06
-
-   vpp# set int input acl intfc GigabitEthernet0/0/0 ip6-table 0
-
--  Configure the proof of transit profile list with profiles. Each
-   profile list referred to by a name can contain 2 profiles, only one
-   is in use for updating proof of transit data at any time.
-
-   -  Example profile list example with a profile generated from the
-      script to verify transit through 3 nodes is:
-
-   vpp# set pot profile name example id 0 prime-number
-   0x7fff0000fa884685 secret_share 0x6c22eff0f45ec56d lpc
-   0x7fff0000fa884682 polynomial2 0xffb543d4a9c bits-in-random 63
-
--  Enable one of the profiles from the configured profile list as active
-   so that is will be used for calculating proof of transit
-
-Example enable profile ID 0 from profile list example configured above:
-
-::
-
-   vpp# set pot profile-active name example ID 0
-
--  Enable POT option to be inserted
-
-   vpp# set ioam rewrite pot
-
-.. _on-in-band-oam-transit-node-1:
-
-On in-band OAM transit node
-^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
--  Configure the proof of transit profile list with profiles for transit
-   node. Example:
-
-   vpp# set pot profile name example id 0 prime-number
-   0x7fff0000fa884685 secret_share 0x564cdbdec4eb625d lpc 0x1
-   polynomial2 0x23f3a227186a bits-in-random 63
-
-On in-band OAM decapsulating node / verifier
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
--  The decapsulating node, similar to the encapsulating node requires
-   classification of the packets to remove iOAM data from.
-
-   -  Example to decapsulate iOAM data for packets towards db06::06
-      configure classifier and enable it as an ACL as follows:
-
-   vpp# classify table miss-next node ip6-lookup mask l3 ip6 dst
-
-   vpp# classify session acl-hit-next node ip6-lookup table-index 0
-   match l3 ip6 dst db06::06 opaque-index 100
-
-   vpp# set int input acl intfc GigabitEthernet0/0/0 ip6-table 0
-
--  To update and verify the proof of transit, POT profile list should be
-   configured.
-
-   -  Example POT profile list configured as follows:
-
-   vpp# set pot profile name example id 0 validate-key
-   0x7fff0000fa88465d prime-number 0x7fff0000fa884685 secret_share
-   0x7a08fbfc5b93116d lpc 0x3 polynomial2 0x3ff738597ce bits-in-random
-   63
-
-Operational data
-----------------
-
-Following CLIs are available to check iOAM operation: - To check iOAM
-configuration that are effective use show ioam summary
-
-Example:
-
-::
-
-   vpp# show ioam summary
-                 REWRITE FLOW CONFIGS - Not configured
-    HOP BY HOP OPTIONS - TRACE CONFIG -
-                           Trace Type : 0x1f (31)
-            Trace timestamp precision : 1 (Milliseconds)
-                   Num of trace nodes : 4
-                              Node-id : 0x2 (2)
-                             App Data : 0x1234 (4660)
-                           POT OPTION - 1 (Enabled)
-   Try 'show ioam pot and show pot profile' for more information
-
--  To find statistics about packets for which iOAM options were added
-   (encapsulating node) and removed (decapsulating node) execute *show
-   errors*
-
-Example on encapsulating node:
-
-::
-
-   vpp# show error
-      Count                    Node                  Reason
-   1208804706                ip6-inacl               input ACL hits
-   1208804706           ip6-add-hop-by-hop           Pkts w/ added ip6 hop-by-hop options
-
-Example on decapsulating node:
-
-::
-
-   vpp# show error
-      Count                    Node                  Reason
-     69508569                ip6-inacl               input ACL hits
-     69508569           ip6-pop-hop-by-hop           Pkts w/ removed ip6 hop-by-hop options
-
--  To check the POT profiles use show pot profile
-
-Example:
-
-::
-
-   vpp# show pot profile
-   Profile list in use  : example
-   POT Profile at index: 0
-                    ID : 0
-             Validator : False (0)
-          Secret share : 0x564cdbdec4eb625d (6218586935324795485)
-          Prime number : 0x7fff0000fa884685 (9223090566081300101)
-   2nd polynomial(eval) : 0x23f3a227186a (39529304496234)
-                    LPC : 0x1 (1)
-              Bit mask : 0x7fffffffffffffff (9223372036854775807)
-   Profile index in use: 0
-   Pkts passed : 0x36 (54)
-
--  To get statistics of POT for packets use show ioam pot
-
-Example at encapsulating or transit node:
-
-::
-
-   vpp# show ioam pot
-    Pkts with ip6 hop-by-hop POT options - 54
-    Pkts with ip6 hop-by-hop POT options but no profile set - 0
-    Pkts with POT in Policy - 0
-    Pkts with POT out of Policy - 0
-
-Example at decapsulating/verification node:
-
-::
-
-   vpp# show ioam pot
-    Pkts with ip6 hop-by-hop POT options - 54
-    Pkts with ip6 hop-by-hop POT options but no profile set - 0
-    Pkts with POT in Policy - 54
-    Pkts with POT out of Policy - 0
-
--  Tracing - enable trace of IPv6 packets to view the data inserted and
-   collected.
-
-Example when the nodes are receiving data over a DPDK interface: Enable
-tracing using trace add dpdk-input 20 and execute show trace to view
-the iOAM data collected:
-
-::
-
-    vpp# trace add dpdk-input 20
-
-    vpp# show trace
-
-    ------------------- Start of thread 0 vpp_main -------------------
-
-    Packet 1
-
-    00:00:19:294697: dpdk-input
-      GigabitEthernetb/0/0 rx queue 0
-      buffer 0x10e6b: current data 0, length 214, free-list 0, totlen-nifb 0, trace 0x0
-      PKT MBUF: port 0, nb_segs 1, pkt_len 214
-        buf_len 2176, data_len 214, ol_flags 0x0, data_off 128, phys_addr 0xe9a35a00
-        packet_type 0x0
-      IP6: 00:50:56:9c:df:72 -> 00:50:56:9c:be:55
-      IP6_HOP_BY_HOP_OPTIONS: db05::2 -> db06::6
-        tos 0x00, flow label 0x0, hop limit 63, payload length 160
-    00:00:19:294737: ethernet-input
-      IP6: 00:50:56:9c:df:72 -> 00:50:56:9c:be:55
-    00:00:19:294753: ip6-input
-      IP6_HOP_BY_HOP_OPTIONS: db05::2 -> db06::6
-        tos 0x00, flow label 0x0, hop limit 63, payload length 160
-    00:00:19:294757: ip6-lookup
-      fib 0 adj-idx 15 : indirect via db05::2 flow hash: 0x00000000
-      IP6_HOP_BY_HOP_OPTIONS: db05::2 -> db06::6
-        tos 0x00, flow label 0x0, hop limit 63, payload length 160
-    00:00:19:294802: ip6-hop-by-hop
-      IP6_HOP_BY_HOP: next index 5 len 96 traced 96  Trace Type 0x1f , 1 elts left
-        [0] ttl 0x0 node ID 0x0 ingress 0x0 egress 0x0 ts 0x0
-    app 0x0
-        [1] ttl 0x3e node ID 0x3 ingress 0x1 egress 0x2 ts 0xb68c2213
-    app 0x1234
-        [2] ttl 0x3f node ID 0x2 ingress 0x1 egress 0x2 ts 0xb68c2204
-    app 0x1234
-        [3] ttl 0x40 node ID 0x1 ingress 0x5 egress 0x6 ts 0xb68c2200
-    app 0x1234
-        POT opt present
-              random = 0x577a916946071950, Cumulative = 0x10b46e78a35a392d, Index = 0x0
-    00:00:19:294810: ip6-rewrite
-      tx_sw_if_index 1 adj-idx 14 : GigabitEthernetb/0/0
-                                    IP6: 00:50:56:9c:be:55 -> 00:50:56:9c:df:72 flow hash: 0x00000000
-      IP6: 00:50:56:9c:be:55 -> 00:50:56:9c:df:72
-      IP6_HOP_BY_HOP_OPTIONS: db05::2 -> db06::6
-        tos 0x00, flow label 0x0, hop limit 62, payload length 160
-    00:00:19:294814: GigabitEthernetb/0/0-output
-      GigabitEthernetb/0/0
-      IP6: 00:50:56:9c:be:55 -> 00:50:56:9c:df:72
-      IP6_HOP_BY_HOP_OPTIONS: db05::2 -> db06::6
-        tos 0x00, flow label 0x0, hop limit 62, payload length 160
-    00:00:19:294820: GigabitEthernetb/0/0-tx
-      GigabitEthernetb/0/0 tx queue 0
-      buffer 0x10e6b: current data 0, length 214, free-list 0, totlen-nifb 0, trace 0x0
-      IP6: 00:50:56:9c:be:55 -> 00:50:56:9c:df:72
-
-      IP6_HOP_BY_HOP_OPTIONS: db05::2 -> db06::6
-
-        tos 0x00, flow label 0x0, hop limit 62, payload length 160
diff --git a/ioam/ioam_test.c b/ioam/ioam_test.c
deleted file mode 100644
index 228ac07..0000000
--- a/ioam/ioam_test.c
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (c) 2018 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <vat/vat.h>
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-#include <vnet/format_fns.h>
-#include <vnet/ip/ip_types_api.h>
-
-clib_error_t * vxlan_gpe_ioam_export_vat_plugin_register (vat_main_t * vam);
-clib_error_t * pot_vat_plugin_register (vat_main_t *vam);
-clib_error_t * trace_vat_plugin_register (vat_main_t * vam);
-clib_error_t * vxlan_gpe_vat_plugin_register (vat_main_t * vam);
-clib_error_t * udp_ping_vat_plugin_register (vat_main_t * vam);
-clib_error_t * ioam_export_vat_plugin_register (vat_main_t * vam);
-
-clib_error_t *
-vat_plugin_register (vat_main_t *vam)
-{
-  clib_error_t *err;
-
-  if ((err = pot_vat_plugin_register (vam)))
-    return err;
-
-  if ((err = vxlan_gpe_ioam_export_vat_plugin_register (vam)))
-    return err;
-
-  if ((err = trace_vat_plugin_register (vam)))
-    return err;
-
-  if ((err = vxlan_gpe_vat_plugin_register(vam)))
-    return err;
-
-  if ((err = udp_ping_vat_plugin_register (vam)))
-    return err;
-
-  if ((err = ioam_export_vat_plugin_register (vam)))
-    return err;
-
-  return 0;
-}
-uword unformat_ip46_address (unformat_input_t * input, va_list * args)
-{
-  ip46_address_t *ip46 = va_arg (*args, ip46_address_t *);
-  ip46_type_t type = va_arg (*args, ip46_type_t);
-  if ((type != IP46_TYPE_IP6) &&
-      unformat(input, "%U", unformat_ip4_address, &ip46->ip4)) {
-    ip46_address_mask_ip4(ip46);
-    return 1;
-  } else if ((type != IP46_TYPE_IP4) &&
-      unformat(input, "%U", unformat_ip6_address, &ip46->ip6)) {
-    return 1;
-  }
-  return 0;
-}
diff --git a/ioam/ip6/ioam_cache.api b/ioam/ip6/ioam_cache.api
deleted file mode 100644
index 963c033..0000000
--- a/ioam/ip6/ioam_cache.api
+++ /dev/null
@@ -1,30 +0,0 @@
-/* Hey Emacs use -*- mode: C -*- */
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-option version = "1.0.0";
-
-/*  API to control ioam caching */
-
-autoreply define ioam_cache_ip6_enable_disable {
-    /* Client identifier, set from api_main.my_client_index */
-    u32 client_index;
-
-    /* Arbitrary context, so client can match reply to request */
-    u32 context;
-
-    /* Enable / disable the feature */
-    bool is_disable;
-};
diff --git a/ioam/ip6/ioam_cache.c b/ioam/ip6/ioam_cache.c
deleted file mode 100644
index d9f7029..0000000
--- a/ioam/ip6/ioam_cache.c
+++ /dev/null
@@ -1,354 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- *------------------------------------------------------------------
- * ioam_cache.c - ioam ip6 API / debug CLI handling
- *------------------------------------------------------------------
- */
-
-#include <vnet/vnet.h>
-#include <vnet/plugin/plugin.h>
-#include <ioam/ip6/ioam_cache.h>
-
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-#include <vnet/ip/ip6_hop_by_hop.h>
-
-#include "ioam_cache.h"
-
-/* define message IDs */
-#include <ioam/ip6/ioam_cache.api_enum.h>
-#include <ioam/ip6/ioam_cache.api_types.h>
-
-#define REPLY_MSG_ID_BASE cm->msg_id_base
-#include <vlibapi/api_helper_macros.h>
-
-ioam_cache_main_t ioam_cache_main;
-
-static u8 *
-ioam_e2e_id_trace_handler (u8 * s, ip6_hop_by_hop_option_t * opt)
-{
-  ioam_e2e_id_option_t *e2e = (ioam_e2e_id_option_t *) opt;
-
-  if (e2e)
-    {
-      s =
-	format (s, "IP6_HOP_BY_HOP E2E ID = %U\n", format_ip6_address,
-		&(e2e->id));
-    }
-
-
-  return s;
-}
-
-static u8 *
-ioam_e2e_cache_trace_handler (u8 * s, ip6_hop_by_hop_option_t * opt)
-{
-  ioam_e2e_cache_option_t *e2e = (ioam_e2e_cache_option_t *) opt;
-
-  if (e2e)
-    {
-      s =
-	format (s, "IP6_HOP_BY_HOP E2E CACHE = pool:%d idx:%d\n",
-		e2e->pool_id, e2e->pool_index);
-    }
-
-
-  return s;
-}
-
-/* Action function shared between message handler and debug CLI */
-int
-ioam_cache_ip6_enable_disable (ioam_cache_main_t * em,
-			       ip6_address_t * sr_localsid, u8 is_disable)
-{
-  vlib_main_t *vm = em->vlib_main;
-
-  if (is_disable == 0)
-    {
-      ioam_cache_table_init (vm);
-      em->sr_localsid_cache.as_u64[0] = sr_localsid->as_u64[0];
-      em->sr_localsid_cache.as_u64[1] = sr_localsid->as_u64[1];
-      ip6_hbh_set_next_override (em->cache_hbh_slot);
-      ip6_hbh_register_option (HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE_ID,
-			       0, ioam_e2e_id_trace_handler);
-      ip6_hbh_register_option (HBH_OPTION_TYPE_IOAM_E2E_CACHE_ID,
-			       0, ioam_e2e_cache_trace_handler);
-
-    }
-  else
-    {
-      ip6_hbh_set_next_override (IP6_LOOKUP_NEXT_POP_HOP_BY_HOP);
-      ioam_cache_table_destroy (vm);
-      em->sr_localsid_cache.as_u64[0] = 0;
-      em->sr_localsid_cache.as_u64[1] = 0;
-      ip6_hbh_unregister_option (HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE_ID);
-      ip6_hbh_unregister_option (HBH_OPTION_TYPE_IOAM_E2E_CACHE_ID);
-    }
-
-  return 0;
-}
-
-/* Action function shared between message handler and debug CLI */
-int
-ioam_tunnel_select_ip6_enable_disable (ioam_cache_main_t * em,
-				       u8 criteria,
-				       u8 no_of_responses,
-				       ip6_address_t * sr_localsid,
-				       u8 is_disable)
-{
-  vlib_main_t *vm = em->vlib_main;
-
-  if (is_disable == 0)
-    {
-      ioam_cache_ts_table_init (vm);
-      em->criteria_oneway = criteria;
-      em->wait_for_responses = no_of_responses;
-      em->sr_localsid_ts.as_u64[0] = sr_localsid->as_u64[0];
-      em->sr_localsid_ts.as_u64[1] = sr_localsid->as_u64[1];
-      ip6_hbh_set_next_override (em->ts_hbh_slot);
-      ip6_ioam_ts_cache_set_rewrite ();
-      ip6_hbh_register_option (HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE_ID,
-			       0, ioam_e2e_id_trace_handler);
-      ip6_hbh_register_option (HBH_OPTION_TYPE_IOAM_E2E_CACHE_ID,
-			       0, ioam_e2e_cache_trace_handler);
-
-      /* Turn on the cleanup process */
-      //      vlib_process_signal_event (vm, em->cleanup_process_node_index, 1, 0);
-    }
-  else
-    {
-      ioam_cache_ts_timer_node_enable (vm, 0);
-      ip6_hbh_set_next_override (IP6_LOOKUP_NEXT_POP_HOP_BY_HOP);
-      em->sr_localsid_ts.as_u64[0] = 0;
-      em->sr_localsid_ts.as_u64[1] = 0;
-      ioam_cache_ts_table_destroy (vm);
-      ip6_ioam_ts_cache_cleanup_rewrite ();
-      ip6_hbh_unregister_option (HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE_ID);
-      ip6_hbh_unregister_option (HBH_OPTION_TYPE_IOAM_E2E_CACHE_ID);
-    }
-
-  return 0;
-}
-
-/* API message handler */
-static void vl_api_ioam_cache_ip6_enable_disable_t_handler
-  (vl_api_ioam_cache_ip6_enable_disable_t * mp)
-{
-  vl_api_ioam_cache_ip6_enable_disable_reply_t *rmp;
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ip6_address_t sr_localsid;
-  int rv;
-
-  sr_localsid.as_u64[0] = 0;
-  sr_localsid.as_u64[1] = 0;
-  rv =
-    ioam_cache_ip6_enable_disable (cm, &sr_localsid, (int) (mp->is_disable));
-  REPLY_MACRO (VL_API_IOAM_CACHE_IP6_ENABLE_DISABLE_REPLY);
-}
-
-static clib_error_t *
-set_ioam_cache_command_fn (vlib_main_t * vm,
-			   unformat_input_t * input, vlib_cli_command_t * cmd)
-{
-  ioam_cache_main_t *em = &ioam_cache_main;
-  u8 is_disable = 0;
-  ip6_address_t sr_localsid;
-  u8 address_set = 0;
-
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "disable"))
-	is_disable = 1;
-      else if (!address_set
-	       && unformat (input, "sr_localsid %U", unformat_ip6_address,
-			    &sr_localsid))
-	address_set = 1;
-      else
-	break;
-    }
-
-  if (is_disable == 0 && !address_set)
-    return clib_error_return (0, "Error: SRv6 LocalSID address is mandatory");
-
-  ioam_cache_ip6_enable_disable (em, &sr_localsid, is_disable);
-
-  return 0;
-}
-
-/* *INDENT_OFF* */
-VLIB_CLI_COMMAND (set_ioam_cache_command, static) =
-{
-.path = "set ioam ip6 cache",.short_help =
-    "set ioam ip6 cache sr_localsid <ip6 address> [disable]",.function =
-    set_ioam_cache_command_fn};
-/* *INDENT_ON* */
-
-#define IOAM_TS_WAIT_FOR_RESPONSES 3
-static clib_error_t *
-set_ioam_tunnel_select_command_fn (vlib_main_t * vm,
-				   unformat_input_t * input,
-				   vlib_cli_command_t * cmd)
-{
-  ioam_cache_main_t *em = &ioam_cache_main;
-  u8 is_disable = 0;
-  u8 one_way = 0;
-  ip6_address_t sr_localsid;
-  u8 address_set = 0;
-  u8 no_of_responses = IOAM_TS_WAIT_FOR_RESPONSES;
-
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "disable"))
-	is_disable = 1;
-      else if (unformat (input, "rtt"))
-	one_way = 0;
-      else if (unformat (input, "oneway"))
-	one_way = 1;
-      else if (unformat (input, "wait_for_responses %d", &no_of_responses))
-	;
-      else if (!address_set
-	       && unformat (input, "sr_localsid %U", unformat_ip6_address,
-			    &sr_localsid))
-	address_set = 1;
-      else
-	break;
-    }
-  if (is_disable == 0 && !address_set)
-    return clib_error_return (0,
-			      "Error: SRv6 LocalSID address is mandatory to receive response.");
-
-  ioam_tunnel_select_ip6_enable_disable (em, one_way, no_of_responses,
-					 &sr_localsid, is_disable);
-
-  return 0;
-}
-
-/* *INDENT_OFF* */
-VLIB_CLI_COMMAND (set_ioam_cache_ts_command, static) =
-{
-.path = "set ioam ip6 sr-tunnel-select",.short_help =
-    "set ioam ip6 sr-tunnel-select [disable] [oneway|rtt] [wait_for_responses <n|default 3>] \
-  [sr_localsid <ip6 address>]",.function = set_ioam_tunnel_select_command_fn};
-/* *INDENT_ON* */
-
-static void
-ioam_cache_table_print (vlib_main_t * vm, u8 verbose)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ioam_cache_entry_t *entry = 0;
-  ioam_cache_ts_entry_t *ts_entry = 0;
-  int no_of_threads = vec_len (vlib_worker_threads);
-  int i;
-
-  pool_foreach (entry, cm->ioam_rewrite_pool)
-  {
-    vlib_cli_output (vm, "%U", format_ioam_cache_entry, entry);
-  }
-
-  if (cm->ts_stats)
-    for (i = 0; i < no_of_threads; i++)
-      {
-	vlib_cli_output (vm, "Number of entries in thread-%d selection pool: %lu\n \
-                          (pool found to be full: %lu times)", i,
-			 cm->ts_stats[i].inuse, cm->ts_stats[i].add_failed);
-
-	if (verbose == 1)
-	  vlib_worker_thread_barrier_sync (vm);
-	pool_foreach (ts_entry, cm->ioam_ts_pool[i])
-	{
-	  vlib_cli_output (vm, "%U", format_ioam_cache_ts_entry, ts_entry,
-			   (u32) i);
-	}
-	vlib_worker_thread_barrier_release (vm);
-      }
-
-}
-
-static clib_error_t *
-show_ioam_cache_command_fn (vlib_main_t * vm,
-			    unformat_input_t * input,
-			    vlib_cli_command_t * cmd)
-{
-  u8 verbose = 0;
-
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "verbose"))
-	verbose = 1;
-      else
-	return clib_error_return (0, "unknown input `%U'",
-				  format_unformat_error, input);
-    }
-  ioam_cache_table_print (vm, verbose);
-
-
-  return 0;
-}
-
-/* *INDENT_OFF* */
-VLIB_CLI_COMMAND (show_ioam_cache_command, static) =
-{
-.path = "show ioam ip6 cache",.short_help =
-    "show ioam ip6 cache [verbose]",.function = show_ioam_cache_command_fn};
-/* *INDENT_ON* */
-
-#include <ioam/ip6/ioam_cache.api.c>
-static clib_error_t *
-ioam_cache_init (vlib_main_t * vm)
-{
-  vlib_node_t *node;
-  ioam_cache_main_t *em = &ioam_cache_main;
-  u32 cache_node_index = ioam_cache_node.index;
-  u32 ts_node_index = ioam_cache_ts_node.index;
-  vlib_node_t *ip6_hbyh_node = NULL, *ip6_hbh_pop_node = NULL, *error_node =
-    NULL;
-
-  clib_memset (&ioam_cache_main, 0, sizeof (ioam_cache_main));
-  /* Ask for a correctly-sized block of API message decode slots */
-  em->msg_id_base = setup_message_id_table ();
-
-  /* Hook this node to ip6-hop-by-hop */
-  ip6_hbyh_node = vlib_get_node_by_name (vm, (u8 *) "ip6-hop-by-hop");
-  em->cache_hbh_slot =
-    vlib_node_add_next (vm, ip6_hbyh_node->index, cache_node_index);
-  em->ts_hbh_slot =
-    vlib_node_add_next (vm, ip6_hbyh_node->index, ts_node_index);
-
-  ip6_hbh_pop_node = vlib_get_node_by_name (vm, (u8 *) "ip6-pop-hop-by-hop");
-  em->ip6_hbh_pop_node_index = ip6_hbh_pop_node->index;
-
-  error_node = vlib_get_node_by_name (vm, (u8 *) "error-drop");
-  em->error_node_index = error_node->index;
-  em->vlib_main = vm;
-
-  node = vlib_get_node_by_name (vm, (u8 *) "ip6-add-from-cache-hop-by-hop");
-  em->ip6_add_from_cache_hbh_node_index = node->index;
-
-  node = vlib_get_node_by_name (vm, (u8 *) "ip6-add-syn-hop-by-hop");
-  em->ip6_reset_ts_hbh_node_index = node->index;
-
-  return 0;
-}
-
-VLIB_INIT_FUNCTION (ioam_cache_init);
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/ip6/ioam_cache.h b/ioam/ip6/ioam_cache.h
deleted file mode 100644
index 8c1b629..0000000
--- a/ioam/ip6/ioam_cache.h
+++ /dev/null
@@ -1,909 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef __included_ioam_cache_h__
-#define __included_ioam_cache_h__
-
-#include <vnet/vnet.h>
-#include <vnet/ip/ip.h>
-#include <vnet/ip/ip_packet.h>
-#include <vnet/ip/ip4_packet.h>
-#include <vnet/ip/ip6_packet.h>
-#include <vnet/srv6/sr.h>
-
-#include <vppinfra/pool.h>
-#include <vppinfra/hash.h>
-#include <vppinfra/error.h>
-#include <vppinfra/elog.h>
-#include <vppinfra/bihash_8_8.h>
-#include <ioam/analyse/ip6/ip6_ioam_analyse.h>
-#include <vppinfra/tw_timer_16t_2w_512sl.h>
-/*
- * ioam_cache.h
- * This header contains routines for caching of ioam header and
- * buffer:
- * 1 - On application facing node: to cache ioam header recvd
- *     in request and reattach in response to provide round
- *     trip path visibility. Since request response matching
- *     is needed works with TCP and relies on (5 tuples,seq no)
- * 2 - On M-Anycast server node: This node replicates requests
- *    towards multiple anycast service nodes serving anycast
- *    IP6 address. It evaluates response and forwards the best
- *    response towards the client of requesting the service.
- *    Again since request-response matching is needed, works
- *    with TCP  and relies on (5 tuples,seq no) for matching.
- *    To do this it caches SYN-ACK responses for a short time to
- *    evaluate multiple responses received before the selected
- *    SYN-ACK response is forwared and others dropped.
- *
- * M-Anycast server cache:
- *   - There is a pool of cache entries per worker thread.
- *   - Cache entry is created when SYN is received expected
- *     number of responses are marked based on number of
- *     SR tunnels for the anycast destination address
- *   - The pool/thread id and pool index are attached in the
- *    message as an ioam option for quick look up.
- *   - When is received SYN-ACK the ioam option containing
- *     thread id + pool index of the cache entry is used to
- *     look up cache entry.
- *   - Cache synchronization:
- *      - This is achieved by cache entry add/del/update all handled
- *        by the same worker/main thread
- *      - Packets from client to threads - syn packets, can be disctributed
- *        based on incoming interface affinity to the cpu core pinned to
- *        the thread or a simple sequence number based distribution
- *        if thread per interface is not scaling
- *      - Response packets from server towards clients - syn-acks, are
- *        forced to the same thread that created the cache entry
- *        using SR and the destination of SR v6 address assigned
- *        to the core/thread. This adderss is sent as an ioam option
- *        in the syn that can be then used on the other side to
- *        populate v6 dst address in the response
- *      - Timeout: timer wheel per thread is used to track the syn-ack wait
- *        time. The timer wheel tick is updated via an input node per thread.
- *
- * Application facing node/Service side cache:
- *  - Single pool of cache entries.
- *  - Cache entry is created when SYN is received. Caches the ioam
- *    header. Hash table entry is created based on 5 tuple and
- *    TCP seq no to pool index
- *  - Response SYN-ACK processed by looking up pool index in hash table
- *    and cache entry in the pool is used to get the ioam header rewrite
- *    string. Entry is freed from pool and hash table after use.
- *  - Locking/Synchronization: Currently this functionality is deployed
- *    with main/single thread only. Hence no locking is used.
- *  - Deployment: A VPP node per application server servicing anycast
- *    address is expected. Locking/synchronization needed when the server
- *    /application facing node is started with multiple worker threads.
- *
- */
-
-/*
- * Application facing server side caching:
- * Cache entry for ioam header
- * Currently caters to TCP and relies on
- * TCP - 5 tuples + seqno to cache and reinsert
- * ioam header b/n TCP request response
- */
-typedef struct
-{
-  /** Required for pool_get_aligned */
-  CLIB_CACHE_LINE_ALIGN_MARK (cacheline0);
-  ip6_address_t src_address;
-  ip6_address_t dst_address;
-  u16 src_port;
-  u16 dst_port;
-  u8 protocol;
-  u32 seq_no;
-  ip6_address_t next_hop;
-  u16 my_address_offset;
-  u8 *ioam_rewrite_string;
-} ioam_cache_entry_t;
-
-/*
- * Cache entry for anycast server selection
- * Works for TCP as 5 tuple + sequence number
- * is required for request response matching
- * max_responses expected is set based on number
- *              of SR tunnels for the dst_address
- * Timeout or all response_received = max_responses
- *            will clear the entry
- * buffer_index index of the response msg vlib buffer
- *           that is currently the best response
- */
-typedef struct
-{
-  /** Required for pool_get_aligned */
-  CLIB_CACHE_LINE_ALIGN_MARK (cacheline0);
-  u32 pool_id;
-  u32 pool_index;
-  ip6_address_t src_address;
-  ip6_address_t dst_address;
-  u16 src_port;
-  u16 dst_port;
-  u8 protocol;
-  u32 seq_no;
-  u32 buffer_index;
-  ip6_hop_by_hop_header_t *hbh;	//pointer to hbh header in the buffer
-  u64 created_at;
-  u8 response_received;
-  u8 max_responses;
-  u32 stop_timer_handle;
-  /** Handle returned from tw_start_timer */
-  u32 timer_handle;
-  /** entry should expire at this clock tick */
-  u32 expected_to_expire;
-} ioam_cache_ts_entry_t;
-
-/*
- * Per thread tunnel selection cache stats
- */
-typedef struct
-{
-  u64 inuse;
-  u64 add_failed;
-} ioam_cache_ts_pool_stats_t;
-
-/* Server side: iOAM header caching */
-#define MAX_CACHE_ENTRIES 4096
-/* M-Anycast: Cache for SR tunnel selection */
-#define MAX_CACHE_TS_ENTRIES 1048576
-
-#define IOAM_CACHE_TABLE_DEFAULT_HASH_NUM_BUCKETS (4 * 1024)
-#define IOAM_CACHE_TABLE_DEFAULT_HASH_MEMORY_SIZE (2<<20)
-
-typedef struct
-{
-  /* API message ID base */
-  u16 msg_id_base;
-
-  /* Pool of ioam_cache_buffer_t */
-  ioam_cache_entry_t *ioam_rewrite_pool;
-
-  /* For steering packets ioam cache entry is followed by
-   * SR header. This is the SR rewrite template */
-  u8 *sr_rewrite_template;
-  /* The current rewrite string being used */
-  u8 *rewrite;
-  u8 rewrite_pool_index_offset;
-  ip6_address_t sr_localsid_cache;
-
-  u64 lookup_table_nbuckets;
-  u64 lookup_table_size;
-  clib_bihash_8_8_t ioam_rewrite_cache_table;
-
-  /* M-Anycast: Pool of ioam_cache_ts_entry_t per thread */
-  ioam_cache_ts_entry_t **ioam_ts_pool;
-  ioam_cache_ts_pool_stats_t *ts_stats;
-  /** per thread single-wheel */
-  tw_timer_wheel_16t_2w_512sl_t *timer_wheels;
-
-  /*
-   * Selection criteria: oneway delay: Server to M-Anycast
-   * or RTT
-   */
-  bool criteria_oneway;
-  u8 wait_for_responses;
-  ip6_address_t sr_localsid_ts;
-
-  /* convenience */
-  vlib_main_t *vlib_main;
-
-  uword cache_hbh_slot;
-  uword ts_hbh_slot;
-  u32 ip6_hbh_pop_node_index;
-  u32 error_node_index;
-  u32 cleanup_process_node_index;
-
-  u32 ip6_add_from_cache_hbh_node_index;
-  u32 ip6_reset_ts_hbh_node_index;
-} ioam_cache_main_t;
-
-extern ioam_cache_main_t ioam_cache_main;
-
-extern vlib_node_registration_t ioam_cache_node;
-extern vlib_node_registration_t ioam_cache_ts_node;
-
-/*  Compute flow hash.  We'll use it to select which Sponge to use for this
- *  flow.  And other things.
- *  ip6_compute_flow_hash in ip6.h doesnt locate tcp/udp when
- *  ext headers are present. While it could be made to it will be a
- *  performance hit for ECMP flows.
- *  HEnce this function here, with L4 information directly input
- *  Useful when tcp/udp headers are already located in presence of
- *  ext headers
- */
-always_inline u32
-ip6_compute_flow_hash_ext (const ip6_header_t * ip,
-			   u8 protocol,
-			   u16 src_port,
-			   u16 dst_port, flow_hash_config_t flow_hash_config)
-{
-  u64 a, b, c;
-  u64 t1, t2;
-
-  t1 = (ip->src_address.as_u64[0] ^ ip->src_address.as_u64[1]);
-  t1 = (flow_hash_config & IP_FLOW_HASH_SRC_ADDR) ? t1 : 0;
-
-  t2 = (ip->dst_address.as_u64[0] ^ ip->dst_address.as_u64[1]);
-  t2 = (flow_hash_config & IP_FLOW_HASH_DST_ADDR) ? t2 : 0;
-
-  a = (flow_hash_config & IP_FLOW_HASH_REVERSE_SRC_DST) ? t2 : t1;
-  b = (flow_hash_config & IP_FLOW_HASH_REVERSE_SRC_DST) ? t1 : t2;
-  b ^= (flow_hash_config & IP_FLOW_HASH_PROTO) ? protocol : 0;
-
-  t1 = src_port;
-  t2 = dst_port;
-
-  t1 = (flow_hash_config & IP_FLOW_HASH_SRC_PORT) ? t1 : 0;
-  t2 = (flow_hash_config & IP_FLOW_HASH_DST_PORT) ? t2 : 0;
-
-  c = (flow_hash_config & IP_FLOW_HASH_REVERSE_SRC_DST) ?
-    ((t1 << 16) | t2) : ((t2 << 16) | t1);
-
-  hash_mix64 (a, b, c);
-  return (u32) c;
-}
-
-
-/* 2 new ioam E2E options :
- * 1. HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE_ID: IP6 address
- *                of ioam node that inserted ioam header
- * 2. HBH_OPTION_TYPE_IOAM_E2E_CACHE_ID: Pool id and index
- *                   to look up tunnel select cache entry
- */
-#define HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE_ID 30
-#define HBH_OPTION_TYPE_IOAM_E2E_CACHE_ID 31
-
-typedef CLIB_PACKED (struct
-		     {
-		     ip6_hop_by_hop_option_t hdr; u8 e2e_type; u8 reserved[5];
-		     ip6_address_t id;
-		     }) ioam_e2e_id_option_t;
-
-typedef CLIB_PACKED (struct
-		     {
-		     ip6_hop_by_hop_option_t hdr; u8 e2e_type; u8 pool_id;
-		     u32 pool_index;
-		     }) ioam_e2e_cache_option_t;
-
-#define IOAM_E2E_ID_OPTION_RND ((sizeof(ioam_e2e_id_option_t) + 7) & ~7)
-#define IOAM_E2E_ID_HBH_EXT_LEN (IOAM_E2E_ID_OPTION_RND >> 3)
-#define IOAM_E2E_CACHE_OPTION_RND ((sizeof(ioam_e2e_cache_option_t) + 7) & ~7)
-#define IOAM_E2E_CACHE_HBH_EXT_LEN (IOAM_E2E_CACHE_OPTION_RND >> 3)
-
-static inline void
-ioam_e2e_id_rewrite_handler (ioam_e2e_id_option_t * e2e_option,
-			     ip6_address_t * address)
-{
-  e2e_option->id.as_u64[0] = address->as_u64[0];
-  e2e_option->id.as_u64[1] = address->as_u64[1];
-
-}
-
-/* Following functions are for the caching of ioam header
- * to enable reattaching it for a complete request-response
- * message exchange */
-inline static void
-ioam_cache_entry_free (ioam_cache_entry_t * entry)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  if (entry)
-    {
-      vec_free (entry->ioam_rewrite_string);
-      clib_memset (entry, 0, sizeof (*entry));
-      pool_put (cm->ioam_rewrite_pool, entry);
-    }
-}
-
-inline static ioam_cache_entry_t *
-ioam_cache_entry_cleanup (u32 pool_index)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ioam_cache_entry_t *entry = 0;
-
-  entry = pool_elt_at_index (cm->ioam_rewrite_pool, pool_index);
-  ioam_cache_entry_free (entry);
-  return (0);
-}
-
-inline static ioam_cache_entry_t *
-ioam_cache_lookup (ip6_header_t * ip0, u16 src_port, u16 dst_port, u32 seq_no)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  u32 flow_hash = ip6_compute_flow_hash_ext (ip0, ip0->protocol,
-					     src_port, dst_port,
-					     IP_FLOW_HASH_DEFAULT |
-					     IP_FLOW_HASH_REVERSE_SRC_DST);
-  clib_bihash_kv_8_8_t kv, value;
-
-  kv.key = (u64) flow_hash << 32 | seq_no;
-  kv.value = 0;
-  value.key = 0;
-  value.value = 0;
-
-  if (clib_bihash_search_8_8 (&cm->ioam_rewrite_cache_table, &kv, &value) >=
-      0)
-    {
-      ioam_cache_entry_t *entry = 0;
-
-      entry = pool_elt_at_index (cm->ioam_rewrite_pool, value.value);
-      /* match */
-      if (ip6_address_compare (&ip0->src_address, &entry->dst_address) == 0 &&
-	  ip6_address_compare (&ip0->dst_address, &entry->src_address) == 0 &&
-	  entry->src_port == dst_port &&
-	  entry->dst_port == src_port && entry->seq_no == seq_no)
-	{
-	  /* If lookup is successful remove it from the hash */
-	  clib_bihash_add_del_8_8 (&cm->ioam_rewrite_cache_table, &kv, 0);
-	  return (entry);
-	}
-      else
-	return (0);
-
-    }
-  return (0);
-}
-
-/*
- * Caches ioam hbh header
- * Extends the hbh header with option to contain IP6 address of the node
- * that caches it
- */
-inline static int
-ioam_cache_add (vlib_buffer_t * b0,
-		ip6_header_t * ip0,
-		u16 src_port,
-		u16 dst_port, ip6_hop_by_hop_header_t * hbh0, u32 seq_no)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ioam_cache_entry_t *entry = 0;
-  u32 rewrite_len = 0, e2e_id_offset = 0;
-  u32 pool_index = 0;
-  ioam_e2e_id_option_t *e2e = 0;
-
-  pool_get_aligned (cm->ioam_rewrite_pool, entry, CLIB_CACHE_LINE_BYTES);
-  clib_memset (entry, 0, sizeof (*entry));
-  pool_index = entry - cm->ioam_rewrite_pool;
-
-  clib_memcpy_fast (entry->dst_address.as_u64, ip0->dst_address.as_u64,
-		    sizeof (ip6_address_t));
-  clib_memcpy_fast (entry->src_address.as_u64, ip0->src_address.as_u64,
-		    sizeof (ip6_address_t));
-  entry->src_port = src_port;
-  entry->dst_port = dst_port;
-  entry->seq_no = seq_no;
-  rewrite_len = ((hbh0->length + 1) << 3);
-  vec_validate (entry->ioam_rewrite_string, rewrite_len - 1);
-  e2e = ip6_ioam_find_hbh_option (hbh0, HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE_ID);
-  if (e2e)
-    {
-      entry->next_hop.as_u64[0] = e2e->id.as_u64[0];
-      entry->next_hop.as_u64[1] = e2e->id.as_u64[1];
-    }
-  else
-    {
-      return (-1);
-    }
-  e2e_id_offset = (u8 *) e2e - (u8 *) hbh0;
-  /* setup e2e id option to insert v6 address of the node caching it */
-  clib_memcpy_fast (entry->ioam_rewrite_string, hbh0, rewrite_len);
-  hbh0 = (ip6_hop_by_hop_header_t *) entry->ioam_rewrite_string;
-
-  /* suffix rewrite string with e2e ID option */
-  e2e = (ioam_e2e_id_option_t *) (entry->ioam_rewrite_string + e2e_id_offset);
-  ioam_e2e_id_rewrite_handler (e2e, &cm->sr_localsid_cache);
-  entry->my_address_offset = (u8 *) (&e2e->id) - (u8 *) hbh0;
-
-  /* add it to hash, replacing and freeing any collision for now */
-  u32 flow_hash =
-    ip6_compute_flow_hash_ext (ip0, hbh0->protocol, src_port, dst_port,
-			       IP_FLOW_HASH_DEFAULT);
-  clib_bihash_kv_8_8_t kv, value;
-  kv.key = (u64) flow_hash << 32 | seq_no;
-  kv.value = 0;
-  if (clib_bihash_search_8_8 (&cm->ioam_rewrite_cache_table, &kv, &value) >=
-      0)
-    {
-      /* replace */
-      ioam_cache_entry_cleanup (value.value);
-    }
-  kv.value = pool_index;
-  clib_bihash_add_del_8_8 (&cm->ioam_rewrite_cache_table, &kv, 1);
-  return (0);
-}
-
-/* Creates SR rewrite string
- * This is appended with ioam header on the server facing
- * node.
- * This SR header is necessary to attract packets towards
- * selected Anycast server.
- */
-inline static void
-ioam_cache_sr_rewrite_template_create (void)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ip6_address_t *segments = 0;
-  ip6_address_t *this_seg = 0;
-
-  /* This nodes address and the original dest will be
-   * filled when the packet is processed */
-  vec_add2 (segments, this_seg, 1);
-  clib_memset (this_seg, 0xfe, sizeof (ip6_address_t));
-  cm->sr_rewrite_template = ip6_sr_compute_rewrite_string_insert (segments);
-  vec_free (segments);
-}
-
-inline static int
-ioam_cache_table_init (vlib_main_t * vm)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-
-  pool_alloc_aligned (cm->ioam_rewrite_pool,
-		      MAX_CACHE_ENTRIES, CLIB_CACHE_LINE_BYTES);
-  cm->lookup_table_nbuckets = IOAM_CACHE_TABLE_DEFAULT_HASH_NUM_BUCKETS;
-  cm->lookup_table_nbuckets = 1 << max_log2 (cm->lookup_table_nbuckets);
-  cm->lookup_table_size = IOAM_CACHE_TABLE_DEFAULT_HASH_MEMORY_SIZE;
-
-  clib_bihash_init_8_8 (&cm->ioam_rewrite_cache_table,
-			"ioam rewrite cache table",
-			cm->lookup_table_nbuckets, cm->lookup_table_size);
-  /* Create SR rewrite template */
-  ioam_cache_sr_rewrite_template_create ();
-  return (1);
-}
-
-inline static int
-ioam_cache_table_destroy (vlib_main_t * vm)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ioam_cache_entry_t *entry = 0;
-  /* free pool and hash table */
-  clib_bihash_free_8_8 (&cm->ioam_rewrite_cache_table);
-  pool_foreach (entry, cm->ioam_rewrite_pool)
-  {
-    ioam_cache_entry_free (entry);
-  }
-  pool_free (cm->ioam_rewrite_pool);
-  cm->ioam_rewrite_pool = 0;
-  vec_free (cm->sr_rewrite_template);
-  cm->sr_rewrite_template = 0;
-  return (0);
-}
-
-inline static u8 *
-format_ioam_cache_entry (u8 * s, va_list * args)
-{
-  ioam_cache_entry_t *e = va_arg (*args, ioam_cache_entry_t *);
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  int rewrite_len = vec_len (e->ioam_rewrite_string);
-
-  s = format (s, "%d: %U:%d to  %U:%d seq_no %lu\n",
-	      (e - cm->ioam_rewrite_pool),
-	      format_ip6_address, &e->src_address,
-	      e->src_port,
-	      format_ip6_address, &e->dst_address, e->dst_port, e->seq_no);
-
-  if (rewrite_len)
-    {
-      s = format (s, "  %U",
-		  format_ip6_hop_by_hop_ext_hdr,
-		  (ip6_hop_by_hop_header_t *) e->ioam_rewrite_string,
-		  rewrite_len - 1);
-    }
-  return s;
-}
-
-void ioam_cache_ts_timer_node_enable (vlib_main_t * vm, u8 enable);
-
-#define IOAM_CACHE_TS_TIMEOUT 1.0	//SYN timeout 1 sec
-#define IOAM_CACHE_TS_TICK 100e-3
-/* Timer delays as multiples of 100ms */
-#define IOAM_CACHE_TS_TIMEOUT_TICKS IOAM_CACHE_TS_TICK*9
-#define TIMER_HANDLE_INVALID ((u32) ~0)
-
-
-void expired_cache_ts_timer_callback (u32 * expired_timers);
-
-/*
- * Following functions are to manage M-Anycast server selection
- * cache
- * There is a per worker thread pool to create a cache entry
- * for a TCP SYN received. TCP SYN-ACK contians ioam header
- * with HBH_OPTION_TYPE_IOAM_E2E_CACHE_ID option to point to the
- * entry.
- */
-inline static int
-ioam_cache_ts_table_init (vlib_main_t * vm)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  int no_of_threads = vec_len (vlib_worker_threads);
-  int i;
-
-  vec_validate_aligned (cm->ioam_ts_pool, no_of_threads - 1,
-			CLIB_CACHE_LINE_BYTES);
-  vec_validate_aligned (cm->ts_stats, no_of_threads - 1,
-			CLIB_CACHE_LINE_BYTES);
-  vec_validate (cm->timer_wheels, no_of_threads - 1);
-  cm->lookup_table_nbuckets = IOAM_CACHE_TABLE_DEFAULT_HASH_NUM_BUCKETS;
-  cm->lookup_table_nbuckets = 1 << max_log2 (cm->lookup_table_nbuckets);
-  cm->lookup_table_size = IOAM_CACHE_TABLE_DEFAULT_HASH_MEMORY_SIZE;
-  for (i = 0; i < no_of_threads; i++)
-    {
-      pool_alloc_aligned (cm->ioam_ts_pool[i],
-			  MAX_CACHE_TS_ENTRIES, CLIB_CACHE_LINE_BYTES);
-      clib_memset (&cm->ts_stats[i], 0, sizeof (ioam_cache_ts_pool_stats_t));
-      tw_timer_wheel_init_16t_2w_512sl (&cm->timer_wheels[i],
-					expired_cache_ts_timer_callback,
-					IOAM_CACHE_TS_TICK
-					/* timer period 100ms */ ,
-					10e4);
-      cm->timer_wheels[i].last_run_time = vlib_time_now (vm);
-    }
-  ioam_cache_ts_timer_node_enable (vm, 1);
-  return (1);
-}
-
-always_inline void
-ioam_cache_ts_timer_set (ioam_cache_main_t * cm,
-			 ioam_cache_ts_entry_t * entry, u32 interval)
-{
-  entry->timer_handle
-    = tw_timer_start_16t_2w_512sl (&cm->timer_wheels[entry->pool_id],
-				   entry->pool_index, 1, interval);
-}
-
-always_inline void
-ioam_cache_ts_timer_reset (ioam_cache_main_t * cm,
-			   ioam_cache_ts_entry_t * entry)
-{
-  tw_timer_stop_16t_2w_512sl (&cm->timer_wheels[entry->pool_id],
-			      entry->timer_handle);
-  entry->timer_handle = TIMER_HANDLE_INVALID;
-}
-
-inline static void
-ioam_cache_ts_entry_free (u32 thread_id,
-			  ioam_cache_ts_entry_t * entry, u32 node_index)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  vlib_main_t *vm = cm->vlib_main;
-  vlib_frame_t *nf = 0;
-  u32 *to_next;
-
-  if (entry)
-    {
-      if (entry->hbh != 0)
-	{
-	  nf = vlib_get_frame_to_node (vm, node_index);
-	  nf->n_vectors = 0;
-	  to_next = vlib_frame_vector_args (nf);
-	  nf->n_vectors = 1;
-	  to_next[0] = entry->buffer_index;
-	  vlib_put_frame_to_node (vm, node_index, nf);
-	}
-      pool_put (cm->ioam_ts_pool[thread_id], entry);
-      cm->ts_stats[thread_id].inuse--;
-      clib_memset (entry, 0, sizeof (*entry));
-    }
-}
-
-inline static int
-ioam_cache_ts_table_destroy (vlib_main_t * vm)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ioam_cache_ts_entry_t *entry = 0;
-  int no_of_threads = vec_len (vlib_worker_threads);
-  int i;
-
-  /* free pool and hash table */
-  if (cm->ioam_ts_pool)
-    {
-      for (i = 0; i < no_of_threads; i++)
-	{
-	  pool_foreach (entry, cm->ioam_ts_pool[i])
-	    {
-	      ioam_cache_ts_entry_free (i, entry, cm->error_node_index);
-	    }
-	  pool_free (cm->ioam_ts_pool[i]);
-	  cm->ioam_ts_pool[i] = 0;
-	  tw_timer_wheel_free_16t_2w_512sl (&cm->timer_wheels[i]);
-	}
-      vec_free (cm->ioam_ts_pool);
-    }
-  return (0);
-}
-
-inline static int
-ioam_cache_ts_entry_cleanup (u32 thread_id, u32 pool_index)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ioam_cache_ts_entry_t *entry = 0;
-
-  entry = pool_elt_at_index (cm->ioam_ts_pool[thread_id], pool_index);
-  ioam_cache_ts_entry_free (thread_id, entry, cm->error_node_index);
-  return (0);
-}
-
-/*
- * Caches buffer for ioam SR tunnel select for Anycast service
- */
-inline static int
-ioam_cache_ts_add (ip6_header_t * ip0,
-		   u16 src_port,
-		   u16 dst_port,
-		   u32 seq_no,
-		   u8 max_responses, u64 now, u32 thread_id, u32 * pool_index)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ioam_cache_ts_entry_t *entry = 0;
-
-  if (cm->ts_stats[thread_id].inuse == MAX_CACHE_TS_ENTRIES)
-    {
-      cm->ts_stats[thread_id].add_failed++;
-      return (-1);
-    }
-
-  pool_get_aligned (cm->ioam_ts_pool[thread_id], entry,
-		    CLIB_CACHE_LINE_BYTES);
-  clib_memset (entry, 0, sizeof (*entry));
-  *pool_index = entry - cm->ioam_ts_pool[thread_id];
-
-  clib_memcpy_fast (entry->dst_address.as_u64, ip0->dst_address.as_u64,
-		    sizeof (ip6_address_t));
-  clib_memcpy_fast (entry->src_address.as_u64, ip0->src_address.as_u64,
-		    sizeof (ip6_address_t));
-  entry->src_port = src_port;
-  entry->dst_port = dst_port;
-  entry->seq_no = seq_no;
-  entry->response_received = 0;
-  entry->max_responses = max_responses;
-  entry->created_at = now;
-  entry->hbh = 0;
-  entry->buffer_index = 0;
-  entry->pool_id = thread_id;
-  entry->pool_index = *pool_index;
-  ioam_cache_ts_timer_set (cm, entry, IOAM_CACHE_TS_TIMEOUT);
-  cm->ts_stats[thread_id].inuse++;
-  return (0);
-}
-
-inline static void
-ioam_cache_ts_send (u32 thread_id, i32 pool_index)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ioam_cache_ts_entry_t *entry = 0;
-
-  entry = pool_elt_at_index (cm->ioam_ts_pool[thread_id], pool_index);
-  if (!pool_is_free (cm->ioam_ts_pool[thread_id], entry) && entry)
-    {
-      /* send and free pool entry */
-      ioam_cache_ts_entry_free (thread_id, entry, cm->ip6_hbh_pop_node_index);
-    }
-}
-
-inline static void
-ioam_cache_ts_check_and_send (u32 thread_id, i32 pool_index)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ioam_cache_ts_entry_t *entry = 0;
-  entry = pool_elt_at_index (cm->ioam_ts_pool[thread_id], pool_index);
-  if (entry && entry->hbh)
-    {
-      if (entry->response_received == entry->max_responses ||
-	  entry->created_at + IOAM_CACHE_TS_TIMEOUT <=
-	  vlib_time_now (cm->vlib_main))
-	{
-	  ioam_cache_ts_timer_reset (cm, entry);
-	  ioam_cache_ts_send (thread_id, pool_index);
-	}
-    }
-}
-
-inline static int
-ioam_cache_ts_update (u32 thread_id,
-		      i32 pool_index,
-		      u32 buffer_index, ip6_hop_by_hop_header_t * hbh)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ioam_cache_ts_entry_t *entry = 0;
-  vlib_main_t *vm = cm->vlib_main;
-  vlib_frame_t *nf = 0;
-  u32 *to_next;
-
-  entry = pool_elt_at_index (cm->ioam_ts_pool[thread_id], pool_index);
-  if (!pool_is_free (cm->ioam_ts_pool[thread_id], entry) && entry)
-    {
-      /* drop existing buffer */
-      if (entry->hbh != 0)
-	{
-	  nf = vlib_get_frame_to_node (vm, cm->error_node_index);
-	  nf->n_vectors = 0;
-	  to_next = vlib_frame_vector_args (nf);
-	  nf->n_vectors = 1;
-	  to_next[0] = entry->buffer_index;
-	  vlib_put_frame_to_node (vm, cm->error_node_index, nf);
-	}
-      /* update */
-      entry->buffer_index = buffer_index;
-      entry->hbh = hbh;
-      /* check and send */
-      ioam_cache_ts_check_and_send (thread_id, pool_index);
-      return (0);
-    }
-  return (-1);
-}
-
-/*
- * looks up the entry based on the e2e option pool index
- * result = 0 found the entry
- * result < 0 indicates failture to find an entry
- */
-inline static int
-ioam_cache_ts_lookup (ip6_header_t * ip0,
-		      u8 protocol,
-		      u16 src_port,
-		      u16 dst_port,
-		      u32 seq_no,
-		      ip6_hop_by_hop_header_t ** hbh,
-		      u32 * pool_index, u8 * thread_id, u8 response_seen)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ip6_hop_by_hop_header_t *hbh0 = 0;
-  ioam_e2e_cache_option_t *e2e = 0;
-
-  hbh0 = (ip6_hop_by_hop_header_t *) (ip0 + 1);
-  e2e =
-    (ioam_e2e_cache_option_t *) ((u8 *) hbh0 + cm->rewrite_pool_index_offset);
-  if ((u8 *) e2e < ((u8 *) hbh0 + ((hbh0->length + 1) << 3))
-      && e2e->hdr.type == HBH_OPTION_TYPE_IOAM_E2E_CACHE_ID)
-    {
-      ioam_cache_ts_entry_t *entry = 0;
-      *pool_index = e2e->pool_index;
-      *thread_id = e2e->pool_id;
-      entry = pool_elt_at_index (cm->ioam_ts_pool[*thread_id], *pool_index);
-      /* match */
-      if (entry &&
-	  ip6_address_compare (&ip0->src_address, &entry->dst_address) == 0 &&
-	  ip6_address_compare (&ip0->dst_address, &entry->src_address) == 0 &&
-	  entry->src_port == dst_port &&
-	  entry->dst_port == src_port && entry->seq_no == seq_no)
-	{
-	  *hbh = entry->hbh;
-	  entry->response_received += response_seen;
-	  return (0);
-	}
-      else if (entry)
-	{
-	  return (-1);
-	}
-    }
-  return (-1);
-}
-
-inline static u8 *
-format_ioam_cache_ts_entry (u8 * s, va_list * args)
-{
-  ioam_cache_ts_entry_t *e = va_arg (*args, ioam_cache_ts_entry_t *);
-  u32 thread_id = va_arg (*args, u32);
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ioam_e2e_id_option_t *e2e = 0;
-  vlib_main_t *vm = cm->vlib_main;
-  clib_time_t *ct = &vm->clib_time;
-
-  if (!e)
-    goto end;
-
-  if (e->hbh)
-    {
-      e2e =
-	ip6_ioam_find_hbh_option (e->hbh,
-				  HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE_ID);
-
-      s =
-	format (s,
-		"%d: %U:%d to  %U:%d seq_no %u buffer %u %U \n\t\tCreated at %U Received %d\n",
-		(e - cm->ioam_ts_pool[thread_id]), format_ip6_address,
-		&e->src_address, e->src_port, format_ip6_address,
-		&e->dst_address, e->dst_port, e->seq_no, e->buffer_index,
-		format_ip6_address, e2e ? &e2e->id : 0, format_time_interval,
-		"h:m:s:u",
-		(e->created_at -
-		 vm->cpu_time_main_loop_start) * ct->seconds_per_clock,
-		e->response_received);
-    }
-  else
-    {
-      s =
-	format (s,
-		"%d: %U:%d to  %U:%d seq_no %u Buffer %u \n\t\tCreated at %U Received %d\n",
-		(e - cm->ioam_ts_pool[thread_id]), format_ip6_address,
-		&e->src_address, e->src_port, format_ip6_address,
-		&e->dst_address, e->dst_port, e->seq_no, e->buffer_index,
-		format_time_interval, "h:m:s:u",
-		(e->created_at -
-		 vm->cpu_time_main_loop_start) * ct->seconds_per_clock,
-		e->response_received);
-    }
-
-end:
-  return s;
-}
-
-/*
- * Get extended rewrite string for iOAM data in v6
- * This makes space for an e2e options to carry cache pool info
- * and manycast server address.
- * It set the rewrite string per configs in ioam ip6 + new option
- * for cache along with offset to the option to populate cache
- * pool id and index
- */
-static inline int
-ip6_ioam_ts_cache_set_rewrite (void)
-{
-  ip6_hop_by_hop_ioam_main_t *hm = &ip6_hop_by_hop_ioam_main;
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  ip6_hop_by_hop_header_t *hbh;
-  u32 rewrite_len = 0;
-  ioam_e2e_cache_option_t *e2e = 0;
-  ioam_e2e_id_option_t *e2e_id = 0;
-
-  vec_free (cm->rewrite);
-  ip6_ioam_set_rewrite (&(cm->rewrite), hm->has_trace_option,
-			hm->has_pot_option, hm->has_seqno_option);
-  hbh = (ip6_hop_by_hop_header_t *) cm->rewrite;
-  rewrite_len = ((hbh->length + 1) << 3);
-  vec_validate (cm->rewrite,
-		rewrite_len - 1 + IOAM_E2E_CACHE_OPTION_RND +
-		IOAM_E2E_ID_OPTION_RND);
-  hbh = (ip6_hop_by_hop_header_t *) cm->rewrite;
-  /* setup e2e id option to insert pool id and index of the node caching it */
-  hbh->length += IOAM_E2E_CACHE_HBH_EXT_LEN + IOAM_E2E_ID_HBH_EXT_LEN;
-  cm->rewrite_pool_index_offset = rewrite_len;
-  e2e = (ioam_e2e_cache_option_t *) (cm->rewrite + rewrite_len);
-  e2e->hdr.type = HBH_OPTION_TYPE_IOAM_E2E_CACHE_ID
-    | HBH_OPTION_TYPE_SKIP_UNKNOWN;
-  e2e->hdr.length = sizeof (ioam_e2e_cache_option_t) -
-    sizeof (ip6_hop_by_hop_option_t);
-  e2e->e2e_type = 2;
-  e2e_id =
-    (ioam_e2e_id_option_t *) ((u8 *) e2e + sizeof (ioam_e2e_cache_option_t));
-  e2e_id->hdr.type =
-    HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE_ID | HBH_OPTION_TYPE_SKIP_UNKNOWN;
-  e2e_id->hdr.length =
-    sizeof (ioam_e2e_id_option_t) - sizeof (ip6_hop_by_hop_option_t);
-  e2e_id->e2e_type = 1;
-
-  return (0);
-}
-
-static inline int
-ip6_ioam_ts_cache_cleanup_rewrite (void)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-
-  vec_free (cm->rewrite);
-  cm->rewrite = 0;
-  cm->rewrite_pool_index_offset = 0;
-  return (0);
-}
-#endif /* __included_ioam_cache_h__ */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/ip6/ioam_cache_node.c b/ioam/ip6/ioam_cache_node.c
deleted file mode 100644
index 6a5465b..0000000
--- a/ioam/ip6/ioam_cache_node.c
+++ /dev/null
@@ -1,415 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- * This file implements caching of ioam header and reattaching
- * it in response message by performing request-response matching.
- *  Works for TCP SYN/SYN-ACK.
- * This feature is used for anycast server selection.
- * ioam data thus cached is used to measure and get complete round trip
- * network path to help in server selection.
- * There are 2 graph nodes defined to :
- * 1. process packets that contain iOAM header and cache it
- * 2. process TCP SYN-ACKs and reattach ioam header from the
- *    cache corresponding to TCP-SYN
- * These graph nodes are attached to the vnet graph based on
- * ioam cache and classifier configs.
- * e.g.
- * If db06::06 is the anycast service IP6 address:
- *
- * set ioam ip6 cache
- *
- * Apply this classifier on interface where requests for anycast service are received:
- * classify session acl-hit-next ip6-node ip6-lookup table-index 0 match l3 ip6 dst db06::06
- *    ioam-decap anycast <<< ioam-decap is hooked to cache when set ioam ip6 cache is enabled
- *
- * Apply this classifier on interface where responses from anycast service are received:
- * classify session acl-hit-next ip6-node ip6-add-from-cache-hop-by-hop table-index 0 match l3
- *    ip6 src db06::06 ioam-encap anycast-response
- *
- */
-#include <vlib/vlib.h>
-#include <vnet/vnet.h>
-#include <vppinfra/error.h>
-#include <vnet/ip/ip.h>
-#include <ioam/ip6/ioam_cache.h>
-#include <vnet/ip/ip6_hop_by_hop.h>
-#include <vnet/ip/ip6_hop_by_hop_packet.h>
-#include <vnet/ip/ip6_inlines.h>
-
-typedef struct
-{
-  u32 next_index;
-  u32 flow_label;
-} cache_trace_t;
-
-/* packet trace format function */
-static u8 *
-format_cache_trace (u8 * s, va_list * args)
-{
-  CLIB_UNUSED (vlib_main_t * vm) = va_arg (*args, vlib_main_t *);
-  CLIB_UNUSED (vlib_node_t * node) = va_arg (*args, vlib_node_t *);
-  cache_trace_t *t = va_arg (*args, cache_trace_t *);
-
-  s = format (s, "CACHE: flow_label %d, next index %d",
-	      t->flow_label, t->next_index);
-  return s;
-}
-
-#define foreach_cache_error \
-_(RECORDED, "ip6 iOAM headers cached")
-
-typedef enum
-{
-#define _(sym,str) CACHE_ERROR_##sym,
-  foreach_cache_error
-#undef _
-    CACHE_N_ERROR,
-} cache_error_t;
-
-static char *cache_error_strings[] = {
-#define _(sym,string) string,
-  foreach_cache_error
-#undef _
-};
-
-typedef enum
-{
-  IOAM_CACHE_NEXT_POP_HBYH,
-  IOAM_CACHE_N_NEXT,
-} cache_next_t;
-
-static uword
-ip6_ioam_cache_node_fn (vlib_main_t * vm,
-			vlib_node_runtime_t * node, vlib_frame_t * frame)
-{
-  u32 n_left_from, *from, *to_next;
-  cache_next_t next_index;
-  u32 recorded = 0;
-
-  from = vlib_frame_vector_args (frame);
-  n_left_from = frame->n_vectors;
-  next_index = node->cached_next_index;
-
-  while (n_left_from > 0)
-    {
-      u32 n_left_to_next;
-
-      vlib_get_next_frame (vm, node, next_index, to_next, n_left_to_next);
-      // TODO: Dual loop
-      while (n_left_from > 0 && n_left_to_next > 0)
-	{
-	  u32 bi0;
-	  vlib_buffer_t *p0;
-	  u32 next0 = IOAM_CACHE_NEXT_POP_HBYH;
-	  ip6_header_t *ip0;
-	  ip6_hop_by_hop_header_t *hbh0;
-	  tcp_header_t *tcp0;
-	  u32 tcp_offset0;
-
-	  /* speculatively enqueue p0 to the current next frame */
-	  bi0 = from[0];
-	  to_next[0] = bi0;
-	  from += 1;
-	  to_next += 1;
-	  n_left_from -= 1;
-	  n_left_to_next -= 1;
-
-	  p0 = vlib_get_buffer (vm, bi0);
-	  ip0 = vlib_buffer_get_current (p0);
-	  if (IP_PROTOCOL_TCP ==
-	      ip6_locate_header (p0, ip0, IP_PROTOCOL_TCP, &tcp_offset0))
-	    {
-	      tcp0 = (tcp_header_t *) ((u8 *) ip0 + tcp_offset0);
-	      if ((tcp0->flags & TCP_FLAG_SYN) == TCP_FLAG_SYN &&
-		  (tcp0->flags & TCP_FLAG_ACK) == 0)
-		{
-		  /* Cache the ioam hbh header */
-		  hbh0 = (ip6_hop_by_hop_header_t *) (ip0 + 1);
-		  if (0 == ioam_cache_add (p0,
-					   ip0,
-					   clib_net_to_host_u16
-					   (tcp0->src_port),
-					   clib_net_to_host_u16
-					   (tcp0->dst_port), hbh0,
-					   clib_net_to_host_u32
-					   (tcp0->seq_number) + 1))
-		    {
-		      recorded++;
-		    }
-		}
-	    }
-	  if (PREDICT_FALSE ((node->flags & VLIB_NODE_FLAG_TRACE)))
-	    {
-	      if (p0->flags & VLIB_BUFFER_IS_TRACED)
-		{
-		  cache_trace_t *t =
-		    vlib_add_trace (vm, node, p0, sizeof (*t));
-		  t->flow_label =
-		    clib_net_to_host_u32
-		    (ip0->ip_version_traffic_class_and_flow_label);
-		  t->next_index = next0;
-		}
-	    }
-	  /* verify speculative enqueue, maybe switch current next frame */
-	  vlib_validate_buffer_enqueue_x1 (vm, node, next_index,
-					   to_next, n_left_to_next,
-					   bi0, next0);
-	}
-
-      vlib_put_next_frame (vm, node, next_index, n_left_to_next);
-    }
-
-  vlib_node_increment_counter (vm, ioam_cache_node.index,
-			       CACHE_ERROR_RECORDED, recorded);
-  return frame->n_vectors;
-}
-
-/*
- * Node for IP6 iOAM header cache
- */
-/* *INDENT-OFF* */
-VLIB_REGISTER_NODE (ioam_cache_node) =
-{
-  .function = ip6_ioam_cache_node_fn,
-  .name = "ip6-ioam-cache",
-  .vector_size = sizeof (u32),
-  .format_trace = format_cache_trace,
-  .type = VLIB_NODE_TYPE_INTERNAL,
-  .n_errors = ARRAY_LEN (cache_error_strings),
-  .error_strings = cache_error_strings,
-  .n_next_nodes = IOAM_CACHE_N_NEXT,
-  /* edit / add dispositions here */
-  .next_nodes =
-  {
-    [IOAM_CACHE_NEXT_POP_HBYH] = "ip6-pop-hop-by-hop"
-  },
-};
-/* *INDENT-ON* */
-
-typedef struct
-{
-  u32 next_index;
-} ip6_add_from_cache_hbh_trace_t;
-
-/* packet trace format function */
-static u8 *
-format_ip6_add_from_cache_hbh_trace (u8 * s, va_list * args)
-{
-  CLIB_UNUSED (vlib_main_t * vm) = va_arg (*args, vlib_main_t *);
-  CLIB_UNUSED (vlib_node_t * node) = va_arg (*args, vlib_node_t *);
-  ip6_add_from_cache_hbh_trace_t *t = va_arg (*args,
-					      ip6_add_from_cache_hbh_trace_t
-					      *);
-
-  s = format (s, "IP6_ADD_FROM_CACHE_HBH: next index %d", t->next_index);
-  return s;
-}
-
-#define foreach_ip6_add_from_cache_hbh_error \
-_(PROCESSED, "Pkts w/ added ip6 hop-by-hop options")
-
-typedef enum
-{
-#define _(sym,str) IP6_ADD_FROM_CACHE_HBH_ERROR_##sym,
-  foreach_ip6_add_from_cache_hbh_error
-#undef _
-    IP6_ADD_FROM_CACHE_HBH_N_ERROR,
-} ip6_add_from_cache_hbh_error_t;
-
-static char *ip6_add_from_cache_hbh_error_strings[] = {
-#define _(sym,string) string,
-  foreach_ip6_add_from_cache_hbh_error
-#undef _
-};
-
-#define foreach_ip6_ioam_cache_input_next        \
-  _(IP6_LOOKUP, "ip6-lookup")                   \
-  _(DROP, "error-drop")
-
-typedef enum
-{
-#define _(s,n) IP6_IOAM_CACHE_INPUT_NEXT_##s,
-  foreach_ip6_ioam_cache_input_next
-#undef _
-    IP6_IOAM_CACHE_INPUT_N_NEXT,
-} ip6_ioam_cache_input_next_t;
-
-
-VLIB_NODE_FN (ip6_add_from_cache_hbh_node) (vlib_main_t * vm,
-					    vlib_node_runtime_t * node,
-					    vlib_frame_t * frame)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  u32 n_left_from, *from, *to_next;
-  ip_lookup_next_t next_index;
-  u32 processed = 0;
-  u8 *rewrite = 0;
-  u32 rewrite_len = 0;
-  u32 sr_rewrite_len = vec_len (cm->sr_rewrite_template);
-
-  from = vlib_frame_vector_args (frame);
-  n_left_from = frame->n_vectors;
-  next_index = node->cached_next_index;
-
-  while (n_left_from > 0)
-    {
-      u32 n_left_to_next;
-
-      vlib_get_next_frame (vm, node, next_index, to_next, n_left_to_next);
-      // TODO: Dual loop
-      while (n_left_from > 0 && n_left_to_next > 0)
-	{
-	  u32 bi0;
-	  vlib_buffer_t *b0;
-	  u32 next0;
-	  ip6_header_t *ip0;
-	  ip6_hop_by_hop_header_t *hbh0;
-	  ip6_sr_header_t *srh0 = 0;
-	  u64 *copy_src0, *copy_dst0;
-	  u16 new_l0;
-	  tcp_header_t *tcp0;
-	  u32 tcp_offset0;
-	  ioam_cache_entry_t *entry = 0;
-
-	  next0 = IP6_IOAM_CACHE_INPUT_NEXT_IP6_LOOKUP;
-	  /* speculatively enqueue b0 to the current next frame */
-	  bi0 = from[0];
-	  to_next[0] = bi0;
-	  from += 1;
-	  to_next += 1;
-	  n_left_from -= 1;
-	  n_left_to_next -= 1;
-
-	  b0 = vlib_get_buffer (vm, bi0);
-
-	  ip0 = vlib_buffer_get_current (b0);
-	  if (IP_PROTOCOL_TCP !=
-	      ip6_locate_header (b0, ip0, IP_PROTOCOL_TCP, &tcp_offset0))
-	    {
-	      goto TRACE0;
-	    }
-	  tcp0 = (tcp_header_t *) ((u8 *) ip0 + tcp_offset0);
-	  if (((tcp0->flags & TCP_FLAG_SYN) == TCP_FLAG_SYN &&
-	       (tcp0->flags & TCP_FLAG_ACK) == TCP_FLAG_ACK) ||
-	      (tcp0->flags & TCP_FLAG_RST) == TCP_FLAG_RST)
-	    {
-	      if (0 != (entry = ioam_cache_lookup (ip0,
-						   clib_net_to_host_u16
-						   (tcp0->src_port),
-						   clib_net_to_host_u16
-						   (tcp0->dst_port),
-						   clib_net_to_host_u32
-						   (tcp0->ack_number))))
-		{
-		  rewrite = entry->ioam_rewrite_string;
-		  rewrite_len = vec_len (rewrite);
-		}
-	      else
-		{
-		  next0 = IP6_IOAM_CACHE_INPUT_NEXT_DROP;
-		  goto TRACE0;
-		}
-	    }
-	  else
-	    goto TRACE0;
-
-
-	  /* Copy the ip header left by the required amount */
-	  copy_dst0 = (u64 *) (((u8 *) ip0) - (rewrite_len + sr_rewrite_len));
-	  copy_src0 = (u64 *) ip0;
-
-	  copy_dst0[0] = copy_src0[0];
-	  copy_dst0[1] = copy_src0[1];
-	  copy_dst0[2] = copy_src0[2];
-	  copy_dst0[3] = copy_src0[3];
-	  copy_dst0[4] = copy_src0[4];
-	  vlib_buffer_advance (b0, -(word) (rewrite_len + sr_rewrite_len));
-	  ip0 = vlib_buffer_get_current (b0);
-
-	  hbh0 = (ip6_hop_by_hop_header_t *) (ip0 + 1);
-	  srh0 = (ip6_sr_header_t *) ((u8 *) hbh0 + rewrite_len);
-	  /* $$$ tune, rewrite_len is a multiple of 8 */
-	  clib_memcpy_fast (hbh0, rewrite, rewrite_len);
-	  clib_memcpy_fast (srh0, cm->sr_rewrite_template, sr_rewrite_len);
-	  /* Copy dst address into the DA slot in the segment list */
-	  clib_memcpy_fast (srh0->segments, ip0->dst_address.as_u64,
-			    sizeof (ip6_address_t));
-	  /* Rewrite the ip6 dst address with the first hop */
-	  clib_memcpy_fast (ip0->dst_address.as_u64, entry->next_hop.as_u64,
-			    sizeof (ip6_address_t));
-	  clib_memcpy_fast (&srh0->segments[1],
-			    (u8 *) hbh0 + entry->my_address_offset,
-			    sizeof (ip6_address_t));
-	  ioam_cache_entry_free (entry);
-
-	  /* Patch the protocol chain, insert the h-b-h (type 0) header */
-	  srh0->protocol = ip0->protocol;
-	  hbh0->protocol = IPPROTO_IPV6_ROUTE;
-	  ip0->protocol = 0;
-	  new_l0 =
-	    clib_net_to_host_u16 (ip0->payload_length) + rewrite_len +
-	    sr_rewrite_len;
-	  ip0->payload_length = clib_host_to_net_u16 (new_l0);
-	  processed++;
-	TRACE0:
-	  if (PREDICT_FALSE ((node->flags & VLIB_NODE_FLAG_TRACE)
-			     && (b0->flags & VLIB_BUFFER_IS_TRACED)))
-	    {
-	      ip6_add_from_cache_hbh_trace_t *t =
-		vlib_add_trace (vm, node, b0, sizeof (*t));
-	      t->next_index = next0;
-	    }
-
-	  /* verify speculative enqueue, maybe switch current next frame */
-	  vlib_validate_buffer_enqueue_x1 (vm, node, next_index,
-					   to_next, n_left_to_next,
-					   bi0, next0);
-	}
-
-      vlib_put_next_frame (vm, node, next_index, n_left_to_next);
-    }
-
-  vlib_node_increment_counter (vm, cm->ip6_add_from_cache_hbh_node_index,
-			       IP6_ADD_FROM_CACHE_HBH_ERROR_PROCESSED,
-			       processed);
-  return frame->n_vectors;
-}
-/* *INDENT-OFF* */
-VLIB_REGISTER_NODE (ip6_add_from_cache_hbh_node) =
-{
-  .name = "ip6-add-from-cache-hop-by-hop",
-  .vector_size = sizeof (u32),
-  .format_trace = format_ip6_add_from_cache_hbh_trace,
-  .type = VLIB_NODE_TYPE_INTERNAL,
-  .n_errors = ARRAY_LEN (ip6_add_from_cache_hbh_error_strings),
-  .error_strings =  ip6_add_from_cache_hbh_error_strings,
-  /* See ip/lookup.h */
-  .n_next_nodes = IP6_IOAM_CACHE_INPUT_N_NEXT,
-  .next_nodes =
-  {
-#define _(s,n) [IP6_IOAM_CACHE_INPUT_NEXT_##s] = n,
-    foreach_ip6_ioam_cache_input_next
-#undef _
-  },
-};
-/* *INDENT-ON* */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/ip6/ioam_cache_tunnel_select_node.c b/ioam/ip6/ioam_cache_tunnel_select_node.c
deleted file mode 100644
index d2c7f20..0000000
--- a/ioam/ip6/ioam_cache_tunnel_select_node.c
+++ /dev/null
@@ -1,768 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- * ioam_cache_tunnel_select_node.c
- * This file implements anycast server selection using ioam data
- * attached to anycast service selection.
- * Anycast service is reachable via multiple servers reachable
- * over SR tunnels.
- * Works with TCP Anycast application.
- * Cache entry is created when TCP SYN is received for anycast destination.
- * Response TCP SYN ACKs for anycast service is compared and selected
- * response is forwarded.
- * The functionality is introduced via graph nodes that are hooked into
- * vnet graph via classifier configs like below:
- *
- * Enable anycast service selection:
- * set ioam ip6 sr-tunnel-select oneway
- *
- * Enable following classifier on the anycast service client facing interface
- * e.g. anycast service is db06::06 then:
- * classify session acl-hit-next ip6-node ip6-add-syn-hop-by-hop table-index 0 match l3
- * ip6 dst db06::06 ioam-encap anycast
- *
- * Enable following classifier on the interfaces facing the server of anycast service:
- * classify session acl-hit-next ip6-node ip6-lookup table-index 0 match l3
- *            ip6 src db06::06 ioam-decap anycast
- *
- */
-#include <vlib/vlib.h>
-#include <vnet/vnet.h>
-#include <vppinfra/error.h>
-#include <vnet/ip/ip.h>
-#include <vnet/srv6/sr.h>
-#include <ioam/ip6/ioam_cache.h>
-#include <vnet/ip/ip6_hop_by_hop.h>
-#include <vnet/ip/ip6_hop_by_hop_packet.h>
-#include <vnet/ip/ip6_inlines.h>
-
-typedef struct
-{
-  u32 next_index;
-  u32 flow_label;
-} cache_ts_trace_t;
-
-/* packet trace format function */
-static u8 *
-format_cache_ts_trace (u8 * s, va_list * args)
-{
-  CLIB_UNUSED (vlib_main_t * vm) = va_arg (*args, vlib_main_t *);
-  CLIB_UNUSED (vlib_node_t * node) = va_arg (*args, vlib_node_t *);
-  cache_ts_trace_t *t = va_arg (*args, cache_ts_trace_t *);
-
-  s = format (s, "CACHE: flow_label %d, next index %d",
-	      t->flow_label, t->next_index);
-  return s;
-}
-
-#define foreach_cache_ts_error \
-_(RECORDED, "ip6 iOAM headers cached")
-
-typedef enum
-{
-#define _(sym,str) CACHE_TS_ERROR_##sym,
-  foreach_cache_ts_error
-#undef _
-    CACHE_TS_N_ERROR,
-} cache_ts_error_t;
-
-static char *cache_ts_error_strings[] = {
-#define _(sym,string) string,
-  foreach_cache_ts_error
-#undef _
-};
-
-typedef enum
-{
-  IOAM_CACHE_TS_NEXT_POP_HBYH,
-  IOAM_CACHE_TS_ERROR_NEXT_DROP,
-  IOAM_CACHE_TS_N_NEXT,
-} cache_ts_next_t;
-
-static uword
-ip6_ioam_cache_ts_node_fn (vlib_main_t * vm,
-			   vlib_node_runtime_t * node, vlib_frame_t * frame)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  u32 n_left_from, *from, *to_next;
-  cache_ts_next_t next_index;
-  u32 recorded = 0;
-
-  from = vlib_frame_vector_args (frame);
-  n_left_from = frame->n_vectors;
-  next_index = node->cached_next_index;
-
-  while (n_left_from > 0)
-    {
-      u32 n_left_to_next;
-
-      vlib_get_next_frame (vm, node, next_index, to_next, n_left_to_next);
-      // TODO: dual loop
-      while (n_left_from > 0 && n_left_to_next > 0)
-	{
-	  u32 bi0;
-	  vlib_buffer_t *p0;
-	  u32 next0 = IOAM_CACHE_TS_NEXT_POP_HBYH;
-	  ip6_header_t *ip0;
-	  ip6_hop_by_hop_header_t *hbh0, *hbh_cmp;
-	  tcp_header_t *tcp0;
-	  u32 tcp_offset0;
-	  u32 cache_ts_index = 0;
-	  u8 cache_thread_id = 0;
-	  int result = 0;
-	  int skip = 0;
-
-	  bi0 = from[0];
-	  from += 1;
-	  n_left_from -= 1;
-
-	  p0 = vlib_get_buffer (vm, bi0);
-	  ip0 = vlib_buffer_get_current (p0);
-	  if (IP_PROTOCOL_TCP ==
-	      ip6_locate_header (p0, ip0, IP_PROTOCOL_TCP, &tcp_offset0))
-	    {
-	      tcp0 = (tcp_header_t *) ((u8 *) ip0 + tcp_offset0);
-	      if ((tcp0->flags & TCP_FLAG_SYN) == TCP_FLAG_SYN &&
-		  (tcp0->flags & TCP_FLAG_ACK) == TCP_FLAG_ACK)
-		{
-		  /* Look up and compare */
-		  hbh0 = (ip6_hop_by_hop_header_t *) (ip0 + 1);
-
-		  if (0 == ioam_cache_ts_lookup (ip0,
-						 hbh0->protocol,
-						 clib_net_to_host_u16
-						 (tcp0->src_port),
-						 clib_net_to_host_u16
-						 (tcp0->dst_port),
-						 clib_net_to_host_u32
-						 (tcp0->ack_number), &hbh_cmp,
-						 &cache_ts_index,
-						 &cache_thread_id, 1))
-		    {
-		      /* response seen */
-		      result = -1;
-		      if (hbh_cmp)
-			result =
-			  ip6_ioam_analyse_compare_path_delay (hbh0, hbh_cmp,
-							       cm->criteria_oneway);
-		      if (result >= 0)
-			{
-			  /* current syn/ack is worse than the earlier: Drop */
-			  next0 = IOAM_CACHE_TS_ERROR_NEXT_DROP;
-			  /* Check if all responses are received or time has exceeded
-			     send cached response if yes */
-			  ioam_cache_ts_check_and_send (cache_thread_id,
-							cache_ts_index);
-			}
-		      else
-			{
-			  /* Update cache with this buffer */
-			  /* If successfully updated then skip sending it */
-			  if (0 ==
-			      (result =
-			       ioam_cache_ts_update (cache_thread_id,
-						     cache_ts_index, bi0,
-						     hbh0)))
-			    {
-			      skip = 1;
-			    }
-			  else
-			    next0 = IOAM_CACHE_TS_ERROR_NEXT_DROP;
-			}
-		    }
-		  else
-		    {
-		      next0 = IOAM_CACHE_TS_ERROR_NEXT_DROP;
-		    }
-		}
-	      else if ((tcp0->flags & TCP_FLAG_RST) == TCP_FLAG_RST)
-		{
-		  /* Look up and compare */
-		  hbh0 = (ip6_hop_by_hop_header_t *) (ip0 + 1);
-		  if (0 == ioam_cache_ts_lookup (ip0, hbh0->protocol, clib_net_to_host_u16 (tcp0->src_port), clib_net_to_host_u16 (tcp0->dst_port), clib_net_to_host_u32 (tcp0->ack_number), &hbh_cmp, &cache_ts_index, &cache_thread_id, 1))	//response seen
-		    {
-		      next0 = IOAM_CACHE_TS_ERROR_NEXT_DROP;
-		      if (hbh_cmp)
-			ioam_cache_ts_check_and_send (cache_thread_id,
-						      cache_ts_index);
-		    }
-
-		}
-	    }
-	  if (PREDICT_FALSE ((node->flags & VLIB_NODE_FLAG_TRACE)))
-	    {
-	      if (p0->flags & VLIB_BUFFER_IS_TRACED)
-		{
-		  cache_ts_trace_t *t =
-		    vlib_add_trace (vm, node, p0, sizeof (*t));
-		  t->flow_label =
-		    clib_net_to_host_u32
-		    (ip0->ip_version_traffic_class_and_flow_label);
-		  t->next_index = next0;
-		}
-	    }
-	  /* verify speculative enqueue, maybe switch current next frame */
-	  if (!skip)
-	    {
-	      to_next[0] = bi0;
-	      to_next += 1;
-	      n_left_to_next -= 1;
-	      vlib_validate_buffer_enqueue_x1 (vm, node, next_index,
-					       to_next, n_left_to_next,
-					       bi0, next0);
-	    }
-	}
-
-      vlib_put_next_frame (vm, node, next_index, n_left_to_next);
-    }
-  vlib_node_increment_counter (vm, ioam_cache_ts_node.index,
-			       CACHE_TS_ERROR_RECORDED, recorded);
-  return frame->n_vectors;
-}
-
-/*
- * Node for IP6 iOAM header cache
- */
-/* *INDENT-OFF* */
-VLIB_REGISTER_NODE (ioam_cache_ts_node) =
-{
-  .function = ip6_ioam_cache_ts_node_fn,
-  .name = "ip6-ioam-tunnel-select",
-  .vector_size = sizeof (u32),
-  .format_trace = format_cache_ts_trace,
-  .type = VLIB_NODE_TYPE_INTERNAL,
-  .n_errors = ARRAY_LEN (cache_ts_error_strings),
-  .error_strings = cache_ts_error_strings,
-  .n_next_nodes = IOAM_CACHE_TS_N_NEXT,
-  /* edit / add dispositions here */
-  .next_nodes =
-  {
-    [IOAM_CACHE_TS_NEXT_POP_HBYH] = "ip6-pop-hop-by-hop",
-    [IOAM_CACHE_TS_ERROR_NEXT_DROP] = "error-drop",
-  },
-};
-/* *INDENT-ON* */
-
-typedef struct
-{
-  u32 next_index;
-} ip6_reset_ts_hbh_trace_t;
-
-/* packet trace format function */
-static u8 *
-format_ip6_reset_ts_hbh_trace (u8 * s, va_list * args)
-{
-  CLIB_UNUSED (vlib_main_t * vm) = va_arg (*args, vlib_main_t *);
-  CLIB_UNUSED (vlib_node_t * node) = va_arg (*args, vlib_node_t *);
-  ip6_reset_ts_hbh_trace_t *t = va_arg (*args,
-					ip6_reset_ts_hbh_trace_t *);
-
-  s =
-    format (s, "IP6_IOAM_RESET_TUNNEL_SELECT_HBH: next index %d",
-	    t->next_index);
-  return s;
-}
-
-#define foreach_ip6_reset_ts_hbh_error \
-_(PROCESSED, "iOAM Syn/Ack Pkts processed") \
-_(SAVED, "iOAM Syn Pkts state saved") \
-_(REMOVED, "iOAM Syn/Ack Pkts state removed")
-
-typedef enum
-{
-#define _(sym,str) IP6_RESET_TS_HBH_ERROR_##sym,
-  foreach_ip6_reset_ts_hbh_error
-#undef _
-    IP6_RESET_TS_HBH_N_ERROR,
-} ip6_reset_ts_hbh_error_t;
-
-static char *ip6_reset_ts_hbh_error_strings[] = {
-#define _(sym,string) string,
-  foreach_ip6_reset_ts_hbh_error
-#undef _
-};
-
-#define foreach_ip6_ioam_cache_ts_input_next    \
-  _(IP6_LOOKUP, "ip6-lookup")                   \
-  _(DROP, "error-drop")
-
-typedef enum
-{
-#define _(s,n) IP6_IOAM_CACHE_TS_INPUT_NEXT_##s,
-  foreach_ip6_ioam_cache_ts_input_next
-#undef _
-    IP6_IOAM_CACHE_TS_INPUT_N_NEXT,
-} ip6_ioam_cache_ts_input_next_t;
-
-
-VLIB_NODE_FN (ip6_reset_ts_hbh_node) (vlib_main_t * vm,
-				      vlib_node_runtime_t * node,
-				      vlib_frame_t * frame)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  u32 n_left_from, *from, *to_next;
-  ip_lookup_next_t next_index;
-  u32 processed = 0, cache_ts_added = 0;
-  u64 now;
-  u8 *rewrite = cm->rewrite;
-  u32 rewrite_length = vec_len (rewrite);
-  ioam_e2e_cache_option_t *e2e = 0;
-  u8 no_of_responses = cm->wait_for_responses;
-
-  from = vlib_frame_vector_args (frame);
-  n_left_from = frame->n_vectors;
-  next_index = node->cached_next_index;
-
-  while (n_left_from > 0)
-    {
-      u32 n_left_to_next;
-
-      vlib_get_next_frame (vm, node, next_index, to_next, n_left_to_next);
-
-      now = vlib_time_now (vm);
-      while (n_left_from >= 4 && n_left_to_next >= 2)
-	{
-	  u32 bi0, bi1;
-	  vlib_buffer_t *b0, *b1;
-	  u32 next0, next1;
-	  ip6_header_t *ip0, *ip1;
-	  tcp_header_t *tcp0, *tcp1;
-	  u32 tcp_offset0, tcp_offset1;
-	  ip6_hop_by_hop_header_t *hbh0, *hbh1;
-	  u64 *copy_src0, *copy_dst0, *copy_src1, *copy_dst1;
-	  u16 new_l0, new_l1;
-	  u32 pool_index0 = 0, pool_index1 = 0;
-
-	  next0 = next1 = IP6_IOAM_CACHE_TS_INPUT_NEXT_IP6_LOOKUP;
-	  /* Prefetch next iteration. */
-	  {
-	    vlib_buffer_t *p2, *p3;
-
-	    p2 = vlib_get_buffer (vm, from[2]);
-	    p3 = vlib_get_buffer (vm, from[3]);
-
-	    vlib_prefetch_buffer_header (p2, LOAD);
-	    vlib_prefetch_buffer_header (p3, LOAD);
-	    CLIB_PREFETCH (p2->data, 2 * CLIB_CACHE_LINE_BYTES, LOAD);
-	    CLIB_PREFETCH (p3->data, 2 * CLIB_CACHE_LINE_BYTES, LOAD);
-	  }
-
-
-	  /* speculatively enqueue b0 to the current next frame */
-	  to_next[0] = bi0 = from[0];
-	  to_next[1] = bi1 = from[1];
-	  from += 2;
-	  to_next += 2;
-	  n_left_from -= 2;
-	  n_left_to_next -= 2;
-
-	  b0 = vlib_get_buffer (vm, bi0);
-	  b1 = vlib_get_buffer (vm, bi1);
-
-	  ip0 = vlib_buffer_get_current (b0);
-	  ip1 = vlib_buffer_get_current (b1);
-
-	  if (IP_PROTOCOL_TCP !=
-	      ip6_locate_header (b0, ip0, IP_PROTOCOL_TCP, &tcp_offset0))
-	    {
-	      goto NEXT00;
-	    }
-	  tcp0 = (tcp_header_t *) ((u8 *) ip0 + tcp_offset0);
-	  if ((tcp0->flags & TCP_FLAG_SYN) == TCP_FLAG_SYN &&
-	      (tcp0->flags & TCP_FLAG_ACK) == 0)
-	    {
-	      if (no_of_responses > 0)
-		{
-		  /* Create TS select entry */
-		  if (0 == ioam_cache_ts_add (ip0,
-					      clib_net_to_host_u16
-					      (tcp0->src_port),
-					      clib_net_to_host_u16
-					      (tcp0->dst_port),
-					      clib_net_to_host_u32
-					      (tcp0->seq_number) + 1,
-					      no_of_responses, now,
-					      vm->thread_index, &pool_index0))
-		    {
-		      cache_ts_added++;
-		    }
-		}
-	      copy_dst0 = (u64 *) (((u8 *) ip0) - rewrite_length);
-	      copy_src0 = (u64 *) ip0;
-
-	      copy_dst0[0] = copy_src0[0];
-	      copy_dst0[1] = copy_src0[1];
-	      copy_dst0[2] = copy_src0[2];
-	      copy_dst0[3] = copy_src0[3];
-	      copy_dst0[4] = copy_src0[4];
-
-	      vlib_buffer_advance (b0, -(word) rewrite_length);
-	      ip0 = vlib_buffer_get_current (b0);
-
-	      hbh0 = (ip6_hop_by_hop_header_t *) (ip0 + 1);
-	      /* $$$ tune, rewrite_length is a multiple of 8 */
-	      clib_memcpy_fast (hbh0, rewrite, rewrite_length);
-	      e2e =
-		(ioam_e2e_cache_option_t *) ((u8 *) hbh0 +
-					     cm->rewrite_pool_index_offset);
-	      e2e->pool_id = (u8) vm->thread_index;
-	      e2e->pool_index = pool_index0;
-	      ioam_e2e_id_rewrite_handler ((ioam_e2e_id_option_t *)
-					   ((u8 *) e2e +
-					    sizeof (ioam_e2e_cache_option_t)),
-					   &cm->sr_localsid_ts);
-	      /* Patch the protocol chain, insert the h-b-h (type 0) header */
-	      hbh0->protocol = ip0->protocol;
-	      ip0->protocol = 0;
-	      new_l0 =
-		clib_net_to_host_u16 (ip0->payload_length) + rewrite_length;
-	      ip0->payload_length = clib_host_to_net_u16 (new_l0);
-	      processed++;
-	    }
-
-	NEXT00:
-	  if (IP_PROTOCOL_TCP !=
-	      ip6_locate_header (b1, ip1, IP_PROTOCOL_TCP, &tcp_offset1))
-	    {
-	      goto TRACE00;
-	    }
-	  tcp1 = (tcp_header_t *) ((u8 *) ip1 + tcp_offset1);
-	  if ((tcp1->flags & TCP_FLAG_SYN) == TCP_FLAG_SYN &&
-	      (tcp1->flags & TCP_FLAG_ACK) == 0)
-	    {
-	      if (no_of_responses > 0)
-		{
-		  /* Create TS select entry */
-		  if (0 == ioam_cache_ts_add (ip1,
-					      clib_net_to_host_u16
-					      (tcp1->src_port),
-					      clib_net_to_host_u16
-					      (tcp1->dst_port),
-					      clib_net_to_host_u32
-					      (tcp1->seq_number) + 1,
-					      no_of_responses, now,
-					      vm->thread_index, &pool_index1))
-		    {
-		      cache_ts_added++;
-		    }
-		}
-
-	      copy_dst1 = (u64 *) (((u8 *) ip1) - rewrite_length);
-	      copy_src1 = (u64 *) ip1;
-
-	      copy_dst1[0] = copy_src1[0];
-	      copy_dst1[1] = copy_src1[1];
-	      copy_dst1[2] = copy_src1[2];
-	      copy_dst1[3] = copy_src1[3];
-	      copy_dst1[4] = copy_src1[4];
-
-	      vlib_buffer_advance (b1, -(word) rewrite_length);
-	      ip1 = vlib_buffer_get_current (b1);
-
-	      hbh1 = (ip6_hop_by_hop_header_t *) (ip1 + 1);
-	      /* $$$ tune, rewrite_length is a multiple of 8 */
-	      clib_memcpy_fast (hbh1, rewrite, rewrite_length);
-	      e2e =
-		(ioam_e2e_cache_option_t *) ((u8 *) hbh1 +
-					     cm->rewrite_pool_index_offset);
-	      e2e->pool_id = (u8) vm->thread_index;
-	      e2e->pool_index = pool_index1;
-	      ioam_e2e_id_rewrite_handler ((ioam_e2e_id_option_t *)
-					   ((u8 *) e2e +
-					    sizeof (ioam_e2e_cache_option_t)),
-					   &cm->sr_localsid_ts);
-	      /* Patch the protocol chain, insert the h-b-h (type 0) header */
-	      hbh1->protocol = ip1->protocol;
-	      ip1->protocol = 0;
-	      new_l1 =
-		clib_net_to_host_u16 (ip1->payload_length) + rewrite_length;
-	      ip1->payload_length = clib_host_to_net_u16 (new_l1);
-	      processed++;
-	    }
-
-	TRACE00:
-	  if (PREDICT_FALSE ((node->flags & VLIB_NODE_FLAG_TRACE)))
-	    {
-	      if (b0->flags & VLIB_BUFFER_IS_TRACED)
-		{
-		  ip6_reset_ts_hbh_trace_t *t =
-		    vlib_add_trace (vm, node, b0, sizeof (*t));
-		  t->next_index = next0;
-		}
-	      if (b1->flags & VLIB_BUFFER_IS_TRACED)
-		{
-		  ip6_reset_ts_hbh_trace_t *t =
-		    vlib_add_trace (vm, node, b1, sizeof (*t));
-		  t->next_index = next1;
-		}
-
-	    }
-
-	  /* verify speculative enqueue, maybe switch current next frame */
-	  vlib_validate_buffer_enqueue_x2 (vm, node, next_index,
-					   to_next, n_left_to_next,
-					   bi0, bi1, next0, next1);
-	}
-      while (n_left_from > 0 && n_left_to_next > 0)
-	{
-	  u32 bi0;
-	  vlib_buffer_t *b0;
-	  u32 next0;
-	  ip6_header_t *ip0;
-	  tcp_header_t *tcp0;
-	  u32 tcp_offset0;
-	  ip6_hop_by_hop_header_t *hbh0;
-	  u64 *copy_src0, *copy_dst0;
-	  u16 new_l0;
-	  u32 pool_index0 = 0;
-
-	  next0 = IP6_IOAM_CACHE_TS_INPUT_NEXT_IP6_LOOKUP;
-	  /* speculatively enqueue b0 to the current next frame */
-	  bi0 = from[0];
-	  to_next[0] = bi0;
-	  from += 1;
-	  to_next += 1;
-	  n_left_from -= 1;
-	  n_left_to_next -= 1;
-
-	  b0 = vlib_get_buffer (vm, bi0);
-
-	  ip0 = vlib_buffer_get_current (b0);
-	  if (IP_PROTOCOL_TCP !=
-	      ip6_locate_header (b0, ip0, IP_PROTOCOL_TCP, &tcp_offset0))
-	    {
-	      goto TRACE0;
-	    }
-	  tcp0 = (tcp_header_t *) ((u8 *) ip0 + tcp_offset0);
-	  if ((tcp0->flags & TCP_FLAG_SYN) == TCP_FLAG_SYN &&
-	      (tcp0->flags & TCP_FLAG_ACK) == 0)
-	    {
-	      if (no_of_responses > 0)
-		{
-		  /* Create TS select entry */
-		  if (0 == ioam_cache_ts_add (ip0,
-					      clib_net_to_host_u16
-					      (tcp0->src_port),
-					      clib_net_to_host_u16
-					      (tcp0->dst_port),
-					      clib_net_to_host_u32
-					      (tcp0->seq_number) + 1,
-					      no_of_responses, now,
-					      vm->thread_index, &pool_index0))
-		    {
-		      cache_ts_added++;
-		    }
-		}
-	      copy_dst0 = (u64 *) (((u8 *) ip0) - rewrite_length);
-	      copy_src0 = (u64 *) ip0;
-
-	      copy_dst0[0] = copy_src0[0];
-	      copy_dst0[1] = copy_src0[1];
-	      copy_dst0[2] = copy_src0[2];
-	      copy_dst0[3] = copy_src0[3];
-	      copy_dst0[4] = copy_src0[4];
-
-	      vlib_buffer_advance (b0, -(word) rewrite_length);
-	      ip0 = vlib_buffer_get_current (b0);
-
-	      hbh0 = (ip6_hop_by_hop_header_t *) (ip0 + 1);
-	      /* $$$ tune, rewrite_length is a multiple of 8 */
-	      clib_memcpy_fast (hbh0, rewrite, rewrite_length);
-	      e2e =
-		(ioam_e2e_cache_option_t *) ((u8 *) hbh0 +
-					     cm->rewrite_pool_index_offset);
-	      e2e->pool_id = (u8) vm->thread_index;
-	      e2e->pool_index = pool_index0;
-	      ioam_e2e_id_rewrite_handler ((ioam_e2e_id_option_t *)
-					   ((u8 *) e2e +
-					    sizeof (ioam_e2e_cache_option_t)),
-					   &cm->sr_localsid_ts);
-	      /* Patch the protocol chain, insert the h-b-h (type 0) header */
-	      hbh0->protocol = ip0->protocol;
-	      ip0->protocol = 0;
-	      new_l0 =
-		clib_net_to_host_u16 (ip0->payload_length) + rewrite_length;
-	      ip0->payload_length = clib_host_to_net_u16 (new_l0);
-	      processed++;
-	    }
-	TRACE0:
-	  if (PREDICT_FALSE ((node->flags & VLIB_NODE_FLAG_TRACE)
-			     && (b0->flags & VLIB_BUFFER_IS_TRACED)))
-	    {
-	      ip6_reset_ts_hbh_trace_t *t =
-		vlib_add_trace (vm, node, b0, sizeof (*t));
-	      t->next_index = next0;
-	    }
-
-	  /* verify speculative enqueue, maybe switch current next frame */
-	  vlib_validate_buffer_enqueue_x1 (vm, node, next_index,
-					   to_next, n_left_to_next,
-					   bi0, next0);
-	}
-
-      vlib_put_next_frame (vm, node, next_index, n_left_to_next);
-    }
-
-  vlib_node_increment_counter (vm, cm->ip6_reset_ts_hbh_node_index,
-			       IP6_RESET_TS_HBH_ERROR_PROCESSED, processed);
-  vlib_node_increment_counter (vm, cm->ip6_reset_ts_hbh_node_index,
-			       IP6_RESET_TS_HBH_ERROR_SAVED, cache_ts_added);
-
-  return frame->n_vectors;
-}
-
-/* *INDENT-OFF* */
-VLIB_REGISTER_NODE (ip6_reset_ts_hbh_node) =
-{
-  .name = "ip6-add-syn-hop-by-hop",
-  .vector_size = sizeof (u32),
-  .format_trace = format_ip6_reset_ts_hbh_trace,
-  .type = VLIB_NODE_TYPE_INTERNAL,
-  .n_errors = ARRAY_LEN (ip6_reset_ts_hbh_error_strings),
-  .error_strings =  ip6_reset_ts_hbh_error_strings,
-  /* See ip/lookup.h */
-  .n_next_nodes = IP6_IOAM_CACHE_TS_INPUT_N_NEXT,
-  .next_nodes =
-  {
-#define _(s,n) [IP6_IOAM_CACHE_TS_INPUT_NEXT_##s] = n,
-    foreach_ip6_ioam_cache_ts_input_next
-#undef _
-  },
-};
-
-/* *INDENT-ON* */
-
-#ifndef CLIB_MARCH_VARIANT
-vlib_node_registration_t ioam_cache_ts_timer_tick_node;
-#endif /* CLIB_MARCH_VARIANT */
-
-typedef struct
-{
-  u32 thread_index;
-} ioam_cache_ts_timer_tick_trace_t;
-
-/* packet trace format function */
-static u8 *
-format_ioam_cache_ts_timer_tick_trace (u8 * s, va_list * args)
-{
-  CLIB_UNUSED (vlib_main_t * vm) = va_arg (*args, vlib_main_t *);
-  CLIB_UNUSED (vlib_node_t * node) = va_arg (*args, vlib_node_t *);
-  ioam_cache_ts_timer_tick_trace_t *t =
-    va_arg (*args, ioam_cache_ts_timer_tick_trace_t *);
-
-  s = format (s, "IOAM_CACHE_TS_TIMER_TICK: thread index %d",
-	      t->thread_index);
-  return s;
-}
-
-#define foreach_ioam_cache_ts_timer_tick_error                 \
-  _(TIMER, "Timer events")
-
-typedef enum
-{
-#define _(sym,str) IOAM_CACHE_TS_TIMER_TICK_ERROR_##sym,
-  foreach_ioam_cache_ts_timer_tick_error
-#undef _
-    IOAM_CACHE_TS_TIMER_TICK_N_ERROR,
-} ioam_cache_ts_timer_tick_error_t;
-
-static char *ioam_cache_ts_timer_tick_error_strings[] = {
-#define _(sym,string) string,
-  foreach_ioam_cache_ts_timer_tick_error
-#undef _
-};
-
-#ifndef CLIB_MARCH_VARIANT
-void
-ioam_cache_ts_timer_node_enable (vlib_main_t * vm, u8 enable)
-{
-  vlib_node_set_state (vm, ioam_cache_ts_timer_tick_node.index,
-		       enable ==
-		       0 ? VLIB_NODE_STATE_DISABLED :
-		       VLIB_NODE_STATE_POLLING);
-}
-
-void
-expired_cache_ts_timer_callback (u32 * expired_timers)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  int i;
-  u32 pool_index;
-  u32 thread_index = vlib_get_thread_index ();
-  u32 count = 0;
-
-  for (i = 0; i < vec_len (expired_timers); i++)
-    {
-      /* Get pool index and pool id */
-      pool_index = expired_timers[i] & 0x0FFFFFFF;
-
-      /* Handle expiration */
-      ioam_cache_ts_send (thread_index, pool_index);
-      count++;
-    }
-  vlib_node_increment_counter (cm->vlib_main,
-			       ioam_cache_ts_timer_tick_node.index,
-			       IOAM_CACHE_TS_TIMER_TICK_ERROR_TIMER, count);
-}
-#endif /* CLIB_MARCH_VARIANT */
-
-static uword
-ioam_cache_ts_timer_tick_node_fn (vlib_main_t * vm,
-				  vlib_node_runtime_t * node,
-				  vlib_frame_t * f)
-{
-  ioam_cache_main_t *cm = &ioam_cache_main;
-  u32 my_thread_index = vlib_get_thread_index ();
-  struct timespec ts, tsrem;
-
-  tw_timer_expire_timers_16t_2w_512sl (&cm->timer_wheels[my_thread_index],
-				       vlib_time_now (vm));
-  ts.tv_sec = 0;
-  ts.tv_nsec = 1000 * 1000 * IOAM_CACHE_TS_TICK;
-  while (nanosleep (&ts, &tsrem) < 0)
-    {
-      ts = tsrem;
-    }
-
-  return 0;
-}
-/* *INDENT-OFF* */
-VLIB_REGISTER_NODE (ioam_cache_ts_timer_tick_node) = {
-  .function = ioam_cache_ts_timer_tick_node_fn,
-  .name = "ioam-cache-ts-timer-tick",
-  .format_trace = format_ioam_cache_ts_timer_tick_trace,
-  .type = VLIB_NODE_TYPE_INPUT,
-
-  .n_errors = ARRAY_LEN(ioam_cache_ts_timer_tick_error_strings),
-  .error_strings = ioam_cache_ts_timer_tick_error_strings,
-
-  .n_next_nodes = 1,
-
-  .state = VLIB_NODE_STATE_DISABLED,
-
-  /* edit / add dispositions here */
-  .next_nodes = {
-    [0] = "error-drop",
-  },
-};
-/* *INDENT-ON* */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/ipfixcollector/ipfixcollector.c b/ioam/ipfixcollector/ipfixcollector.c
deleted file mode 100644
index d4f57c5..0000000
--- a/ioam/ipfixcollector/ipfixcollector.c
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <vnet/ip/ip.h>
-#include <vnet/plugin/plugin.h>
-#include <vnet/udp/udp_local.h>
-#include <ioam/ipfixcollector/ipfixcollector.h>
-
-ipfix_collector_main_t ipfix_collector_main;
-
-/**
- * @brief IP-FIX SetID registration function.
- *
- * This function can be used by other VPP graph nodes to receive IP-FIX packets
- * with a particular setid.
- *
- * @param vm Vlib main of the graph node which is interested in
- *                    getting IP-Fix packet.
- * @param info Structure describing the client node which
- *                               is interested in getting the IP-Fix packets for
- *                               a SetID.
- *
- * @returns 0 on success.
- * @returns Error codes(<0) otherwise.
- */
-int
-ipfix_collector_reg_setid (vlib_main_t * vm, ipfix_client_add_del_t * info)
-{
-  ipfix_collector_main_t *cm = &ipfix_collector_main;
-  uword *p = NULL;
-  int i;
-  ipfix_client *client = 0;
-
-  if ((!info) || (!info->client_name))
-    return IPFIX_COLLECTOR_ERR_INVALID_PARAM;
-
-  p = hash_get (cm->client_reg_table, info->ipfix_setid);
-  client = p ? pool_elt_at_index (cm->client_reg_pool, (*p)) : NULL;
-
-  if (info->del)
-    {
-      if (!client)
-	return 0;		//There is no registered handler, so send success
-
-      hash_unset (cm->client_reg_table, info->ipfix_setid);
-      vec_free (client->client_name);
-      pool_put (cm->client_reg_pool, client);
-      return 0;
-    }
-
-  if (client)
-    return IPFIX_COLLECTOR_ERR_REG_EXISTS;
-
-  pool_get (cm->client_reg_pool, client);
-  i = client - cm->client_reg_pool;
-  client->client_name = vec_dup (info->client_name);
-  client->client_node = info->client_node;
-  client->client_next_node = vlib_node_add_next (vm,
-						 ipfix_collector_node.index,
-						 client->client_node);
-  client->set_id = info->ipfix_setid;
-
-  hash_set (cm->client_reg_table, info->ipfix_setid, i);
-
-  if (!udp_is_valid_dst_port (UDP_DST_PORT_ipfix, 1))
-    udp_register_dst_port (vm, UDP_DST_PORT_ipfix,
-			   ipfix_collector_node.index, 1);
-
-  return 0;
-}
-
-static clib_error_t *
-ipfix_collector_init (vlib_main_t * vm)
-{
-  clib_error_t *error = 0;
-  ipfix_collector_main_t *cm = &ipfix_collector_main;
-
-  cm->vlib_main = vm;
-  cm->vnet_main = vnet_get_main ();
-
-  cm->client_reg_pool = NULL;
-  cm->client_reg_table = hash_create (0, sizeof (uword));
-
-  return error;
-}
-
-VLIB_INIT_FUNCTION (ipfix_collector_init);
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/ipfixcollector/ipfixcollector.h b/ioam/ipfixcollector/ipfixcollector.h
deleted file mode 100644
index 182f12d..0000000
--- a/ioam/ipfixcollector/ipfixcollector.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef PLUGINS_IPFIXCOLLECTOR_PLUGIN_IPFIXCOLLECTOR_IPFIXCOLLECTOR_H_
-#define PLUGINS_IPFIXCOLLECTOR_PLUGIN_IPFIXCOLLECTOR_IPFIXCOLLECTOR_H_
-
-#include <vppinfra/pool.h>
-#include <vppinfra/hash.h>
-#include <vppinfra/error.h>
-
-#define IPFIX_COLLECTOR_CLIENT_NAME_MAX 64
-
-#define IPFIX_COLLECTOR_ERR_INVALID_PARAM -1
-#define IPFIX_COLLECTOR_ERR_REG_EXISTS -2
-
-/** @brief Structure other nodes to use for registering with IP-FIX collector.
-*/
-typedef struct
-{
-  /** String containing name of the client interested in getting
-      ip-fix packets. */
-  u8 *client_name;
-
-  /** Node index where packets have to be redirected. */
-  u32 client_node;
-
-  /** Setid of IPFix for which client is interested in getting packets. */
-  u16 ipfix_setid;
-
-  /** Add(0) or del(1) operation. */
-  u16 del;
-} ipfix_client_add_del_t;
-
-/** @brief IP-FIX collector internal client structure to store SetID to
-     client node ID.
-*/
-typedef struct
-{
-  /** String containing name of the client interested in getting
-        ip-fix packets. */
-  u8 *client_name;
-
-  /** Node index where packets have to be redirected. */
-  u32 client_node;
-
-  /** ipfix-collector next index where packets have to be redirected. */
-  u32 client_next_node;
-
-  /** Setid of IPFix for which client is interested in getting packets. */
-  u16 set_id;
-} ipfix_client;
-
-/** @brief IP-FIX collector main structure to SetID to client node ID mapping.
-    @note cache aligned.
-*/
-typedef struct
-{
-  /** Hash table to map IP-FIX setid to a client registration pool. SetId is
-      key to hash map. */
-  uword *client_reg_table;
-
-  /** Pool of Client node information for the IP-FIX SetID. */
-  ipfix_client *client_reg_pool;
-
-  /** Pointer to VLib main for the node - ipfix-collector. */
-  vlib_main_t *vlib_main;
-
-  /** Pointer to vnet main for convenience. */
-  vnet_main_t *vnet_main;
-} ipfix_collector_main_t;
-
-extern vlib_node_registration_t ipfix_collector_node;
-
-extern ipfix_collector_main_t ipfix_collector_main;
-
-/**
- * @brief IP-FIX SetID registration function.
- *
- * This function can be used by other VPP graph nodes to receive IP-FIX packets
- * with a particular setid.
- *
- * @param vm Vlib main of the graph node which is interested in
- *                    getting IP-Fix packet.
- * @param info Structure describing the client node which
- *                               is interested in getting the IP-Fix packets for
- *                               a SetID.
- *
- * @returns 0 on success.
- * @returns Error codes(<0) otherwise.
- */
-int
-ipfix_collector_reg_setid (vlib_main_t * vm, ipfix_client_add_del_t * info);
-
-always_inline ipfix_client *
-ipfix_collector_get_client (u16 set_id)
-{
-  ipfix_collector_main_t *cm = &ipfix_collector_main;
-  uword *p;
-
-  p = hash_get (cm->client_reg_table, set_id);
-  return (p ? pool_elt_at_index (cm->client_reg_pool, (*p)) : NULL);
-}
-
-#endif /* PLUGINS_IPFIXCOLLECTOR_PLUGIN_IPFIXCOLLECTOR_IPFIXCOLLECTOR_H_ */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/ipfixcollector/node.c b/ioam/ipfixcollector/node.c
deleted file mode 100644
index 098029d..0000000
--- a/ioam/ipfixcollector/node.c
+++ /dev/null
@@ -1,300 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <vlib/vlib.h>
-#include <vnet/vnet.h>
-#include <vppinfra/error.h>
-#include <ioam/ipfixcollector/ipfixcollector.h>
-#include <vnet/ipfix-export/ipfix_packet.h>
-
-#define foreach_ipfix_collector_error \
-_(PROCESSED, "Number of IP-Fix packets processed") \
-_(NO_LISTENER, "Number of IP-Fix packets with no listener")
-
-typedef enum
-{
-#define _(sym,str) IPFIX_COLLECTOR_ERROR_##sym,
-  foreach_ipfix_collector_error
-#undef _
-    IPFIX_COLLECTOR_N_ERROR,
-} flowperpkt_error_t;
-
-static char *ipfix_collector_error_strings[] = {
-#define _(sym,string) string,
-  foreach_ipfix_collector_error
-#undef _
-};
-
-typedef enum
-{
-  IPFIX_COLLECTOR_NEXT_DROP,
-  IPFIX_COLLECTOR_N_NEXT,
-} ipfix_collector_next_t;
-
-typedef struct
-{
-  u32 next_node;
-  u16 set_id;
-  u16 pad;
-} ipfix_collector_trace_t;
-
-vlib_node_registration_t ipfix_collector_node;
-
-/* packet trace format function */
-static u8 *
-format_ipfix_collector_trace (u8 * s, va_list * args)
-{
-  CLIB_UNUSED (vlib_main_t * vm) = va_arg (*args, vlib_main_t *);
-  CLIB_UNUSED (vlib_node_t * node) = va_arg (*args, vlib_node_t *);
-  ipfix_collector_trace_t *t = va_arg (*args, ipfix_collector_trace_t *);
-
-  s = format (s,
-	      "IPFIX_COLLECTOR: set_id %u, next_node %u", t->set_id,
-	      t->next_node);
-  return s;
-}
-
-/**
- * @brief Node to receive IP-Fix packets.
- * @node ipfix-collector
- *
- * This function receives IP-FIX packets and forwards them to other graph nodes
- * based on SetID field in IP-FIX.
- *
- * @param vm    vlib_main_t corresponding to the current thread.
- * @param node  vlib_node_runtime_t data for this node.
- * @param frame vlib_frame_t whose contents should be dispatched.
- *
- * @par Graph mechanics: buffer, next index usage
- *
- * <em>Uses:</em>
- * - <code>vlib_buffer_get_current(p0)</code>
- *     - Parses IP-Fix packet to extract SetId which will be used to decide
- *       next node where packets should be enqueued.
- *
- * <em>Next Index:</em>
- * - Dispatches the packet to other VPP graph nodes based on their registartion
- *   for the IP-Fix SetId using API ipfix_collector_reg_setid().
- */
-uword
-ipfix_collector_node_fn (vlib_main_t * vm,
-			 vlib_node_runtime_t * node,
-			 vlib_frame_t * from_frame)
-{
-  u32 n_left_from, next_index, *from, *to_next;
-  word n_no_listener = 0;
-  word n_listener = 0;
-
-  from = vlib_frame_vector_args (from_frame);
-  n_left_from = from_frame->n_vectors;
-
-  next_index = node->cached_next_index;
-
-  while (n_left_from > 0)
-    {
-      u32 n_left_to_next;
-
-      vlib_get_next_frame (vm, node, next_index, to_next, n_left_to_next);
-
-      while (n_left_from >= 4 && n_left_to_next >= 2)
-	{
-	  u32 bi0, bi1;
-	  vlib_buffer_t *b0, *b1;
-	  u32 next0, next1;
-	  ipfix_message_header_t *ipfix0, *ipfix1;
-	  ipfix_set_header_t *set0, *set1;
-	  u16 set_id0, set_id1;
-	  ipfix_client *client0, *client1;
-
-	  /* Prefetch next iteration. */
-	  {
-	    vlib_buffer_t *p2, *p3;
-
-	    p2 = vlib_get_buffer (vm, from[2]);
-	    p3 = vlib_get_buffer (vm, from[3]);
-
-	    vlib_prefetch_buffer_header (p2, LOAD);
-	    vlib_prefetch_buffer_header (p3, LOAD);
-
-	    CLIB_PREFETCH (p2->data,
-			   (sizeof (ipfix_message_header_t) +
-			    sizeof (ipfix_set_header_t)), LOAD);
-	    CLIB_PREFETCH (p3->data,
-			   (sizeof (ipfix_message_header_t) +
-			    sizeof (ipfix_set_header_t)), LOAD);
-	  }
-
-	  bi0 = from[0];
-	  bi1 = from[1];
-	  to_next[0] = bi0;
-	  to_next[1] = bi1;
-	  from += 2;
-	  to_next += 2;
-	  n_left_to_next -= 2;
-	  n_left_from -= 2;
-
-	  b0 = vlib_get_buffer (vm, bi0);
-	  b1 = vlib_get_buffer (vm, bi1);
-
-	  ipfix0 = vlib_buffer_get_current (b0);
-	  ipfix1 = vlib_buffer_get_current (b1);
-
-	  set0 = (ipfix_set_header_t *) (ipfix0 + 1);
-	  set1 = (ipfix_set_header_t *) (ipfix1 + 1);
-
-	  set_id0 = (u16) (clib_net_to_host_u32 (set0->set_id_length) >> 16);
-	  set_id1 = (u16) (clib_net_to_host_u32 (set1->set_id_length) >> 16);
-
-	  client0 = ipfix_collector_get_client (set_id0);
-	  client1 = ipfix_collector_get_client (set_id1);
-
-	  if (PREDICT_TRUE (NULL != client0))
-	    {
-	      next0 = client0->client_next_node;
-	      n_listener++;
-	    }
-	  else
-	    {
-	      next0 = IPFIX_COLLECTOR_NEXT_DROP;
-	      n_no_listener++;
-	    }
-
-	  if (PREDICT_TRUE (NULL != client1))
-	    {
-	      next1 = client1->client_next_node;
-	      n_listener++;
-	    }
-	  else
-	    {
-	      next1 = IPFIX_COLLECTOR_NEXT_DROP;
-	      n_no_listener++;
-	    }
-
-	  vlib_buffer_advance (b0,
-			       (sizeof (ipfix_message_header_t)
-				+ sizeof (ipfix_set_header_t)));
-	  vlib_buffer_advance (b1,
-			       (sizeof (ipfix_message_header_t)
-				+ sizeof (ipfix_set_header_t)));
-
-	  if (PREDICT_FALSE (b0->flags & VLIB_BUFFER_IS_TRACED))
-	    {
-	      ipfix_collector_trace_t *tr = vlib_add_trace (vm, node,
-							    b0, sizeof (*tr));
-	      tr->next_node = (client0 ? client0->client_node : 0xFFFFFFFF);
-	      tr->set_id = set_id0;
-	    }
-	  if (PREDICT_FALSE (b1->flags & VLIB_BUFFER_IS_TRACED))
-	    {
-	      ipfix_collector_trace_t *tr = vlib_add_trace (vm, node,
-							    b1, sizeof (*tr));
-	      tr->next_node = (client1 ? client1->client_node : 0xFFFFFFFF);
-	      tr->set_id = set_id1;
-	    }
-
-	  vlib_validate_buffer_enqueue_x2 (vm, node, next_index,
-					   to_next, n_left_to_next,
-					   bi0, bi1, next0, next1);
-	}
-
-      while (n_left_from > 0 && n_left_to_next > 0)
-	{
-	  u32 bi0;
-	  vlib_buffer_t *b0;
-	  u32 next0;
-	  ipfix_message_header_t *ipfix0;
-	  ipfix_set_header_t *set0;
-	  u16 set_id0;
-	  ipfix_client *client0;
-
-	  bi0 = from[0];
-	  to_next[0] = bi0;
-	  from += 1;
-	  to_next += 1;
-	  n_left_from -= 1;
-	  n_left_to_next -= 1;
-
-	  b0 = vlib_get_buffer (vm, bi0);
-	  ipfix0 = vlib_buffer_get_current (b0);
-
-	  set0 = (ipfix_set_header_t *) (ipfix0 + 1);
-
-	  set_id0 = (u16) (clib_net_to_host_u32 (set0->set_id_length) >> 16);
-
-	  client0 = ipfix_collector_get_client (set_id0);
-
-	  if (PREDICT_TRUE (NULL != client0))
-	    {
-	      next0 = client0->client_next_node;
-	      n_listener++;
-	    }
-	  else
-	    {
-	      next0 = IPFIX_COLLECTOR_NEXT_DROP;
-	      n_no_listener++;
-	    }
-
-	  vlib_buffer_advance (b0,
-			       (sizeof (ipfix_message_header_t)
-				+ sizeof (ipfix_set_header_t)));
-	  if (PREDICT_FALSE (b0->flags & VLIB_BUFFER_IS_TRACED))
-	    {
-	      ipfix_collector_trace_t *tr = vlib_add_trace (vm, node,
-							    b0, sizeof (*tr));
-	      tr->next_node = (client0 ? client0->client_node : 0xFFFFFFFF);
-	      tr->set_id = set_id0;
-	    }
-
-	  vlib_validate_buffer_enqueue_x1 (vm, node, next_index,
-					   to_next, n_left_to_next,
-					   bi0, next0);
-	}
-
-      vlib_put_next_frame (vm, node, next_index, n_left_to_next);
-    }
-  vlib_error_count (vm, node->node_index,
-		    IPFIX_COLLECTOR_ERROR_NO_LISTENER, n_no_listener);
-  vlib_error_count (vm, node->node_index,
-		    IPFIX_COLLECTOR_ERROR_PROCESSED, n_listener);
-  return from_frame->n_vectors;
-}
-
-/* *INDENT-OFF* */
-VLIB_REGISTER_NODE (ipfix_collector_node) = {
-  .function = ipfix_collector_node_fn,
-  .name = "ipfix-collector",
-  .vector_size = sizeof (u32),
-  .format_trace = format_ipfix_collector_trace,
-  .type = VLIB_NODE_TYPE_INTERNAL,
-
-  .n_errors = ARRAY_LEN(ipfix_collector_error_strings),
-  .error_strings = ipfix_collector_error_strings,
-
-  .n_next_nodes = IPFIX_COLLECTOR_N_NEXT,
-
-  /* edit / add dispositions here */
-  .next_nodes = {
-    [IPFIX_COLLECTOR_NEXT_DROP] = "error-drop",
-  },
-};
-/* *INDENT-ON* */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-e2e/e2e_util.h b/ioam/lib-e2e/e2e_util.h
deleted file mode 100644
index f8a4ebd..0000000
--- a/ioam/lib-e2e/e2e_util.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef PLUGINS_IOAM_PLUGIN_IOAM_LIB_E2E_E2E_UTIL_H_
-#define PLUGINS_IOAM_PLUGIN_IOAM_LIB_E2E_E2E_UTIL_H_
-
-#include <ioam/lib-e2e/ioam_seqno_lib.h>
-
-/* *INDENT-OFF* */
-typedef CLIB_PACKED(struct {
-  u8 e2e_type;
-  u8 reserved;
-  u32 e2e_data;
-}) ioam_e2e_packet_t;
-/* *INDENT-ON* */
-
-#endif /* PLUGINS_IOAM_PLUGIN_IOAM_LIB_E2E_E2E_UTIL_H_ */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-e2e/ioam_seqno_lib.c b/ioam/lib-e2e/ioam_seqno_lib.c
deleted file mode 100644
index bf78c1e..0000000
--- a/ioam/lib-e2e/ioam_seqno_lib.c
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <vlib/vlib.h>
-#include <vnet/vnet.h>
-#include <ioam/lib-e2e/ioam_seqno_lib.h>
-
-u8 *
-show_ioam_seqno_cmd_fn (u8 * s, ioam_seqno_data * seqno_data, u8 enc)
-{
-  seqno_rx_info *rx;
-
-  s = format (s, "SeqNo Data:\n");
-  if (enc)
-    {
-      s = format (s, "  Current Seq. Number : %llu\n", seqno_data->seq_num);
-    }
-  else
-    {
-      rx = &seqno_data->seqno_rx;
-      s = show_ioam_seqno_analyse_data_fn (s, rx);
-    }
-
-  format (s, "\n");
-  return s;
-}
-
-u8 *
-show_ioam_seqno_analyse_data_fn (u8 * s, seqno_rx_info * rx)
-{
-  s = format (s, "  Highest Seq. Number : %llu\n", rx->bitmap.highest);
-  s = format (s, "     Packets received : %llu\n", rx->rx_packets);
-  s = format (s, "         Lost packets : %llu\n", rx->lost_packets);
-  s = format (s, "    Reordered packets : %llu\n", rx->reordered_packets);
-  s = format (s, "    Duplicate packets : %llu\n", rx->dup_packets);
-
-  format (s, "\n");
-  return s;
-}
-
-void
-ioam_seqno_init_data (ioam_seqno_data * data)
-{
-  data->seq_num = 0;
-  ioam_seqno_init_rx_info (&data->seqno_rx);
-  return;
-}
-
-void
-ioam_seqno_init_rx_info (seqno_rx_info * data)
-{
-  seqno_bitmap *bitmap = &data->bitmap;
-  bitmap->window_size = SEQNO_WINDOW_SIZE;
-  bitmap->array_size = SEQNO_WINDOW_ARRAY_SIZE;
-  bitmap->mask = 32 * SEQNO_WINDOW_ARRAY_SIZE - 1;
-  bitmap->array[0] = 0x00000000;	/* pretend we haven seen sequence numbers 0 */
-  bitmap->highest = 0;
-
-  data->dup_packets = 0;
-  data->lost_packets = 0;
-  data->reordered_packets = 0;
-  data->rx_packets = 0;
-  return;
-}
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-e2e/ioam_seqno_lib.h b/ioam/lib-e2e/ioam_seqno_lib.h
deleted file mode 100644
index 31a7431..0000000
--- a/ioam/lib-e2e/ioam_seqno_lib.h
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef PLUGINS_IOAM_PLUGIN_IOAM_LIB_E2E_IOAM_SEQNO_LIB_H_
-#define PLUGINS_IOAM_PLUGIN_IOAM_LIB_E2E_IOAM_SEQNO_LIB_H_
-
-#include <vppinfra/types.h>
-
-#define SEQ_CHECK_VALUE 0x80000000	/* for seq number wraparound detection */
-
-#define SEQNO_WINDOW_SIZE 2048
-#define SEQNO_WINDOW_ARRAY_SIZE 64
-
-typedef struct seqno_bitmap_
-{
-  u32 window_size;
-  u32 array_size;
-  u32 mask;
-  u32 pad;
-  u64 highest;
-  u64 array[SEQNO_WINDOW_ARRAY_SIZE];	/* Will be alloc to array_size */
-} seqno_bitmap;
-
-typedef struct seqno_rx_info_
-{
-  u64 rx_packets;
-  u64 lost_packets;
-  u64 reordered_packets;
-  u64 dup_packets;
-  seqno_bitmap bitmap;
-} seqno_rx_info;
-
-/* This structure is 64-byte aligned */
-typedef struct ioam_seqno_data_
-{
-  union
-  {
-    u32 seq_num;		/* Useful only for encap node */
-    seqno_rx_info seqno_rx;
-  };
-} ioam_seqno_data;
-
-static inline void
-BIT_SET (u64 * p, u32 n)
-{
-  p[n >> 5] |= (1 << (n & 31));
-}
-
-static inline int
-BIT_TEST (u64 * p, u32 n)
-{
-  return p[n >> 5] & (1 << (n & 31));
-}
-
-static void
-BIT_CLEAR (u64 * p, u64 start, int num_bits, u32 mask)
-{
-  int n, t;
-  int start_index = (start >> 5);
-  int mask_index = (mask >> 5);
-
-  start_index &= mask_index;
-  if (start & 0x1f)
-    {
-      int start_bit = (start & 0x1f);
-
-      n = (1 << start_bit) - 1;
-      t = start_bit + num_bits;
-      if (t < 32)
-	{
-	  n |= ~((1 << t) - 1);
-	  p[start_index] &= n;
-	  return;
-	}
-      p[start_index] &= n;
-      start_index = (start_index + 1) & mask_index;
-      num_bits -= (32 - start_bit);
-    }
-  while (num_bits >= 32)
-    {
-      p[start_index] = 0;
-      start_index = (start_index + 1) & mask_index;
-      num_bits -= 32;
-    }
-  n = ~((1 << num_bits) - 1);
-  p[start_index] &= n;
-}
-
-static inline u8
-seqno_check_wraparound (u32 a, u32 b)
-{
-  if ((a != b) && (a > b) && ((a - b) > SEQ_CHECK_VALUE))
-    {
-      return 1;
-    }
-  return 0;
-}
-
-/*
- * Function to analyze the PPC value recevied.
- *     - Updates the bitmap with received sequence number
- *     - counts the received/lost/duplicate/reordered packets
- */
-inline static void
-ioam_analyze_seqno (seqno_rx_info * seqno_rx, u64 seqno)
-{
-  int diff;
-  static int peer_dead_count;
-  seqno_bitmap *bitmap = &seqno_rx->bitmap;
-
-  seqno_rx->rx_packets++;
-
-  if (seqno > bitmap->highest)
-    {				/* new larger sequence number */
-      peer_dead_count = 0;
-      diff = seqno - bitmap->highest;
-      if (diff < bitmap->window_size)
-	{
-	  if (diff > 1)
-	    {			/* diff==1 is *such* a common case it's a win to optimize it */
-	      BIT_CLEAR (bitmap->array, bitmap->highest + 1, diff - 1,
-			 bitmap->mask);
-	      seqno_rx->lost_packets += diff - 1;
-	    }
-	}
-      else
-	{
-	  seqno_rx->lost_packets += diff - 1;
-	  clib_memset (bitmap->array, 0, bitmap->array_size * sizeof (u64));
-	}
-      BIT_SET (bitmap->array, seqno & bitmap->mask);
-      bitmap->highest = seqno;
-      return;
-    }
-
-  /* we've seen a bigger seq number before */
-  diff = bitmap->highest - seqno;
-  if (diff >= bitmap->window_size)
-    {
-      if (seqno_check_wraparound (bitmap->highest, seqno))
-	{
-	  clib_memset (bitmap->array, 0, bitmap->array_size * sizeof (u64));
-	  BIT_SET (bitmap->array, seqno & bitmap->mask);
-	  bitmap->highest = seqno;
-	  return;
-	}
-      else
-	{
-	  peer_dead_count++;
-	  if (peer_dead_count > 25)
-	    {
-	      peer_dead_count = 0;
-	      clib_memset (bitmap->array, 0,
-			   bitmap->array_size * sizeof (u64));
-	      BIT_SET (bitmap->array, seqno & bitmap->mask);
-	      bitmap->highest = seqno;
-	    }
-	  //ppc_rx->reordered_packets++;
-	}
-      return;
-    }
-
-  if (BIT_TEST (bitmap->array, seqno & bitmap->mask))
-    {
-      seqno_rx->dup_packets++;
-      return;			/* Already seen */
-    }
-  seqno_rx->reordered_packets++;
-  seqno_rx->lost_packets--;
-  BIT_SET (bitmap->array, seqno & bitmap->mask);
-  return;
-}
-
-u8 *show_ioam_seqno_analyse_data_fn (u8 * s, seqno_rx_info * rx);
-
-u8 *show_ioam_seqno_cmd_fn (u8 * s, ioam_seqno_data * seqno_data, u8 enc);
-
-void ioam_seqno_init_data (ioam_seqno_data * data);
-
-void ioam_seqno_init_rx_info (seqno_rx_info * data);
-
-#endif /* PLUGINS_IOAM_PLUGIN_IOAM_LIB_E2E_IOAM_SEQNO_LIB_H_ */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-pot/math64.h b/ioam/lib-pot/math64.h
deleted file mode 100644
index 4c608a3..0000000
--- a/ioam/lib-pot/math64.h
+++ /dev/null
@@ -1,159 +0,0 @@
-/* 
- * math64.h provides the 64 bit unsigned integer add, multiply followed by  modulo operation
- * The linux/math64.h provides divide and multiply 64 bit integers but:
- * 1. multiply: mul_u64_u64_shr - only returns 64 bits of the result and has to be called
- *                     twice to get the complete 128 bits of the result.
- * 2. Modulo operation of the result of  addition and multiplication of u64 that may result 
- *                        in integers > 64 bits is not supported
- * Hence this header to combine add/multiply followed by modulo of u64 integrers
- * always resulting in u64.
- * 
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef include_vnet_math64_h
-#define include_vnet_math64_h
-#include <stdint.h>
-
-/* 
- * multiplies and returns result in hi and lo 
- */
-static inline void mul64by64(u64 a, u64 b, u64 * hi, u64 * lo)
-{
-    u64 a_lo = (u64) (uint32_t) a;
-    u64 a_hi = a >> 32;
-    u64 b_lo = (u64) (u32) b;
-    u64 b_hi = b >> 32;
-
-    u64 p0 = a_lo * b_lo;
-    u64 p1 = a_lo * b_hi;
-    u64 p2 = a_hi * b_lo;
-    u64 p3 = a_hi * b_hi;
-
-    u32 cy = (u32) (((p0 >> 32) + (u32) p1 + (u32) p2) >> 32);
-
-    *lo = p0 + (p1 << 32) + (p2 << 32);
-    *hi = p3 + (p1 >> 32) + (p2 >> 32) + cy;
-    return;
-}
-
-#define TWO64 18446744073709551616.0
-
-static inline u64 mod128by64(u64 x, u64 y, u64 m, double di)
-{
-    u64 q1, q2, q;
-    u64 p1, p0;
-    double dq;
-
-    /* calculate quotient first pass 53 bits */
-    dq = (TWO64 * (double)x + (double)y) * di;
-
-    if (dq >= TWO64)
-        q1 = 0xfffffffffffff800L;
-    else
-        q1 = dq;
-
-    /* q1 * m to compare the product to the dividend.  */
-    mul64by64(q1, m, &p1, &p0);
-
-    /* Adjust quotient. is it > actual result: */
-    if (x < p1 || (x == p1 && y < p0))
-    {
-        /* q1 > quotient.  calculate abs remainder */
-        x = p1 - (x + (p0 < y));
-        y = p0 - y;
-
-        /* use the remainder as new dividend to adjust quotient */
-        q2 = (u64) ((TWO64 * (double)x + (double)y) * di);
-        mul64by64(q2, m, &p1, &p0);
-
-        q = q1 - q2;
-        if (x < p1 || (x == p1 && y <= p0))
-        {
-            y = p0 - y;
-        }
-        else
-        {
-            y = p0 - y;
-            y += m;
-            q--;
-        }
-    }
-    else
-    {
-        x = x - (p1 + (y < p0));
-        y = y - p0;
-
-        q2 = (u64) ((TWO64 * (double)x + (double)y) * di);
-        mul64by64(q2, m, &p1, &p0);
-
-        q = q1 + q2;
-        if (x < p1 || (x == p1 && y < p0))
-        {
-            y = y - p0;
-            y += m;
-            q--;
-        }
-        else
-        {
-            y = y - p0;
-            if (y >= m)
-            {
-                y -= m;
-                q++;
-            }
-        }
-    }
-
-    return y;
-}
-
-/* 
- * returns a % p
- */
-static inline u64 mod64by64(u64 a, u64 p, u64 primeinv)
-{
-    return (mod128by64(0, a, p, primeinv));
-}
-
-static inline void add64(u64 a, u64 b, u64 * whi, u64 * wlo)
-{
-    *wlo = a + b;
-    if (*wlo < a)
-        *whi = 1;
-
-}
-
-/* 
- * returns (a + b)%p
- */
-static inline u64 add64_mod(u64 a, u64 b, u64 p, double pi)
-{
-    u64 shi = 0, slo = 0;
-
-    add64(a, b, &shi, &slo);
-    return (mod128by64(shi, slo, p, pi));
-}
-
-/* 
- * returns (ab) % p
- */
-static inline u64 mul64_mod(u64 a, u64 b, u64 p, double pi)
-{
-    u64 phi = 0, plo = 0;
-
-    mul64by64(a, b, &phi, &plo);
-    return (mod128by64(phi, plo, p, pi));
-}
-
-#endif
diff --git a/ioam/lib-pot/pot.api b/ioam/lib-pot/pot.api
deleted file mode 100644
index 18a8f2b..0000000
--- a/ioam/lib-pot/pot.api
+++ /dev/null
@@ -1,100 +0,0 @@
-/* Hey Emacs use -*- mode: C -*- */
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-option version = "1.0.0";
-
-/** \brief Proof of Transit(POT): Set POT profile
-    @param id - id of the profile 
-    @param validator - True/False to indicate if this is verifier
-    @param secret_key - Verification key
-    @param secret_share - Share of the 1st polynomial
-    @param prime - Prime number used for modulo operation
-    @param max_bits - Max bits to be used for Random number generation
-    @param lpc - Lagrange basis polynomial
-    @param polynomial_public - pre-evaluated public polynomial 
-    @param list_name - name of this profile list
-*/
-autoreply define pot_profile_add {
-  u32 client_index;
-  u32 context;
-  u8 id;
-  u8 validator;
-  u64 secret_key;
-  u64 secret_share;
-  u64 prime;
-  u8  max_bits;
-  u64 lpc;
-  u64 polynomial_public;
-  string list_name[];
-};
-
-/** \brief Proof of Transit(POT): Activate POT profile in the list
-    @param id - id of the profile 
-    @param list_name - name of this profile list
-*/
-autoreply define pot_profile_activate {
-  u32 client_index;
-  u32 context;
-  u8 id;
-  string list_name[];
-};
-
-/** \brief Delete POT Profile 
-    @param client_index - opaque cookie to identify the sender
-    @param context - sender context, to match reply w/ request
-    @param list_name - name of profile list to delete
-*/
-autoreply define pot_profile_del {
-  u32 client_index;
-  u32 context;
-  string list_name[];
-};
-
-/** \brief Show POT Profiles
-    @param client_index - opaque cookie to identify the sender
-    @param context - sender context, to match reply w/ request
-    @param id - id of the profile
-*/
-define pot_profile_show_config_dump {
-  u32 client_index;
-  u32 context;
-  u8 id;
-};
-
-/** \brief Show POT profile reply
-    @param id - id of the profile
-    @param validator - True/False to indicate if this is verifier
-    @param secret_key - Verification key
-    @param secret_share - Share of the 1st polynomial
-    @param prime - Prime number used for modulo operation
-    @param max_bits - Max bits to be used for Random number generation
-    @param lpc - Lagrange basis polynomial
-    @param polynomial_public - pre-evaluated public polynomial
-    @param list_name_len - length of the name of this profile list
-    @param list_name - name of this profile list
-*/
-define pot_profile_show_config_details {
-  u32 context;
-  i32 retval;
-  u8 id;
-  u8 validator;
-  u64 secret_key;
-  u64 secret_share;
-  u64 prime;
-  u64 bit_mask;
-  u64 lpc;
-  u64 polynomial_public;
-};
diff --git a/ioam/lib-pot/pot_api.c b/ioam/lib-pot/pot_api.c
deleted file mode 100644
index 72d05d7..0000000
--- a/ioam/lib-pot/pot_api.c
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- *------------------------------------------------------------------
- * pot_api.c - Proof of Transit related APIs to create
- *             and maintain profiles
- *------------------------------------------------------------------
- */
-
-#include <vnet/vnet.h>
-#include <vnet/plugin/plugin.h>
-#include <ioam/lib-pot/pot_util.h>
-
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-
-/* define message IDs */
-#include <ioam/lib-pot/pot.api_enum.h>
-#include <ioam/lib-pot/pot.api_types.h>
-
-#define REPLY_MSG_ID_BASE sm->msg_id_base
-#include <vlibapi/api_helper_macros.h>
-
-static void vl_api_pot_profile_add_t_handler
-(vl_api_pot_profile_add_t *mp)
-{
-    pot_main_t * sm = &pot_main;
-    int rv = 0;
-    vl_api_pot_profile_add_reply_t * rmp;
-    u8 id;
-    pot_profile *profile = NULL;
-    u8 *name = 0;
-
-    name = vl_api_from_api_to_new_vec(mp, &mp->list_name);
-
-    pot_profile_list_init(name);
-    id = mp->id;
-    profile = pot_profile_find(id);
-    if (profile) {
-	rv = pot_profile_create(profile,
-				clib_net_to_host_u64(mp->prime),
-				clib_net_to_host_u64(mp->polynomial_public),
-				clib_net_to_host_u64(mp->lpc),
-				clib_net_to_host_u64(mp->secret_share));
-	if (rv != 0)
-            goto ERROROUT;
-	if (1 == mp->validator)
-	  (void)pot_set_validator(profile, clib_net_to_host_u64(mp->secret_key));
-        (void)pot_profile_set_bit_mask(profile, mp->max_bits);
-    } else {
-        rv = -3;
-    }
- ERROROUT:
-    vec_free(name);
-    REPLY_MACRO(VL_API_POT_PROFILE_ADD_REPLY);
-}
-
-static void send_pot_profile_details(vl_api_pot_profile_show_config_dump_t *mp, u8 id)
-{
-    vl_api_pot_profile_show_config_details_t * rmp;
-    pot_main_t * sm = &pot_main;
-    pot_profile *profile = pot_profile_find(id);
-    int rv = 0;
-    if(profile){
-        REPLY_MACRO2(VL_API_POT_PROFILE_SHOW_CONFIG_DETAILS,
-			rmp->id=id;
-			rmp->validator=profile->validator;
-			rmp->secret_key=clib_host_to_net_u64(profile->secret_key);
-			rmp->secret_share=clib_host_to_net_u64(profile->secret_share);
-			rmp->prime=clib_host_to_net_u64(profile->prime);
-			rmp->bit_mask=clib_host_to_net_u64(profile->bit_mask);
-			rmp->lpc=clib_host_to_net_u64(profile->lpc);
-			rmp->polynomial_public=clib_host_to_net_u64(profile->poly_pre_eval);
-			);
-    }
-    else{
-        REPLY_MACRO2(VL_API_POT_PROFILE_SHOW_CONFIG_DETAILS,
-			rmp->id=id;
-			rmp->validator=0;
-			rmp->secret_key=0;
-			rmp->secret_share=0;
-			rmp->prime=0;
-			rmp->bit_mask=0;
-			rmp->lpc=0;
-			rmp->polynomial_public=0;
-			);
-    }
-}
-
-static void vl_api_pot_profile_show_config_dump_t_handler
-(vl_api_pot_profile_show_config_dump_t *mp)
-{
-    u8 id = mp->id;
-    u8 dump_call_id = ~0;
-    if(dump_call_id==id){
-        for(id=0;id<MAX_POT_PROFILES;id++)
-	    send_pot_profile_details(mp,id);
-    }
-    else
-        send_pot_profile_details(mp,id);
-}
-
-static void vl_api_pot_profile_activate_t_handler
-(vl_api_pot_profile_activate_t *mp)
-{
-    pot_main_t * sm = &pot_main;
-    int rv = 0;
-    vl_api_pot_profile_add_reply_t * rmp;
-    u8 id;
-    u8 *name = NULL;
-
-    name = vl_api_from_api_to_new_vec(mp, &mp->list_name);
-    if (!pot_profile_list_is_enabled(name)) {
-        rv = -1;
-    } else {
-        id = mp->id;
-	rv = pot_profile_set_active(id);
-    }
-
-    vec_free(name);
-    REPLY_MACRO(VL_API_POT_PROFILE_ACTIVATE_REPLY);
-}
-
-
-static void vl_api_pot_profile_del_t_handler
-(vl_api_pot_profile_del_t *mp)
-{
-    pot_main_t * sm = &pot_main;
-    int rv = 0;
-    vl_api_pot_profile_del_reply_t * rmp;
-
-    clear_pot_profiles();
-
-    REPLY_MACRO(VL_API_POT_PROFILE_DEL_REPLY);
-}
-
-#include <ioam/lib-pot/pot.api.c>
-static clib_error_t * pot_init (vlib_main_t * vm)
-{
-  pot_main_t * sm = &pot_main;
-
-  bzero(sm, sizeof(pot_main));
-  (void)pot_util_init();
-
-  sm->vlib_main = vm;
-  sm->vnet_main = vnet_get_main();
-
-  /* Ask for a correctly-sized block of API message decode slots */
-  sm->msg_id_base = setup_message_id_table ();
-
-  return 0;
-}
-
-VLIB_INIT_FUNCTION (pot_init);
diff --git a/ioam/lib-pot/pot_test.c b/ioam/lib-pot/pot_test.c
deleted file mode 100644
index b30b21e..0000000
--- a/ioam/lib-pot/pot_test.c
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- *------------------------------------------------------------------
- * pot_test.c - test harness for pot plugin
- *------------------------------------------------------------------
- */
-
-#include <vat/vat.h>
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-
-#include <vppinfra/error.h>
-
-#define __plugin_msg_base pot_test_main.msg_id_base
-#include <vlibapi/vat_helper_macros.h>
-
-/* Declare message IDs */
-#include <ioam/lib-pot/pot.api_enum.h>
-#include <ioam/lib-pot/pot.api_types.h>
-
-typedef struct {
-    /* API message ID base */
-    u16 msg_id_base;
-    vat_main_t *vat_main;
-} pot_test_main_t;
-
-pot_test_main_t pot_test_main;
-
-static int api_pot_profile_add (vat_main_t *vam)
-{
-#define MAX_BITS 64
-    unformat_input_t *input = vam->input;
-    vl_api_pot_profile_add_t *mp;
-    u8 *name = NULL;
-    u64 prime = 0;
-    u64 secret_share = 0;
-    u64 secret_key = 0;
-    u32  bits = MAX_BITS;
-    u64 lpc = 0, poly2 = 0;
-    u8 id = 0;
-    int rv = 0;
-    int ret;
-
-    while (unformat_check_input(input) != UNFORMAT_END_OF_INPUT)
-      {
-        if (unformat(input, "name %s", &name))
-	  ;
-	else if(unformat(input, "id %d", &id))
-	  ;
-        else if (unformat(input, "validator-key 0x%Lx", &secret_key))
-          ;
-        else if (unformat(input, "prime-number 0x%Lx", &prime))
-          ;
-        else if (unformat(input, "secret-share 0x%Lx", &secret_share))
-          ;
-        else if (unformat(input, "polynomial-public 0x%Lx", &poly2))
-          ;
-        else if (unformat(input, "lpc 0x%Lx", &lpc))
-          ;
-        else if (unformat(input, "bits-in-random %u", &bits))
-	  {
-	    if (bits > MAX_BITS)
-	      bits = MAX_BITS;
-	  }
-        else
-  	break;
-      }
-
-    if (!name)
-      {
-        errmsg ("name required\n");
-        rv = -99;
-        goto OUT;
-      }
-
-    M2(POT_PROFILE_ADD, mp, sizeof(vl_api_string_t) + vec_len(name));
-
-    vl_api_vec_to_api_string(name, &mp->list_name);
-    mp->secret_share = clib_host_to_net_u64(secret_share);
-    mp->polynomial_public = clib_host_to_net_u64(poly2);
-    mp->lpc = clib_host_to_net_u64(lpc);
-    mp->prime = clib_host_to_net_u64(prime);
-    if (secret_key != 0)
-      {
-        mp->secret_key = clib_host_to_net_u64(secret_key);
-        mp->validator = 1;
-      }
-    else
-      {
-	mp->validator = 0;
-      }
-    mp->id = id;
-    mp->max_bits = bits;
-
-    S(mp);
-    W (ret);
-    return ret;
-
-OUT:
-    vec_free(name);
-    return(rv);
-}
-
-static int api_pot_profile_activate (vat_main_t *vam)
-{
-#define MAX_BITS 64
-    unformat_input_t *input = vam->input;
-    vl_api_pot_profile_activate_t *mp;
-    u8 *name = NULL;
-    u8 id = 0;
-    int rv = 0;
-    int ret;
-
-    while (unformat_check_input(input) != UNFORMAT_END_OF_INPUT)
-      {
-        if (unformat(input, "name %s", &name))
-	  ;
-	else if(unformat(input, "id %d", &id))
-	  ;
-        else
-  	break;
-      }
-
-    if (!name)
-      {
-        errmsg ("name required\n");
-        rv = -99;
-        goto OUT;
-      }
-
-    M2(POT_PROFILE_ACTIVATE, mp, sizeof(vl_api_string_t) + vec_len(name));
-    vl_api_vec_to_api_string(name, &mp->list_name);
-    mp->id = id;
-
-    S(mp);
-    W (ret);
-    return ret;
-
-OUT:
-    vec_free(name);
-    return(rv);
-}
-
-
-static int api_pot_profile_del (vat_main_t *vam)
-{
-    vl_api_pot_profile_del_t *mp;
-    int ret;
-
-    M(POT_PROFILE_DEL, mp);
-    S(mp);
-    W (ret);
-    return ret;
-}
-
-static int api_pot_profile_show_config_dump (vat_main_t *vam)
-{
-    unformat_input_t *input = vam->input;
-    vl_api_pot_profile_show_config_dump_t *mp;
-    u8 id = 0;
-    int ret;
-
-    while(unformat_check_input(input) != UNFORMAT_END_OF_INPUT)
-    {
-      if(unformat(input,"id %d",&id));
-      else
-        break;
-    }
-    M(POT_PROFILE_SHOW_CONFIG_DUMP, mp);
-
-    mp->id = id;
-
-    S(mp);
-    W (ret);
-    return ret;
-}
-static int vl_api_pot_profile_show_config_details_t_handler (vat_main_t *vam)
-{
-  return -1;
-}
-
-/* Override generated plugin register symbol */
-#define vat_plugin_register pot_vat_plugin_register
-#include <ioam/lib-pot/pot.api_test.c>
diff --git a/ioam/lib-pot/pot_util.c b/ioam/lib-pot/pot_util.c
deleted file mode 100644
index 2fe9ce9..0000000
--- a/ioam/lib-pot/pot_util.c
+++ /dev/null
@@ -1,445 +0,0 @@
-/* 
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <vnet/vnet.h>
-#include <stdint.h>
-#include <time.h>
-#include <string.h>
-#include <vppinfra/mem.h>
-#include "math64.h"
-#include "pot_util.h"
-
-pot_main_t pot_main;
-
-static void pot_profile_cleanup(pot_profile *profile);
-
-static void pot_main_profiles_reset (void)
-{
-    pot_main_t *sm = &pot_main;
-    int i = 0;
-
-    for (i = 0; i < MAX_POT_PROFILES; i++)
-    {
-      pot_profile_cleanup(&(sm->profile_list[i]));
-    }
-    sm->active_profile_id = 0;
-    if (sm->profile_list_name)
-	vec_free(sm->profile_list_name);
-    sm->profile_list_name = NULL;
-}
-
-int pot_util_init (void)
-{
-    pot_main_profiles_reset();
-    
-    return(0);
-}
-
-static void pot_profile_init(pot_profile * new, u8 id)
-{
-    if (new)
-    {
-        clib_memset(new, 0, sizeof(pot_profile));
-        new->id = id;
-    }
-}
-
-pot_profile *pot_profile_find(u8 id)
-{
-    pot_main_t *sm = &pot_main;
-
-    if (id < MAX_POT_PROFILES)
-    {
-        return (&(sm->profile_list[id]));
-    }
-    return (NULL);
-}
-static int pot_profile_name_equal (u8 *name0, u8 *name1)
-{
-    int len0, len1;
-
-    len0 = vec_len (name0);
-    len1 = vec_len (name1);
-    if (len0 != len1)
-        return(0);
-    return (0==strncmp ((char *) name0, (char *)name1, len0));
-}
-
-int pot_profile_list_is_enabled (u8 *name)
-{
-    pot_main_t *sm = &pot_main;
-    return (pot_profile_name_equal(sm->profile_list_name, name));
-}
-
-void pot_profile_list_init(u8 * profile_list_name)
-{
-    pot_main_t *sm = &pot_main;
-    int i = 0;
-
-    /* If it is the same profile list skip reset */
-    if (pot_profile_name_equal(sm->profile_list_name, profile_list_name))
-    {
-      return;
-    }
-
-    pot_main_profiles_reset();
-    if (vec_len(profile_list_name))
-      sm->profile_list_name = (u8 *)vec_dup(profile_list_name);
-    else
-      sm->profile_list_name = 0;
-    sm->active_profile_id = 0;
-    
-    for (i = 0; i < MAX_POT_PROFILES; i++)
-    {
-      pot_profile_init(&(sm->profile_list[i]), i);
-    }
-}
-
-static void pot_profile_cleanup(pot_profile * profile)
-{
-    u16 id = profile->id;
-
-    clib_memset(profile, 0, sizeof(pot_profile));
-    profile->id = id;           /* Restore id alone */
-}
-
-int pot_profile_create(pot_profile * profile, u64 prime,
-    u64 poly2, u64 lpc, u64 secret_share)
-{
-    if (profile && !profile->in_use)
-    {
-        pot_profile_cleanup(profile);
-        profile->prime = prime;
-        profile->primeinv = 1.0 / prime;
-        profile->lpc = lpc;
-        profile->poly_pre_eval = poly2;
-        profile->secret_share = secret_share;
-	profile->total_pkts_using_this_profile = 0;
-        profile->valid = 1;
-	return(0);
-    }
-    
-    return(-1);
-}
-
-int pot_set_validator(pot_profile * profile, u64 key)
-{
-    if (profile && !profile->in_use)
-    {
-        profile->validator = 1;
-        profile->secret_key = key;
-	return(0);
-    }
-    return(-1);
-}
-
-always_inline u64 pot_update_cumulative_inline(u64 cumulative, u64 random,
-    u64 secret_share, u64 prime, u64 lpc, u64 pre_split, double prime_inv)
-{
-    u64 share_random = 0;
-    u64 cumulative_new = 0;
-
-    /* 
-     * calculate split share for random
-     */
-    share_random = add64_mod(pre_split, random, prime, prime_inv);
-
-    /* 
-     * lpc * (share_secret + share_random)
-     */
-    share_random = add64_mod(share_random, secret_share, prime, prime_inv);
-    share_random = mul64_mod(share_random, lpc, prime, prime_inv);
-
-    cumulative_new = add64_mod(cumulative, share_random, prime, prime_inv);
-
-    return (cumulative_new);
-}
-
-u64 pot_update_cumulative(pot_profile * profile, u64 cumulative, u64 random)
-{
-    if (profile && profile->valid != 0)
-    {
-        return (pot_update_cumulative_inline(cumulative, random, profile->secret_share,
-                profile->prime, profile->lpc, profile->poly_pre_eval,
-                profile->primeinv));
-    }
-    return (0);
-}
-
-always_inline u8 pot_validate_inline(u64 secret, u64 prime, double prime_inv,
-    u64 cumulative, u64 random)
-{
-    if (cumulative == (random + secret))
-    {
-        return (1);
-    }
-    else if (cumulative == add64_mod(random, secret, prime, prime_inv))
-    {
-        return (1);
-    }
-    return (0);
-}
-
-/* 
- * return True if the cumulative matches secret from a profile
- */
-u8 pot_validate(pot_profile * profile, u64 cumulative, u64 random)
-{
-    if (profile && profile->validator)
-    {
-        return (pot_validate_inline(profile->secret_key, profile->prime,
-                profile->primeinv, cumulative, random));
-    }
-    return (0);
-}
-
-/* 
- * Utility function to get random number per pack
- */
-u64 pot_generate_random(pot_profile * profile)
-{
-    u64 random = 0;
-    int32_t second_half;
-    static u32 seed = 0;
-
-    if (PREDICT_FALSE(!seed))
-        seed = random_default_seed();
-
-    /* 
-     * Upper 4 bytes seconds
-     */
-    random = (u64) time(NULL);
-
-    random &= 0xffffffff;
-    random = random << 32;
-    /* 
-     * Lower 4 bytes random number
-     */
-    second_half = random_u32(&seed);
-
-    random |= second_half;
-
-    if (PREDICT_TRUE(profile != NULL))
-    {
-        random &= profile->bit_mask;
-    }
-    return (random);
-}
-
-int pot_profile_set_bit_mask(pot_profile * profile, u16 bits)
-{
-    int sizeInBits;
-
-    if (profile && !profile->in_use)
-    {
-        sizeInBits = sizeof(profile->bit_mask) * 8;
-        profile->bit_mask =
-            (bits >=
-            sizeInBits ? (u64) - 1 : (u64) ((u64) 1 << (u64) bits) - 1);
-	return(0);
-    }
-    return(-1);
-}
-
-clib_error_t *clear_pot_profile_command_fn(vlib_main_t * vm,
-    unformat_input_t * input, vlib_cli_command_t * cmd)
-{
-
-    pot_main_profiles_reset();
-    
-    return 0;
-}
-
-void clear_pot_profiles()
-{
-    clear_pot_profile_command_fn(0, 0, 0);
-}
-
-VLIB_CLI_COMMAND(clear_pot_profile_command) =
-{
-.path = "clear pot profile",
-.short_help = "clear pot profile [<index>|all]",
-.function = clear_pot_profile_command_fn,
-};
-
-static clib_error_t *set_pot_profile_command_fn(vlib_main_t * vm,
-    unformat_input_t * input, vlib_cli_command_t * cmd)
-{
-    u64 prime;
-    u64 secret_share;
-    u64 secret_key;
-    u8 validator = 0;
-    u32 profile_id = ~0;
-    u32 bits;
-    u64 lpc = 0, poly2 = 0;
-    pot_profile *profile = NULL;
-    u8 *profile_list_name = NULL;
-    
-    bits = MAX_BITS;
-
-    while (unformat_check_input(input) != UNFORMAT_END_OF_INPUT)
-    {
-        if (unformat(input, "name %s",
-		     &profile_list_name));
-        else if (unformat(input, "id %d", &profile_id))
-            ;
-        else if (unformat(input, "validate-key 0x%Lx", &secret_key))
-            validator = 1;
-        else if (unformat(input, "prime-number 0x%Lx", &prime))
-            ;
-        else if (unformat(input, "secret_share 0x%Lx", &secret_share))
-            ;
-        else if (unformat(input, "polynomial2 0x%Lx", &poly2))
-            ;
-        else if (unformat(input, "lpc 0x%Lx", &lpc))
-            ;
-        else if (unformat(input, "bits-in-random %d", &bits))
-        {
-            if (bits > MAX_BITS)
-                bits = MAX_BITS;
-        }
-        else
-	  break;
-    }
-    if (profile_list_name == 0)
-    {
-        return clib_error_return(0, "Name cannot be null");
-    }	
-    pot_profile_list_init(profile_list_name);
-    profile = pot_profile_find(profile_id);
-
-    if (profile)
-    {
-        pot_profile_create(profile, prime, poly2, lpc, secret_share);
-        if (validator)
-            pot_set_validator(profile, secret_key);
-        pot_profile_set_bit_mask(profile, bits);
-    }
-    vec_free(profile_list_name);
-    return 0;
-}
-
-VLIB_CLI_COMMAND(set_pot_profile_command) =
-{
-.path = "set pot profile",
-.short_help = "set pot profile name <string> id [0-1] [validator-key 0xu64] \
-                  prime-number 0xu64 secret_share 0xu64 lpc 0xu64 \
-                  polynomial2 0xu64 bits-in-random [0-64] ",
-.function = set_pot_profile_command_fn,
-};
-
-static clib_error_t *set_pot_profile_activate_command_fn(vlib_main_t * vm,
-    unformat_input_t * input, vlib_cli_command_t * cmd)
-{
-    pot_main_t *sm = &pot_main;
-    u8 *profile_list_name = NULL;
-    u32 id = 0;
-    clib_error_t *result = NULL;
-    
-    while (unformat_check_input(input) != UNFORMAT_END_OF_INPUT)
-    {
-        if (unformat(input, "name %s",
-		     &profile_list_name));
-        else if (unformat(input, "id %d", &id))
-            ;
-        else
-            return clib_error_return(0, "unknown input `%U'",
-                format_unformat_error, input);
-    }
-    if (profile_list_name == 0)
-    {
-        return clib_error_return(0, "Name cannot be null");
-    }
-
-    if (!pot_profile_list_is_enabled(profile_list_name)) {
-        result = clib_error_return(0, "%s list is not enabled, profile in use %s",
-				 profile_list_name, sm->profile_list_name);
-    } else if (0 != pot_profile_set_active((u8)id)) {
-        result = clib_error_return(0, "Profile %d not defined in %s",
-				 id, sm->profile_list_name);
-    }
-    vec_free(profile_list_name);
-    return result;
-}
-
-VLIB_CLI_COMMAND(set_pot_profile_activate_command) =
-{
-.path = "set pot profile-active",
-.short_help = "set pot profile-active name <string> id [0-1]",
-.function = set_pot_profile_activate_command_fn,
-};
-
-static clib_error_t *show_pot_profile_command_fn(vlib_main_t * vm,
-    unformat_input_t * input, vlib_cli_command_t * cmd)
-{
-    pot_main_t *sm = &pot_main;
-    pot_profile *p = NULL;
-    u16 i;
-    u8 *s = 0;
-
-    if (vec_len(sm->profile_list_name) == 0)
-    {
-        s = format(s, "POT Profiles not configured\n");
-        vlib_cli_output(vm, "%v", s);
-        return 0;
-    }
-    s = format(s, "Profile list in use  : %s\n",sm->profile_list_name);
-    for (i = 0; i < MAX_POT_PROFILES; i++)
-    {
-        p = pot_profile_find(i);
-        if (p->valid == 0)
-            continue;
-        s = format(s, "POT Profile at index: %d\n", i);
-        s = format(s, "                 Id : %d\n", p->id);
-        s = format(s, "          Validator : %s (%d)\n",
-            (p->validator) ? "True" : "False", p->validator);
-        if (p->validator == 1)
-            s = format(s, "         Secret key : 0x%Lx (%Ld)\n",
-                p->secret_key, p->secret_key);
-        s = format(s, "       Secret share : 0x%Lx (%Ld)\n",
-            p->secret_share, p->secret_share);
-        s = format(s, "       Prime number : 0x%Lx (%Ld)\n",
-            p->prime, p->prime);
-        s = format(s, "2nd polynomial(eval) : 0x%Lx (%Ld)\n",
-            p->poly_pre_eval, p->poly_pre_eval);
-        s = format(s, "                 LPC : 0x%Lx (%Ld)\n", p->lpc, p->lpc);
-
-        s = format(s, "           Bit mask : 0x%Lx (%Ld)\n",
-            p->bit_mask, p->bit_mask);
-    }
-
-    p = pot_profile_find(sm->active_profile_id);
-
-    if (p && p->valid && p->in_use) {
-        s = format(s, "\nProfile index in use: %d\n", sm->active_profile_id);
-        s = format(s, "Pkts passed : 0x%Lx (%Ld)\n",
-		   p->total_pkts_using_this_profile,
-		   p->total_pkts_using_this_profile);
-        if (pot_is_decap(p))
-            s = format(s, "  This is Decap node.  \n");
-    } else {
-        s = format(s, "\nProfile index in use: None\n");
-    }
-    vlib_cli_output(vm, "%v", s);
-    vec_free(s);
-
-    return 0;
-}
-
-VLIB_CLI_COMMAND(show_pot_profile_command) =
-{
-.path = "show pot profile",
-.short_help = "show pot profile",
-.function = show_pot_profile_command_fn,
-};
diff --git a/ioam/lib-pot/pot_util.h b/ioam/lib-pot/pot_util.h
deleted file mode 100644
index 9df31fa..0000000
--- a/ioam/lib-pot/pot_util.h
+++ /dev/null
@@ -1,195 +0,0 @@
-/* 
- * pot_util.h -- Proof Of Transit Utility Header
- *
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef include_vnet_pot_util_h
-#define include_vnet_pot_util_h
-
-#include <vnet/ip/ip6_hop_by_hop.h>
-#define debug_ioam debug_ioam_fn
-/* Dont change this size 256. This is there across multiple components */
-#define PATH_NAME_SIZE  256
-
-/* Ring size. this should be same as the one in ODL. Do not change this
-   without change in ODL. */
-#define MAX_POT_PROFILES 2
-
-/**
- * Usage:
- * 
- * On any node that participates in Proof of Transit:
- *
- * Step 1: Initialize this library by calling pot_init()
- * Step 2: Setup a proof of transit  profile that contains all the parameters needed to compute cumulative:
- *         Call these functions:
- *         pot_profile_find
- *         pot_profile_create
- *         pot_profile_set_bit_mask - To setup how large we want the numbers used in the computation and random number <= 64 bits
- * Step 2a: For validator do this:
- *          pot_set_validator
- * Step 2b: On initial node enable the profile to be used:
- *          pot_profile_set_active / pot_profile_get_active will return the profile
- * Step 3a: At the initial node to generate Random number that will be read by all other nodes:
- *          pot_generate_random
- * Step 3b: At all nodes including initial and verifier call this to compute cumulative:
- *          pot_update_cumulative
- * Step 4: At the verifier:
- *         pot_validate
- * 
- */
-
-typedef struct pot_profile_
-{
-    u8 id : 1;
-    u8 valid : 1;
-    u8 in_use : 1;
-    u64 random;
-    u8 validator;
-    u64 secret_key;
-    u64 secret_share;
-    u64 prime;
-    u64 lpc;
-    u64 poly_pre_eval;
-    u64 bit_mask;
-    u64 limit;
-    double primeinv;
-    u64 total_pkts_using_this_profile;
-} pot_profile;
-
-typedef struct {
-    /* Name of the default profile list in use*/
-    u8 *profile_list_name;
-    pot_profile profile_list[MAX_POT_PROFILES];
-    /* number of profiles in the list */
-    u8 active_profile_id : 1;
-
-    /* API message ID base */
-    u16 msg_id_base;
-
-    /* convenience */
-    vlib_main_t * vlib_main;
-    vnet_main_t * vnet_main;
-} pot_main_t;
-
-extern pot_main_t pot_main;
-
-/* 
- * Initialize proof of transit
- */
-int pot_util_init(void);
-void pot_profile_list_init(u8 * name);
-
-
-/* 
- * Find a pot profile by ID
- */
-pot_profile *pot_profile_find(u8 id);
-
-static inline u16 pot_profile_get_id(pot_profile * profile)
-{
-    if (profile)
-    {
-        return (profile->id);
-    }
-    return (0);
-}
-
-/* setup and clean up profile */
-int pot_profile_create(pot_profile * profile, u64 prime,
-    u64 poly2, u64 lpc, u64 secret_share);
-/* 
- * Setup profile as a validator
- */
-int pot_set_validator(pot_profile * profile, u64 key);
-
-/* 
- * Setup max bits to be used for random number generation
- */
-#define MAX_BITS 64
-int pot_profile_set_bit_mask(pot_profile * profile, u16 bits);
-
-/* 
- * Given a random and cumulative compute the new cumulative for a given profile
- */
-u64 pot_update_cumulative(pot_profile * profile, u64 cumulative, u64 random);
-
-/* 
- * return True if the cumulative matches secret from a profile
- */
-u8 pot_validate(pot_profile * profile, u64 cumulative, u64 random);
-
-/* 
- * Utility function to get random number per pack
- */
-u64 pot_generate_random(pot_profile * profile);
-
-
-extern void clear_pot_profiles();
-extern int pot_profile_list_is_enabled(u8 *name);
-
-static inline u8 pot_is_decap(pot_profile * p)
-{
-    return (p->validator == 1);
-}
-
-static inline int pot_profile_set_active (u8 id)
-{
-    pot_main_t *sm = &pot_main;
-    pot_profile *profile = NULL;
-    pot_profile *current_active_prof = NULL;
-
-    current_active_prof = pot_profile_find(sm->active_profile_id);
-    profile = pot_profile_find(id);
-    if (profile && profile->valid) {
-        sm->active_profile_id = id;
-	current_active_prof->in_use = 0;
-	profile->in_use = 1;
-	return(0);
-    }
-    return(-1);
-}
-static inline u8 pot_profile_get_active_id (void)
-{
-    pot_main_t *sm = &pot_main;
-    return (sm->active_profile_id);
-}
-
-static inline pot_profile * pot_profile_get_active (void)
-{
-    pot_main_t *sm = &pot_main;
-    pot_profile *profile = NULL;
-    profile = pot_profile_find(sm->active_profile_id);
-    if (profile && profile->in_use)
-        return(profile);
-    return (NULL);
-}
-
-static inline void pot_profile_reset_usage_stats (pot_profile *pow)
-{
-  if (pow) {
-    pow->total_pkts_using_this_profile = 0;
-  }
-}
-
-static inline void pot_profile_incr_usage_stats (pot_profile *pow)
-{
-  if (pow) {
-    pow->total_pkts_using_this_profile++;
-  }
-}
-
-
-#endif
diff --git a/ioam/lib-trace/trace.api b/ioam/lib-trace/trace.api
deleted file mode 100644
index 7354196..0000000
--- a/ioam/lib-trace/trace.api
+++ /dev/null
@@ -1,87 +0,0 @@
-/* Hey Emacs use -*- mode: C -*- */
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-option version = "1.0.0";
-
-/** \brief iOAM6 Trace - Set the iOAM6 trace profile
-    @param trace_type - Type of trace requested
-    @param num_elts - Number of trace elements to be inserted
-    @param node_id - Trace Node ID
-    @param trace_tsp- Timestamp resolution
-    @param app_data - Application specific opaque
-*/
-autoreply define trace_profile_add {
-  u32 client_index;
-  u32 context;
-  u16 namespace_id;
-  u8 num_elts;
-  u32 node_id_short;
-  u64 node_id_wide;
-  u32 app_data_short;
-  u64 app_data_wide;
-  u8 option_type;
-  u32 trace_type;
-  u8 node_type;
-  u8 ts_format;
-  u8 queue_depth_type;
-  u8 opaque_len;
-  u32 opaque_id;
-};
-
-/** \brief Delete trace Profile
-    @param client_index - opaque cookie to identify the sender
-    @param context - sender context, to match reply w/ request
-*/
-autoreply define trace_profile_del {
-  u32 client_index;
-  u32 context;
-};
-
-/** \brief Show trace Profile
-    @param client_index - opaque cookie to identify the sender
-    @param context - sender context, to match reply w/ request
-*/
-define trace_profile_show_config {
-  u32 client_index;
-  u32 context;
-};
-
-/** \brief Show trace config response
-    @param context - sender context, to match reply w/ request
-    @param retval - return value for request
-    @param trace_type - Type of trace requested
-    @param num_elts - Number of trace elements to be inserted
-    @param node_id - Trace Node ID
-    @param trace_tsp- Timestamp resolution
-    @param app_data - Application specific opaque
-*/
-define trace_profile_show_config_reply {
-  u32 context;
-  i32 retval;
-  u16 namespace_id;
-  u8 num_elts;
-  u32 node_id_short;
-  u64 node_id_wide;
-  u32 app_data_short;
-  u64 app_data_wide;
-  u8 option_type;
-  u32 trace_type;
-  u8 node_type;
-  u8 ts_format;
-  u8 queue_depth_type;
-  u8 opaque_len;
-  u32 opaque_id;
-};
diff --git a/ioam/lib-trace/trace_api.c b/ioam/lib-trace/trace_api.c
deleted file mode 100644
index 6c0340d..0000000
--- a/ioam/lib-trace/trace_api.c
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- *------------------------------------------------------------------
- * trace_api.c - iOAM Trace related APIs to create
- *               and maintain profiles
- *------------------------------------------------------------------
- */
-
-#include <vnet/vnet.h>
-#include <vnet/plugin/plugin.h>
-#include <ioam/lib-trace/trace_util.h>
-#include <ioam/lib-trace/trace_config.h>
-#include <vlibapi/api_helper_macros.h>
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-
-/* define message IDs */
-#include <ioam/lib-trace/trace.api_enum.h>
-#include <ioam/lib-trace/trace.api_types.h>
-
-static void vl_api_trace_profile_add_t_handler (vl_api_trace_profile_add_t * mp)
-{
-  /* stuff required for each API function */
-  int rv = 0;
-  vl_api_trace_profile_add_reply_t *rmp;
-
-  /* stuff specific to the trace_profile_add API function */
-  trace_profile *profile = NULL;
-  trace_profile tmp;
-  profile = trace_profile_find ();
-  if (profile)
-  {
-    tmp.namespace_id = mp->namespace_id;
-    tmp.num_elts = mp->num_elts;
-    tmp.node_id_short = ntohl(mp->node_id_short);
-    tmp.node_id_wide = ntohll64(mp->node_id_wide);
-    tmp.app_data_short = ntohl(mp->app_data_short);
-    tmp.app_data_wide = ntohll64(mp->app_data_wide);
-    tmp.option_type = mp->option_type;
-    tmp.trace_type = mp->trace_type;
-    tmp.node_type = mp->node_type;
-    tmp.ts_format = mp->ts_format;
-    tmp.queue_depth_type = mp->queue_depth_type;
-    tmp.opaque.len_schemeid = IOAM_SET_OPAQUE_HEADER(mp->opaque_len, mp->opaque_id);
-    rv = trace_profile_create (profile, &tmp);
-    if (rv != 0) {
-      goto ERROROUT;
-    }
-  }
-  else
-  {
-    rv = -3;
-  }
-  ERROROUT:
-    REPLY_MACRO (VL_API_TRACE_PROFILE_ADD_REPLY);
-}
-
-
-static void vl_api_trace_profile_del_t_handler (vl_api_trace_profile_del_t * mp)
-{
-  int rv = 0;
-  vl_api_trace_profile_del_reply_t *rmp;
-
-  clear_trace_profiles ();
-
-  REPLY_MACRO (VL_API_TRACE_PROFILE_DEL_REPLY);
-}
-
-static void vl_api_trace_profile_show_config_t_handler (vl_api_trace_profile_show_config_t * mp)
-{
-  vl_api_trace_profile_show_config_reply_t *rmp;
-  int rv = 0;
-  trace_profile *profile = trace_profile_find ();
-
-  if (profile->valid)
-  {
-    REPLY_MACRO2 (VL_API_TRACE_PROFILE_SHOW_CONFIG_REPLY,
-      rmp->namespace_id = profile->namespace_id;
-      rmp->num_elts = profile->num_elts;
-      rmp->node_id_short = htonl(profile->node_id_short);
-      rmp->node_id_wide = htonll64(profile->node_id_wide);
-      rmp->app_data_short = htonl(profile->app_data_short);
-      rmp->app_data_wide = htonll64(profile->app_data_wide);
-      rmp->option_type = profile->option_type;
-      rmp->trace_type = profile->trace_type;
-      rmp->node_type = profile->node_type;
-      rmp->ts_format = profile->ts_format;
-      rmp->queue_depth_type = profile->queue_depth_type;
-      rmp->opaque_len = IOAM_GET_OPAQUE_LEN(profile->opaque.len_schemeid);
-      rmp->opaque_id = IOAM_OPAQUE_SCHEMEID_MASK & profile->opaque.len_schemeid;
-    );
-  }
-  else
-  {
-    REPLY_MACRO2 (VL_API_TRACE_PROFILE_SHOW_CONFIG_REPLY,
-      rmp->namespace_id = 0;
-      rmp->num_elts = 0;
-      rmp->node_id_short = 0;
-      rmp->node_id_wide = 0;
-      rmp->app_data_short = 0;
-      rmp->app_data_wide = 0;
-      rmp->option_type = 0;
-      rmp->trace_type = 0;
-      rmp->node_type = 0;
-      rmp->ts_format = 0;
-      rmp->queue_depth_type = 0;
-      rmp->opaque_len = 0;
-      rmp->opaque_id = 0;
-    );
-  }
-}
-
-#include <ioam/lib-trace/trace.api.c>
-static clib_error_t *
-trace_init (vlib_main_t * vm)
-{
-  trace_main_t *sm = &trace_main;
-  bzero (sm, sizeof (trace_main));
-  (void) trace_util_init ();
-
-  sm->vlib_main = vm;
-  sm->vnet_main = vnet_get_main ();
-
-  /* Ask for a correctly-sized block of API message decode slots */
-  sm->msg_id_base = setup_message_id_table ();
-
-  return 0;
-}
-
-VLIB_INIT_FUNCTION (trace_init);
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-trace/trace_config.h b/ioam/lib-trace/trace_config.h
deleted file mode 100644
index d9fa9ff..0000000
--- a/ioam/lib-trace/trace_config.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * trace_config.h -- iOAM trace configuration utility routines
- *
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef include_vnet_trace_config_h
-#define include_vnet_trace_config_h
-
-extern trace_main_t trace_main;
-
-always_inline trace_profile *
-trace_profile_find (void)
-{
-  trace_main_t *sm = &trace_main;
-
-  return (&(sm->profile));
-}
-
-
-
-#endif
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-trace/trace_test.c b/ioam/lib-trace/trace_test.c
deleted file mode 100644
index 7fb85fb..0000000
--- a/ioam/lib-trace/trace_test.c
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- *------------------------------------------------------------------
- * trace_test.c - test harness for trace plugin
- *------------------------------------------------------------------
- */
-
-#include <vat/vat.h>
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-
-#include <vppinfra/error.h>
-
-#define __plugin_msg_base trace_test_main.msg_id_base
-#include <vlibapi/vat_helper_macros.h>
-
-/* Declare message IDs */
-#include <ioam/lib-trace/trace.api_enum.h>
-#include <ioam/lib-trace/trace.api_types.h>
-
-typedef struct
-{
-  /* API message ID base */
-  u16 msg_id_base;
-  vat_main_t *vat_main;
-} trace_test_main_t;
-
-trace_test_main_t trace_test_main;
-
-static int
-api_trace_profile_add (vat_main_t * vam)
-{
-  unformat_input_t *input = vam->input;
-  vl_api_trace_profile_add_t *mp;
-  u8 trace_type = 0;
-  u8 num_elts = 0;
-  u32 node_id = 0;
-  u32 app_data = 0;
-  u8 trace_tsp = 0;
-  int ret;
-
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "trace-type 0x%x", &trace_type))
-	;
-      else if (unformat (input, "trace-elts %d", &num_elts))
-	;
-      else if (unformat (input, "trace-tsp %d", &trace_tsp))
-	;
-      else if (unformat (input, "node-id 0x%x", &node_id))
-	;
-      else if (unformat (input, "app-data 0x%x", &app_data))
-	;
-
-      else
-	break;
-    }
-
-
-  M (TRACE_PROFILE_ADD, mp);
-
-  mp->trace_type = trace_type;
-  mp->ts_format = trace_tsp;
-  mp->node_id_short = htonl (node_id);
-  mp->app_data_short = htonl (app_data);
-  mp->num_elts = num_elts;
-
-  S (mp);
-  W (ret);
-  return ret;
-}
-
-
-
-static int
-api_trace_profile_del (vat_main_t * vam)
-{
-  vl_api_trace_profile_del_t *mp;
-  int ret;
-
-  M (TRACE_PROFILE_DEL, mp);
-  S (mp);
-  W (ret);
-  return ret;
-}
-
-static int
-api_trace_profile_show_config (vat_main_t * vam)
-{
-  vl_api_trace_profile_show_config_t *mp;
-  int ret;
-
-  M (TRACE_PROFILE_SHOW_CONFIG, mp);
-  S (mp);
-  W (ret);
-  return ret;
-}
-
-static int
-vl_api_trace_profile_show_config_reply_t_handler (vat_main_t * vam)
-{
-  return -1;
-}
-
-/* Override generated plugin register symbol */
-#define vat_plugin_register trace_vat_plugin_register
-#include <ioam/lib-trace/trace.api_test.c>
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-trace/trace_util.c b/ioam/lib-trace/trace_util.c
deleted file mode 100644
index 263ddd4..0000000
--- a/ioam/lib-trace/trace_util.c
+++ /dev/null
@@ -1,445 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <vnet/vnet.h>
-#include <stdint.h>
-#include <time.h>
-#include <string.h>
-#include <vppinfra/mem.h>
-#include "trace_util.h"
-#include "trace_config.h"
-
-__clib_export trace_main_t trace_main;
-
-static int
-trace_profile_cleanup (trace_profile * profile)
-{
-  clib_memset (profile, 0, sizeof (trace_profile));
-  ip6_trace_profile_cleanup ();	/* lib-trace_TODO: Remove this once IOAM-IPv6 transport is a plugin */
-  return 0;
-}
-
-static int
-trace_main_profiles_reset (void)
-{
-  int rv;
-
-  trace_main_t *sm = &trace_main;
-  rv = trace_profile_cleanup (&(sm->profile));
-  return (rv);
-}
-
-int
-trace_util_init (void)
-{
-  int rv;
-
-  rv = trace_main_profiles_reset ();
-  return (rv);
-}
-
-int
-trace_profile_create (trace_profile * profile, trace_profile *user_defined)
-{
-  if (profile && !profile->valid)
-  {
-    // Set the rest of the vars
-    profile->namespace_id = user_defined->namespace_id;
-    profile->num_elts = user_defined->num_elts;
-    profile->node_id_short = user_defined->node_id_short;
-    profile->node_id_wide = user_defined->node_id_wide;
-    profile->app_data_short = user_defined->app_data_short;
-    profile->app_data_wide = user_defined->app_data_wide;
-    profile->option_type = user_defined->option_type;
-    profile->node_type = user_defined->node_type;
-    profile->trace_type = user_defined->trace_type;
-    profile->ts_format = user_defined->ts_format;
-    profile->queue_depth_type = user_defined->queue_depth_type;
-    profile->valid = 1;
-    profile->opaque.len_schemeid = user_defined->opaque.len_schemeid;
-    if(user_defined->opaque.data)
-    {
-      vlib_cli_output(vlib_get_main(), "Trace Profile Create: Adding %d-bytes of opaque data...\n");
-      u32 olen = IOAM_GET_OPAQUE_LEN(user_defined->opaque.len_schemeid); // Represented as 4 octets
-      u32 i;
-      for(i = 0; i < olen; i++)
-      {
-        // Freaking endianess
-        profile->opaque.data[i] = clib_host_to_net_u32(user_defined->opaque.data[i]);
-      }
-      vec_free(user_defined->opaque.data);
-    }
-
-    /* lib-trace_TODO: Remove this once IOAM-IPv6 transport is a plugin */
-    ip6_trace_profile_setup ();
-    return (0);
-  }
-  return (-1);
-}
-
-clib_error_t *
-clear_trace_profile_command_fn (vlib_main_t * vm, unformat_input_t * input, vlib_cli_command_t * cmd)
-{
-  trace_main_profiles_reset ();
-  return 0;
-}
-
-void
-clear_trace_profiles (void)
-{
-  clear_trace_profile_command_fn (0, 0, 0);
-}
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND(clear_trace_profile_command) =
-{
-.path = "clear ioam-trace profile",
-.short_help = "clear ioam-trace profile [<index>|all]",
-.function = clear_trace_profile_command_fn,
-};
-
-/* *INDENT-ON* */
-static clib_error_t *
-show_trace_profile_command_fn (vlib_main_t * vm, unformat_input_t * input, vlib_cli_command_t * cmd)
-{
-  trace_profile *p = NULL;
-  p = trace_profile_find ();
-  u8 *s = 0;
-  if (!(p && p->valid))
-  {
-    s = format (s, "\nTrace configuration not valid\n");
-    vlib_cli_output (vm, "%v", s);
-    vec_free (s);
-    return 0;
-  }
-  s = format (s, " HOP BY HOP OPTIONS - TRACE CONFIG - \n");
-  s = format (s, "        iOAM Namespace      : %d\n",
-	      p->namespace_id);
-  s = format (s, "        iOAM Type           : %d ", p->option_type);
-  u8* stmp = 0;
-  if(p->option_type & IOAM_OPTION_PREALLOC)
-  {
-    stmp = format(stmp, " - Preallocation");
-  }
-  if(p->option_type & IOAM_OPTION_INCREMENT)
-  {
-    stmp = format(stmp, " - Incremental");
-  }
-  if(p->option_type & IOAM_OPTION_POT)
-  {
-    stmp = format(stmp, " - Proof-of-Transit");
-  }
-  if(p->option_type & IOAM_OPTION_E2E)
-  {
-    stmp = format(stmp, " - Edge-to-Edge");
-  }
-  s = format(s, "(%s)\n", stmp);
-  s = format (s, "        Trace Type          : 0x%x\n",
-	      p->trace_type);
-  s =
-    format (s, "        Timestamp precision : %d (%s)\n",
-	    p->ts_format,
-	    (p->ts_format ==
-	     IOAM_TSP_SECONDS) ? "Seconds" : ((p->ts_format ==
-					  IOAM_TSP_MILLISECONDS) ?
-					 "Milliseconds"
-					 : (((p->ts_format ==
-					      IOAM_TSP_MICROSECONDS) ?
-					     "Microseconds" :
-					     "Nanoseconds"))));
-  s = format (s, "        Num of trace nodes  : %d\n", p->num_elts);
-  s =
-    format (s, "        Node-ID-Short/Type  : %d / %s\n",
-	    p->node_id_short,
-      (p->node_type == IOAM_NODE_ENCAP) ? "Encap" :
-      ((p->node_type == IOAM_NODE_TRANSIT) ? "Transit" : "Decap"));
-  s =
-    format (s, "        App Data-Short      : 0x%x\n",
-	    p->app_data_short);
-  s =
-    format (s, "        Node-ID-Wide/Type   : 0x%Lx / %s\n",
-	    p->node_id_wide,
-      (p->node_type == IOAM_NODE_ENCAP) ? "Encap" :
-      ((p->node_type == IOAM_NODE_TRANSIT) ? "Transit" : "Decap"));
-  s =
-    format (s, "        App Data-Wide       : 0x%Lx\n",
-	    p->app_data_wide);
-  s =
-    format (s, "        Queue Depth-Type    : %s\n",
-      (p->queue_depth_type == QUEUE_DEPTH_AF_PACKET) ? "AF_PACKET" :
-      ((p->queue_depth_type == QUEUE_DEPTH_DPDK) ? "DPDK" : "NON"));
-  s = format (s, "        Opaque Length/ID    : %d / %d\n",
-    IOAM_GET_OPAQUE_LEN(p->opaque.len_schemeid) << 2, p->opaque.len_schemeid & IOAM_OPAQUE_SCHEMEID_MASK);
-  if (IOAM_GET_OPAQUE_LEN(p->opaque.len_schemeid))
-  {
-    u32 indent = format_get_indent (s);
-    s = format (s, "        Opaque Data         : \n        %U%U",
-                format_white_space, indent,
-                format_hex_bytes, p->opaque.data, IOAM_GET_OPAQUE_LEN(p->opaque.len_schemeid) << 2);
-  }
-  vlib_cli_output (vm, "%v", s);
-  vec_free (stmp);
-  vec_free (s);
-  return 0;
-}
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (show_trace_profile_command, static) =
-{
-.path = "show ioam-trace profile",
-.short_help = "show ioam-trace profile",
-.function = show_trace_profile_command_fn,
-};
-/* *INDENT-ON* */
-
-uword
-unformat_option_type (unformat_input_t * input, va_list * args)
-{
-  u8 *result = va_arg (*args, u8 *);
-  *result = 0;
-  u8 tmp = 0;
-  do
-  {
-    if (unformat (input, "prealloc"))
-    {
-      *result |= IOAM_OPTION_PREALLOC;
-    }
-    else if (unformat (input, "increment"))
-    {
-      *result |= IOAM_OPTION_INCREMENT;
-    }
-    else if (unformat (input, "pot"))
-    {
-      *result |= IOAM_OPTION_POT;
-    }
-    else if (unformat (input, "e2e"))
-    {
-      *result |= IOAM_OPTION_E2E;
-    }
-  } while(tmp++ < 4);
-  if( (*result & IOAM_OPTION_PREALLOC) && (*result &  IOAM_OPTION_INCREMENT) )
-  {
-    vlib_cli_output (vlib_get_main(), "WARNING: option-type (0x%x) contains both prealloc and increment, defaulting to prealloc", *result);
-    *result &= ~(IOAM_OPTION_INCREMENT);
-  }
-  if (*result == 0)
-  {
-    vlib_cli_output (vlib_get_main(), "WARNING: No option-type chosen, defaulting to prealloc");
-    *result = IOAM_OPTION_PREALLOC;
-  }
-  return 1;
-}
-uword
-unformat_node_type (unformat_input_t * input, va_list * args)
-{
-  u8 *result = va_arg (*args, u8 *);
-  *result = 99; // For input check later
-
-  if (unformat (input, "encap"))
-  {
-    *result = IOAM_NODE_ENCAP;
-  }
-  else if (unformat (input, "transit"))
-  {
-    *result = IOAM_NODE_TRANSIT;
-  }
-  else if (unformat (input, "decap"))
-  {
-    *result = IOAM_NODE_DECAP;
-  }
-  return 1;
-}
-uword
-unformat_ts_format (unformat_input_t * input, va_list * args)
-{
-  u8 *result = va_arg (*args, u8 *);
-  *result = 99; // For input check later
-
-  if (unformat (input, "sec"))
-  {
-    *result = IOAM_TSP_SECONDS;
-  }
-  else if (unformat (input, "ms"))
-  {
-    *result = IOAM_TSP_MILLISECONDS;
-  }
-  else if (unformat (input, "us"))
-  {
-    *result = IOAM_TSP_MICROSECONDS;
-  }
-  else if (unformat (input, "ns"))
-  {
-    *result = IOAM_TSP_NANOSECONDS;
-  }
-  return 1;
-}
-uword
-unformat_queue_depth_format (unformat_input_t * input, va_list * args)
-{
-  u8 *result = va_arg (*args, u8 *);
-  *result = 99; // For input check later
-
-  if (unformat (input, "drv-af-packet"))
-  {
-    *result = QUEUE_DEPTH_AF_PACKET;
-  }
-  else if (unformat (input, "drv-dpdk"))
-  {
-    *result = QUEUE_DEPTH_DPDK;
-  }
-  return 1;
-}
-static u8 *
-trace_util_check_input(u8 *inerror, va_list * args)
-{
-  vlib_main_t * vm = va_arg (*args, vlib_main_t *);
-  trace_profile *input = va_arg (*args, trace_profile *);
-  u32 *olen = va_arg (*args, u32 *);
-  u32 *oid = va_arg (*args, u32 *);
-  // Invalid instruction
-  if ((input->trace_type & ~IOAM_INSTR_BITMAP_MASK) | (!input->trace_type))
-  {
-    inerror =  format (inerror, " - ERROR: Invalid trace-type (0x%x)\n", input->trace_type);
-  }
-  // check validity of option type
-  u8 all_options = IOAM_OPTION_PREALLOC | IOAM_OPTION_INCREMENT | IOAM_OPTION_POT | IOAM_OPTION_E2E;
-  if( input->option_type & ~all_options )
-  {
-    inerror =  format (inerror, " - ERROR: Invalid option-type - [prealloc | increment | pot | e2e]\n");
-  }
-  if (input->option_type == 0)
-  {
-    vlib_cli_output (vm, "WARNING: No option-type chosen, defaulting to prealloc");
-    input->option_type = IOAM_OPTION_PREALLOC;
-  }
-  u8 all_nodes = IOAM_NODE_ENCAP | IOAM_NODE_TRANSIT | IOAM_NODE_DECAP;
-  if((input->node_type & ~all_nodes) | !input->node_type)
-  {
-    inerror =  format (inerror, " - ERROR: Invalid node-type - [encap | transit | decap]\n");
-  }
-  if(!input->num_elts)
-  {
-    inerror =  format (inerror, " - ERROR: num-elts must be > 0\n");
-  }
-  if (((input->trace_type & IOAM_BIT_TTL_NODEID_SHORT) == 0) && ((input->trace_type & IOAM_BIT_TTL_NODEID_WIDE) == 0))
-  {
-    inerror =  format (inerror, " - ERROR: Node ID (short or wide) is required and must be > 0\n");
-  }
-  if( (input->trace_type & IOAM_BIT_TTL_NODEID_SHORT) && !input->node_id_short)
-  {
-    inerror =  format (inerror, " - ERROR: node-id-short must be > 0\n");
-  }
-  if( (input->trace_type & IOAM_BIT_TTL_NODEID_WIDE) && !input->node_id_wide)
-  {
-    inerror =  format (inerror, " - ERROR: node-id-wide must be > 0\n");
-  }
-  if( (input->trace_type & IOAM_BIT_TIMESTAMP_SUB_SEC) && (input->ts_format >= IOAM_TSP_OPTION_SIZE) )
-  {
-    inerror =  format (inerror, " - ERROR: ts-format-sub must be - [sec | ms | us | ns]\n");
-  }
-  u8 all_depth_types = QUEUE_DEPTH_AF_PACKET | QUEUE_DEPTH_DPDK;
-  if( (input->trace_type & IOAM_BIT_QUEUE_DEPTH) && ((input->queue_depth_type & ~all_depth_types) | !input->queue_depth_type))
-  {
-    inerror =  format (inerror, " - ERROR: queue-depth-type must be - [drv-af-packet | drv-dpdk]\n");
-  }
-  u32 in_olen = *olen;
-  u32 in_oid = *oid;
-  if((in_olen && in_oid) && (input->trace_type & IOAM_BIT_VAR_LEN_OP_ST_SNSH))
-  {
-    u32 odata_len = vec_len(input->opaque.data);
-    if(in_olen != odata_len)
-    {
-      vlib_cli_output(vm, "WARNING: opaque-len (%d) != len(opaque-data) (%d) octets - setting to (%d)", in_olen, odata_len, odata_len);
-      in_olen = odata_len;
-    }
-    // round to 4 octet multiples
-    in_olen = (in_olen + 3) & ~3;
-    if(in_olen > IOAM_MAX_OPAQUE_DATA_BYTE_SIZE)
-    {
-      vlib_cli_output(vm, "WARNING: in_olen (%d) > max (%d) octets - using max length", in_olen, IOAM_MAX_OPAQUE_DATA_BYTE_SIZE);
-      in_olen = IOAM_MAX_OPAQUE_DATA_BYTE_SIZE;
-    }
-    // lenght in 4 octet units
-    in_olen = in_olen >> 2;
-    input->opaque.len_schemeid = IOAM_SET_OPAQUE_HEADER(in_olen,in_oid);
-  }
-  else if(
-    ((!in_olen || !in_oid) && (input->trace_type & IOAM_BIT_VAR_LEN_OP_ST_SNSH)) ||
-    (!(input->trace_type & IOAM_BIT_VAR_LEN_OP_ST_SNSH) && (in_olen || in_oid))
-    )
-  {
-    inerror =
-    format (inerror, "ERROR: Opaque, check - opaque bit in trace-type (0x%x), opaque-len (%d) opaque-id (%d)",
-    input->trace_type & IOAM_BIT_VAR_LEN_OP_ST_SNSH, in_olen, in_oid);
-  }
-  return inerror;
-}
-/* *INDENT-ON* */
-static clib_error_t *
-set_trace_profile_command_fn (vlib_main_t * vm, unformat_input_t * input, vlib_cli_command_t * cmd)
-{
-  trace_profile *profile = NULL;
-  trace_profile user_defined;
-  clib_memset (&user_defined, 0, sizeof (trace_profile));
-  u32 olen = 0;
-  u32 oid = 0;
-  clear_trace_profiles ();
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-  {
-    if (unformat (input, "namespace-id %d", &user_defined.namespace_id));
-    else if (unformat (input, "num-elts %d", &user_defined.num_elts));
-    else if (unformat (input, "node-id-short %d", &user_defined.node_id_short));
-    else if (unformat (input, "node-id-wide 0x%Lx", &user_defined.node_id_wide));
-    else if (unformat (input, "app-data-short 0x%x", &user_defined.app_data_short));
-    else if (unformat (input, "app-data-wide 0x%Lx", &user_defined.app_data_wide));
-    else if (unformat (input, "option-type %U", unformat_option_type, &user_defined.option_type));
-    else if (unformat (input, "trace-type 0x%x", &user_defined.trace_type));
-    else if (unformat (input, "node-type %U", unformat_node_type, &user_defined.node_type));
-    else if (unformat (input, "ts-format-sub %U", unformat_ts_format, &user_defined.ts_format));
-    else if (unformat (input, "queue-depth-type %U", unformat_queue_depth_format, &user_defined.queue_depth_type));
-    else if (unformat (input, "opaque-len %d", &olen));
-    else if (unformat (input, "opaque-id %d", &oid));
-    else if (unformat (input, "opaque-data 0x%U", unformat_hex_string, &user_defined.opaque.data));
-    else break;
-  }
-  profile = trace_profile_find ();
-  u8 *errstr = 0;
-  errstr = format(errstr, "%U", trace_util_check_input, vm, &user_defined, &olen, &oid);
-  if (!errstr)
-  {
-    trace_profile_create (profile, &user_defined);
-    show_trace_profile_command_fn (vm, input, cmd);
-  }
-  else
-  {
-    vec_free(user_defined.opaque.data);
-    return clib_error_return (0, "%s", errstr);
-  }
-  return 0;
-}
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (set_trace_profile_command, static) =
-{
-.path = "set ioam-trace profile",
-.short_help = "set ioam-trace profile\n   Mandatory:\n      trace-type [as hex] namespace-id [n] num-elts [< 255] node-id-short [n > 0 (dec)] node-id-wide [n > 0x0 (hex)] queue-depth-type (if queue depth in trace-type) [drv-af-packet | drv-dpdk] node-type [encap | transit | decap]\n    Optional:\n     option-type [prealloc (default) | increment | pot | e2e] ts-format-sub [sec | ms | us | ns] app-data-short/-wide [in hex] opaque-len [n < 1020-bytes] opaque-id [n] opaque-data [hex]",
-.function = set_trace_profile_command_fn,
-};
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-trace/trace_util.h b/ioam/lib-trace/trace_util.h
deleted file mode 100644
index c36fb06..0000000
--- a/ioam/lib-trace/trace_util.h
+++ /dev/null
@@ -1,447 +0,0 @@
-/*
- * trace_util.h -- Trace Profile Utility header
- *
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- * NOTE: This file utilizes IEFT IOAM DATA DRAFTE v10
-*/
-/**
- * Usage:
- *
- * On any node that participates in iOAM Trace.
- *
- * Step 1: Initialize this library by calling trace_init()
- * Step 2: Setup a trace  profile that contains all the parameters needed to compute cumulative:
- *         Call these functions:
- *         trace_profile_find
- *         trace_profile_create
- * Step 2a: On initial node enable the profile to be used:
- *          trace_profile_set_active / trace_profile_get_active will return the profile
- * Step 4: TBD
- *         trace_validate
- *
- */
-#ifndef include_vnet_trace_util_h
-#define include_vnet_trace_util_h
-
-#define debug_ioam debug_ioam_fn
-
-// Useful
-# define htonll64(x)    (((u64)htonl((x) & 0xFFFFFFFF) << 32) | htonl((x) >> 32))
-# define ntohll64(x)    (((u64)ntohl((x) & 0xFFFFFFFF) << 32) | ntohl((x) >> 32))
-
-/*
- * Data-Field - Set of bits with a defined format and meaning, 4 categories
- * Preallocated, Incremental, Proof of Transit, and Edge to Edge
- */
-/*
- * Pre alloc - pre allocated space in packet for telemetry data
- * Incremental - Node allocates and pushes telemetry data following option header
- * PoT - Proof of transit
- * E2E - Edge-to-Edge
- * A nodes can use any of these simultaneously, incremental must precede prealloc
- */
-#define IOAM_OPTION_PREALLOC    (1<<0)
-#define IOAM_OPTION_INCREMENT   (1<<1)
-#define IOAM_OPTION_POT         (1<<2)
-#define IOAM_OPTION_E2E         (1<<3)
-/*
- * Node can only be one !
- * Encapsulation node - A node that adds at least one iOAM option and/or iOAM data
- *                      as packet enters iOAM domain
- * Transit node - Adds iOAM data within an iOAM domain based on the provided iOAM
- *                option type. DOES NOT add new or alter existing option types
- * Decapsulation node - In charge of removing iOAM option type and data before
- *                      leaving iOAM domain
-*/
-#define IOAM_NODE_ENCAP     (1<<0)
-#define IOAM_NODE_TRANSIT   (1<<1)
-#define IOAM_NODE_DECAP     (1<<2)
-
-#define IOAM_TSP_SECONDS       ((u8)0)
-#define IOAM_TSP_MILLISECONDS  ((u8)1)
-#define IOAM_TSP_MICROSECONDS  ((u8)2)
-#define IOAM_TSP_NANOSECONDS   ((u8)3)
-#define IOAM_TSP_OPTION_SIZE   ((u8)4)
-
-/*
- * Hop-by-hop extension
-           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         |  Next Header  |  Hdr Ext Len  |      Options and Padding      |
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         +       Options and Padding, but will be header below           +
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
- * iOAM Prealloc and Incremental Option Header
-           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         |          Namespace ID         |  NodeLen | Flags| RemainingLen|
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         +                 iOAM Trace Type                |   Reserved   +
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   	 |Signature-suite|  Nonce-length |           Reserved            |
-   	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   	 |                             Nonce                             +
-   	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   	 |                           Signature [0]                       +
-   	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   	 |                              ...				  +
-   	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   	 |                           Signature [n]                       +
-   	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         +                       Node Data List [0]                      +
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         +                              ...                              +
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         +                       Node Data List [n]                      +
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
- * namespace_id (16-bit) - unique id which is used by the Encap, Tranist, and Decap nodes
- *             in order to identify what iOAM options/data to alter/add/remove etc.
- *             Allows for a namespace specif interpretation of iOAM data fields.
- *             A subset of all the iOAM option types and data fields are associated
- *             with this ID. There exists two sub-ranges: Default is 0x0000
- *              - Operator-assigned range from 0x0001 to 0x7FFF
- *              - IANA-asigned range from 0x8000 to 0xFFFF
- *             Nodes can work on several Namespace IDs
- *
- * node_len (5-bit) - specified the length of data added by each no in multiples of 4-octets,
- *                    excluding the length of the "Opaque State Snapshot" field.
- *                    Set by Encap.
- *
- *      If iOAM trace type bit 22 is clear,
- *          node_len specifies the actual length added by each node,
- *      else, actual length added by each node is:
- *          node_len + length of "Opaque State Snapshot" field in 4-octet units
- *
- * flags (4-bit) - in IANA, section 8.3 in Draft IETF IPPM iOAM data v10
- *                 Bit 0 "Overflow" (MSB). set if Number of iOAM nodes to aggregate their telemetry
- *                 data is greater than the PMTU.
- *
- * remaining_len (7-bit) - specifies the data space in multiples of 4-octets remaining for
- *      recording the node data, before the node data list is considered to have overflowed.
- *      Can be set to MTU (PMTU) in order to compare with node_len how much space there is left.
- *      In prealloc, this can be used as index for data array, = remaining_len - node_len
- *
- *
- * 
- * Signature-suite:  8-bit unsigned integer.  This field defines the
- *    algorithms used to compute the digest and the signature over the
- *    IOAM-Data-Fields.
- *
- * Nonce length:  8-bit unsigned integer.  This field specifies the
- *    length of the Nonce in octets.
- *
- * Reserved:  16-bit Reserved field.  MUST be set to zero upon
- *    transmission and ignored upon receipt.
- *
- * Nonce:  Variable length field with length specified in Nonce length.
- *
- * Signature:  Digital signature value generated by the method and
- *    algorithm specified by Signature-suite.
- *
- * trace_type (24-bit) - view bit definitions below,
-    iOAM-trace-type if above bits are set accordingly
-    the format of node header data is something like the following.
-    Short/Wide formats - use is not exclusive, so both can be used
-
-          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         |   Hop_Lim     |              node_id (short)                  |
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         |     ingress_if_id (short)       |     egress_if_id (short)    |
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         +                       timestamp_sec                           +
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         +                       timestamp_sub_sec                       +
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         +0|                       transit delay                         +
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         |                        app_data (short)                       |
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         |                          queue_depth                          |
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         |                       checksum_complement                     |
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         |   Hop_Lim     |              node_id (wide)                  |
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         |                      node_id_cont (wide)                      |
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         +                      ingress_if_id (wide)                     +
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         +                      egress_if_id (wide)                      +
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         |                      app_data_cont (wide)                     |
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         |                        buffer_occupancy                       |
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         // opaue data length in 4 octets, max 255 * 4 = 1020 (bytes)
-         |     length    |               schema_id                       |
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         |                           opaque_data                         |
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         |                               ...                             |
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-         |                           opaque_data                         |
-         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-
-         Explaination of Trace Type data
- *
- * Reserved (8-bit) - Encap must set the value to 0s and ignored by transit nodes
- *
- * Node data list (variable length field) - data elements determined by trace type
- *      Order of data followed Trace Type bit order (below). If node is not able to
- *      populate the data field, it is filled with all 0xFs.
- */
- // Trace type instruction bitmap
-#define    IOAM_INSTR_BITMAP_MASK     0xFFF002
-// from pg 15
-#define    IOAM_BIT_TTL_NODEID_SHORT       (1<<23)
-#define    IOAM_BIT_ING_EGR_INT_SHORT      (1<<22)
-#define    IOAM_BIT_TIMESTAMP_SEC          (1<<21)
-#define    IOAM_BIT_TIMESTAMP_SUB_SEC      (1<<20)
-#define    IOAM_BIT_TRANSIT_DELAY          (1<<19)
-#define    IOAM_BIT_APPDATA_SHORT_DATA     (1<<18)
-#define    IOAM_BIT_QUEUE_DEPTH            (1<<17)
-#define    IOAM_BIT_CHECKSUM_COMPLEMENT    (1<<16)
-#define    IOAM_BIT_TTL_NODEID_WIDE        (1<<15)
-#define    IOAM_BIT_ING_EGR_INT_WIDE       (1<<14)
-#define    IOAM_BIT_APPDATA_WIDE_DATA      (1<<13)
-#define    IOAM_BIT_BUFFER_OCCUPANCY       (1<<12)
-/*12-21 are undefined, view pg 16, set to 0 */
-// variable length opaue state snapshot
-#define    IOAM_BIT_VAR_LEN_OP_ST_SNSH     (1<<1)
-// 23 is reserved, set to 0
-// Trace Flags
-#define IOAM_BIT_FLAG_OVERFLOW             (1<<7)
-#define IOAM_BIT_FLAG_LOOPBACK             (1<<8)
-#define IOAM_BIT_FLAG_LOOPBACK_REPLY       (1<<9)
-// For old iOAM Plugin
-#define BIT_LOOPBACK                        IOAM_BIT_FLAG_LOOPBACK
-
-// Trace overflow flag, but also used to indicate if we need to add transit delay
-#define IOAM_BIT_TRANSIT_DELAY_OVERFLOW    (1<<31)
-// Empty values
-#define IOAM_EMPTY_FIELD_U8      (0xFF)
-#define IOAM_EMPTY_FIELD_U16     (0xFFFF)
-#define IOAM_EMPTY_FIELD_U24     (0x00FFFFFF)
-#define IOAM_EMPTY_FIELD_U32     (0xFFFFFFFF)
-#define IOAM_EMPTY_FIELD_U56     (0x00FFFFFFFFFFFFFF)
-#define IOAM_EMPTY_FIELD_U64     (0xFFFFFFFFFFFFFFFF)
-
-#define IOAM_NAMESPACE_ID_MASK  ((u32)0xFFFF0000)
-#define IOAM_NODE_LEN_MASK      ((u16)0xF800)
-#define IOAM_FLAGS_MASK         ((u16)0x0780)
-#define IOAM_REMAIN_LEN_MASK    ((u16)0x0000007F)
-#define IOAM_SET_NODE_LEN(len)  ((u16)((len) << 11) & IOAM_NODE_LEN_MASK)
-#define IOAM_GET_NODE_LEN(n)    ((u16)((n) & IOAM_NODE_LEN_MASK) >> 11)
-#define IOAM_TRACE_TYPE_MASK    ((u32)0xFFFFFF00)
-#define IOAM_SET_TRACETYPE(tt)  ((u32)(clib_host_to_net_u32((tt & IOAM_INSTR_BITMAP_MASK) << 8)))
-#define IOAM_GET_TRACETYPE(tt)  ((u32)((clib_net_to_host_u32(tt) >> 8) & IOAM_INSTR_BITMAP_MASK))
-
-typedef CLIB_PACKED (struct ioam_trace_hdr_ {
-     u16 namespace_id;
-     u16 node_len_flags_remaining_len;
-     u32 trace_type; // only 24-bits, last 8 is for reserved(=0)
-     u8 sign_suite;
-     u8 nonce_len;
-     u32 nonce;
-     u32 signature[0];
-     u32 data_list[0];
- }) ioam_trace_hdr_t;
-
-#define IOAM_MAX_OPAQUE_DATA_WORD_SIZE        ((u8)255)
-#define IOAM_MAX_OPAQUE_DATA_BYTE_SIZE        ((u16)(IOAM_MAX_OPAQUE_DATA_WORD_SIZE<<2))
-#define IOAM_OPAQUE_LEN_MASK                  ((u32)0xFF000000)
-#define IOAM_OPAQUE_SCHEMEID_MASK             ((u32)0x00FFFFFF)
-#define IOAM_GET_OPAQUE_LEN(b)                ((u8)(((IOAM_OPAQUE_LEN_MASK & (b)) >> 24)))
-#define IOAM_SET_OPAQUE_HEADER(len,schemaid)  ((u32)((((len) << 24) & IOAM_OPAQUE_LEN_MASK) | (schemaid & IOAM_OPAQUE_SCHEMEID_MASK)))
-// Max data each node can add, minus opaque (60 bytes)
-#define IOAM_MAX_DATA_NO_OPAQUE               ((u8)60)
-// Max data per node with opaque = 1084-bytes max, +4 due to opaque header
-#define IOAM_MAX_DATA_W_OPAQUE                ((u16)(IOAM_MAX_DATA_NO_OPAQUE + 4 + IOAM_MAX_OPAQUE_DATA_BYTE_SIZE))
-
-typedef CLIB_PACKED (struct opaque_scheme_ {
-     u32 len_schemeid;
-     u32 *data;
- }) opaque_scheme_t;
-
-// Queue depth type for device driver
-#define QUEUE_DEPTH_AF_PACKET   (1<<0)
-#define QUEUE_DEPTH_DPDK        (1<<1)
-// These below are not implemented
-/*
-#define QUEUE_DEPTH_PIPE        (1<<2)
-#define QUEUE_DEPTH_TUNTAP      (1<<3)
-#define QUEUE_DEPTH_VIRTIO      (1<<4)
-#define QUEUE_DEPTH_NETLINK     (1<<5)
-*/
-/*
- * User sets these values to setup the trace profile
-*/
- typedef struct trace_profile_ {
-    u8 valid:1;
-    u16 namespace_id;
-    u8 num_elts;
-    u32 node_id_short;
-    u64 node_id_wide;
-    u32 app_data_short;
-    u64 app_data_wide;
-    u8 option_type;
-    u32 trace_type;
-    u8 node_type;
-    u8 ts_format;
-    u8 queue_depth_type;
-    opaque_scheme_t opaque;
- } trace_profile;
-
-typedef struct
-{
-  /* Name of the default profile list in use */
-  trace_profile profile;
-
-  /* API message ID base */
-  u16 msg_id_base;
-
-  /* convenience */
-  vlib_main_t *vlib_main;
-  vnet_main_t *vnet_main;
-} trace_main_t;
-
-/*
- * Initialize Trace profile
- */
-int trace_util_init (void);
-
-/* setup and clean up profile */
-int trace_profile_create (trace_profile * profile, trace_profile *user_defined);
-
-void clear_trace_profiles (void);
-
-// Defined as 24-bit
-static inline u32
-fetch_trace_data_size (trace_profile * profile)
-{
-  u32 trace_data_size = 0;
-  u32 trace_type = profile->trace_type;
-
-  if(trace_type & IOAM_BIT_TTL_NODEID_SHORT )
-  {
-    trace_data_size += 4;
-  }
-  if(trace_type & IOAM_BIT_ING_EGR_INT_SHORT)
-  {
-    trace_data_size += 4;
-  }
-  if(trace_type & IOAM_BIT_TIMESTAMP_SEC)
-  {
-    trace_data_size += 4;
-  }
-  if(trace_type & IOAM_BIT_TIMESTAMP_SUB_SEC)
-  {
-      trace_data_size += 4;
-  }
-  if(trace_type & IOAM_BIT_TRANSIT_DELAY)
-  {
-    trace_data_size += 4;
-  }
-  if(trace_type & IOAM_BIT_APPDATA_SHORT_DATA)
-  {
-    trace_data_size += 4;
-  }
-  if(trace_type & IOAM_BIT_QUEUE_DEPTH)
-  {
-    trace_data_size += 4;
-  }
-  if(trace_type & IOAM_BIT_CHECKSUM_COMPLEMENT)
-  {
-    trace_data_size += 4;
-  }
-  if(trace_type & IOAM_BIT_TTL_NODEID_WIDE)
-  {
-      trace_data_size += 8;
-  }
-  if(trace_type & IOAM_BIT_ING_EGR_INT_WIDE)
-  {
-      trace_data_size += 8;
-  }
-  if(trace_type & IOAM_BIT_APPDATA_WIDE_DATA)
-  {
-    trace_data_size += 8;
-  }
-  if(trace_type & IOAM_BIT_BUFFER_OCCUPANCY)
-  {
-    trace_data_size += 4;
-  }
-  if(trace_type & IOAM_BIT_VAR_LEN_OP_ST_SNSH)
-  {
-    trace_data_size += 4; // for opaque header, data is variable length but max 255*4 bytes
-    trace_data_size += IOAM_GET_OPAQUE_LEN(profile->opaque.len_schemeid) << 2;
-  }
-  return trace_data_size;
-}
-
-always_inline void
-ioam_tracetype_set_bit (ioam_trace_hdr_t * trace_hdr, u32 trace_bit)
-{
-  trace_hdr->trace_type |= clib_host_to_net_u32(trace_bit);
-}
-
-always_inline void
-ioam_tracetype_reset_bit (ioam_trace_hdr_t * trace_hdr, u32 trace_bit)
-{
-  trace_hdr->trace_type &= clib_host_to_net_u32(~trace_bit);
-}
-
-always_inline void
-ioam_traceflag_set_bit (ioam_trace_hdr_t * trace_hdr, u16 flag_bit)
-{
-  trace_hdr->node_len_flags_remaining_len |= clib_host_to_net_u16(flag_bit);
-}
-
-always_inline void
-ioam_traceflag_reset_bit (ioam_trace_hdr_t * trace_hdr, u16 flag_bit)
-{
-  trace_hdr->node_len_flags_remaining_len &= clib_host_to_net_u16(~flag_bit);
-}
-static inline void
-ioam_print_profile(trace_profile *profile)
-{
-  if(profile)
-  {
-    vlib_cli_output(vlib_get_main(), "iOAM Profile:\n");
-    vlib_cli_output(vlib_get_main(),
-    " - namespace-id %d\n - num-elts %d\n - node-id-short %d\n - app-data-short 0x%x\n - node-id-wide %Ld\n - app-data-wide 0x%Lx\n - option-type %d\n - trace-type 0x%x\n - node-type %d\n - ts-format-sub %d\n - opaque-len %d\n - opaque-id %d\n",
-    profile->namespace_id, profile->num_elts, profile->node_id_short, profile->app_data_short, profile->node_id_wide, profile->app_data_wide, profile->option_type, profile->trace_type, profile->node_type, profile->ts_format, IOAM_GET_OPAQUE_LEN(profile->opaque.len_schemeid) << 2, IOAM_OPAQUE_SCHEMEID_MASK & profile->opaque.len_schemeid);
-  }
-  else
-  {
-    vlib_cli_output(vlib_get_main(), "No iOAM Profile to print.\n");
-  }
-}
-
-int ioam_trace_get_sizeof_handler (u32 * result);
-int ip6_trace_profile_setup (void);
-int ip6_trace_profile_cleanup (void);
-
-
-#endif /* include_vnet_trace_util_h */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-vxlan-gpe/ioam_decap.c b/ioam/lib-vxlan-gpe/ioam_decap.c
deleted file mode 100644
index 87e57d3..0000000
--- a/ioam/lib-vxlan-gpe/ioam_decap.c
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * Copyright (c) 2015 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <vppinfra/error.h>
-#include <vppinfra/hash.h>
-#include <vnet/vnet.h>
-#include <vnet/ip/ip.h>
-#include <vnet/ethernet/ethernet.h>
-#include <vnet/vxlan-gpe/vxlan_gpe.h>
-#include <vnet/vxlan-gpe/vxlan_gpe.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam_packet.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam_util.h>
-
-/* Statistics (not really errors) */
-#define foreach_vxlan_gpe_decap_ioam_v4_error    \
-_(DECAPSULATED, "good packets decapsulated")
-
-static char *vxlan_gpe_decap_ioam_v4_error_strings[] = {
-#define _(sym,string) string,
-  foreach_vxlan_gpe_decap_ioam_v4_error
-#undef _
-};
-
-typedef enum
-{
-#define _(sym,str) VXLAN_GPE_DECAP_IOAM_V4_ERROR_##sym,
-  foreach_vxlan_gpe_decap_ioam_v4_error
-#undef _
-    VXLAN_GPE_DECAP_IOAM_V4_N_ERROR,
-} vxlan_gpe_decap_ioam_v4_error_t;
-
-
-always_inline void
-vxlan_gpe_decap_ioam_v4_two_inline (vlib_main_t * vm,
-				    vlib_node_runtime_t * node,
-				    vxlan_gpe_main_t * ngm,
-				    vlib_buffer_t * b0, vlib_buffer_t * b1,
-				    u32 * next0, u32 * next1)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-
-  *next0 = *next1 = hm->decap_v4_next_override;
-  vxlan_gpe_encap_decap_ioam_v4_one_inline (vm, node, b0, next0,
-					    VXLAN_GPE_DECAP_IOAM_V4_NEXT_DROP,
-					    0 /* use_adj */ );
-  vxlan_gpe_encap_decap_ioam_v4_one_inline (vm, node, b1, next1,
-					    VXLAN_GPE_DECAP_IOAM_V4_NEXT_DROP,
-					    0 /* use_adj */ );
-}
-
-
-
-static uword
-vxlan_gpe_decap_ioam (vlib_main_t * vm,
-		      vlib_node_runtime_t * node,
-		      vlib_frame_t * from_frame, u8 is_ipv6)
-{
-  u32 n_left_from, next_index, *from, *to_next;
-  vxlan_gpe_main_t *ngm = &vxlan_gpe_main;
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-
-  from = vlib_frame_vector_args (from_frame);
-  n_left_from = from_frame->n_vectors;
-
-  next_index = node->cached_next_index;
-
-  while (n_left_from > 0)
-    {
-      u32 n_left_to_next;
-
-      vlib_get_next_frame (vm, node, next_index, to_next, n_left_to_next);
-
-      while (n_left_from >= 4 && n_left_to_next >= 2)
-	{
-	  u32 bi0, bi1;
-	  vlib_buffer_t *b0, *b1;
-	  u32 next0, next1;
-
-	  next0 = next1 = hm->decap_v4_next_override;
-
-	  /* Prefetch next iteration. */
-	  {
-	    vlib_buffer_t *p2, *p3;
-
-	    p2 = vlib_get_buffer (vm, from[2]);
-	    p3 = vlib_get_buffer (vm, from[3]);
-
-	    vlib_prefetch_buffer_header (p2, LOAD);
-	    vlib_prefetch_buffer_header (p3, LOAD);
-
-	    CLIB_PREFETCH (p2->data, 2 * CLIB_CACHE_LINE_BYTES, LOAD);
-	    CLIB_PREFETCH (p3->data, 2 * CLIB_CACHE_LINE_BYTES, LOAD);
-	  }
-
-	  bi0 = from[0];
-	  bi1 = from[1];
-	  to_next[0] = bi0;
-	  to_next[1] = bi1;
-	  from += 2;
-	  to_next += 2;
-	  n_left_to_next -= 2;
-	  n_left_from -= 2;
-
-	  b0 = vlib_get_buffer (vm, bi0);
-	  b1 = vlib_get_buffer (vm, bi1);
-
-
-	  vlib_buffer_advance (b0,
-			       -(word) (sizeof (udp_header_t) +
-					sizeof (ip4_header_t) +
-					sizeof (vxlan_gpe_header_t)));
-	  vlib_buffer_advance (b1,
-			       -(word) (sizeof (udp_header_t) +
-					sizeof (ip4_header_t) +
-					sizeof (vxlan_gpe_header_t)));
-
-	  vxlan_gpe_decap_ioam_v4_two_inline (vm, node, ngm, b0, b1,
-					      &next0, &next1);
-
-
-	  vlib_validate_buffer_enqueue_x2 (vm, node, next_index, to_next,
-					   n_left_to_next, bi0, bi1, next0,
-					   next1);
-
-	  if (PREDICT_FALSE (b0->flags & VLIB_BUFFER_IS_TRACED))
-	    {
-	      vxlan_gpe_ioam_v4_trace_t *tr = vlib_add_trace (vm, node, b0,
-							      sizeof (*tr));
-	    }
-	}
-
-      while (n_left_from > 0 && n_left_to_next > 0)
-	{
-	  u32 bi0;
-	  vlib_buffer_t *b0;
-	  u32 next0 = hm->decap_v4_next_override;
-
-	  bi0 = from[0];
-	  to_next[0] = bi0;
-	  from += 1;
-	  to_next += 1;
-	  n_left_from -= 1;
-	  n_left_to_next -= 1;
-
-	  b0 = vlib_get_buffer (vm, bi0);
-
-
-	  vlib_buffer_advance (b0,
-			       -(word) (sizeof (udp_header_t) +
-					sizeof (ip4_header_t) +
-					sizeof (vxlan_gpe_header_t)));
-
-	  next0 = hm->decap_v4_next_override;
-	  vxlan_gpe_encap_decap_ioam_v4_one_inline (vm, node, b0,
-						    &next0,
-						    VXLAN_GPE_DECAP_IOAM_V4_NEXT_DROP,
-						    0 /* use_adj */ );
-
-	  if (PREDICT_FALSE (b0->flags & VLIB_BUFFER_IS_TRACED))
-	    {
-	      vxlan_gpe_ioam_v4_trace_t *tr = vlib_add_trace (vm, node, b0,
-							      sizeof (*tr));
-	    }
-	  vlib_validate_buffer_enqueue_x1 (vm, node, next_index, to_next,
-					   n_left_to_next, bi0, next0);
-	}
-
-      vlib_put_next_frame (vm, node, next_index, n_left_to_next);
-    }
-
-  return from_frame->n_vectors;
-}
-
-
-static uword
-vxlan_gpe_decap_ioam_v4 (vlib_main_t * vm,
-			 vlib_node_runtime_t * node,
-			 vlib_frame_t * from_frame)
-{
-  return vxlan_gpe_decap_ioam (vm, node, from_frame, 0);
-}
-
-
-/* *INDENT-OFF* */
-VLIB_REGISTER_NODE (vxlan_gpe_decap_ioam_v4_node) = {
-  .function = vxlan_gpe_decap_ioam_v4,
-  .name = "vxlan-gpe-decap-ioam-v4",
-  .vector_size = sizeof (u32),
-  .format_trace = format_vxlan_gpe_ioam_v4_trace,
-  .type = VLIB_NODE_TYPE_INTERNAL,
-
-  .n_errors = ARRAY_LEN(vxlan_gpe_decap_ioam_v4_error_strings),
-  .error_strings = vxlan_gpe_decap_ioam_v4_error_strings,
-
-  .n_next_nodes = VXLAN_GPE_DECAP_IOAM_V4_N_NEXT,
-
-  .next_nodes = {
-    [VXLAN_GPE_DECAP_IOAM_V4_NEXT_POP] = "vxlan-gpe-pop-ioam-v4",
-    [VXLAN_GPE_DECAP_IOAM_V4_NEXT_DROP] = "error-drop",
-  },
-};
-/* *INDENT-ON* */
-
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-vxlan-gpe/ioam_encap.c b/ioam/lib-vxlan-gpe/ioam_encap.c
deleted file mode 100644
index 1d15654..0000000
--- a/ioam/lib-vxlan-gpe/ioam_encap.c
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * Copyright (c) 2015 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <vppinfra/error.h>
-#include <vppinfra/hash.h>
-#include <vnet/vnet.h>
-#include <vnet/ip/ip.h>
-#include <vnet/ethernet/ethernet.h>
-#include <vnet/vxlan-gpe/vxlan_gpe.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam_packet.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam_util.h>
-
-/* Statistics (not really errors) */
-#define foreach_vxlan_gpe_encap_ioam_v4_error    \
-_(ENCAPSULATED, "good packets encapsulated")
-
-static char *vxlan_gpe_encap_ioam_v4_error_strings[] = {
-#define _(sym,string) string,
-  foreach_vxlan_gpe_encap_ioam_v4_error
-#undef _
-};
-
-typedef enum
-{
-#define _(sym,str) VXLAN_GPE_ENCAP_IOAM_V4_ERROR_##sym,
-  foreach_vxlan_gpe_encap_ioam_v4_error
-#undef _
-    VXLAN_GPE_ENCAP_IOAM_V4_N_ERROR,
-} vxlan_gpe_encap_ioam_v4_error_t;
-
-typedef enum
-{
-  VXLAN_GPE_ENCAP_IOAM_V4_NEXT_IP4_LOOKUP,
-  VXLAN_GPE_ENCAP_IOAM_V4_NEXT_DROP,
-  VXLAN_GPE_ENCAP_IOAM_V4_N_NEXT
-} vxlan_gpe_encap_ioam_v4_next_t;
-
-
-always_inline void
-vxlan_gpe_encap_ioam_v4_two_inline (vlib_main_t * vm,
-				    vlib_node_runtime_t * node,
-				    vxlan_gpe_main_t * ngm,
-				    vlib_buffer_t * b0, vlib_buffer_t * b1,
-				    u32 * next0, u32 * next1)
-{
-  *next0 = *next1 = VXLAN_GPE_ENCAP_IOAM_V4_NEXT_IP4_LOOKUP;
-  vxlan_gpe_encap_decap_ioam_v4_one_inline (vm, node, b0, next0,
-					    VXLAN_GPE_ENCAP_IOAM_V4_NEXT_DROP,
-					    0 /* use_adj */ );
-  vxlan_gpe_encap_decap_ioam_v4_one_inline (vm, node, b1, next1,
-					    VXLAN_GPE_ENCAP_IOAM_V4_NEXT_DROP,
-					    0 /* use_adj */ );
-}
-
-
-static uword
-vxlan_gpe_encap_ioam_v4 (vlib_main_t * vm,
-			 vlib_node_runtime_t * node,
-			 vlib_frame_t * from_frame)
-{
-  u32 n_left_from, next_index, *from, *to_next;
-  vxlan_gpe_main_t *ngm = &vxlan_gpe_main;
-
-  from = vlib_frame_vector_args (from_frame);
-  n_left_from = from_frame->n_vectors;
-
-  next_index = node->cached_next_index;
-
-  while (n_left_from > 0)
-    {
-      u32 n_left_to_next;
-
-      vlib_get_next_frame (vm, node, next_index, to_next, n_left_to_next);
-
-      while (n_left_from >= 4 && n_left_to_next >= 2)
-	{
-	  u32 bi0, bi1;
-	  vlib_buffer_t *b0, *b1;
-	  u32 next0, next1;
-
-	  next0 = next1 = VXLAN_GPE_ENCAP_IOAM_V4_NEXT_IP4_LOOKUP;
-
-	  /* Prefetch next iteration. */
-	  {
-	    vlib_buffer_t *p2, *p3;
-
-	    p2 = vlib_get_buffer (vm, from[2]);
-	    p3 = vlib_get_buffer (vm, from[3]);
-
-	    vlib_prefetch_buffer_header (p2, LOAD);
-	    vlib_prefetch_buffer_header (p3, LOAD);
-
-	    CLIB_PREFETCH (p2->data, 2 * CLIB_CACHE_LINE_BYTES, LOAD);
-	    CLIB_PREFETCH (p3->data, 2 * CLIB_CACHE_LINE_BYTES, LOAD);
-	  }
-
-	  bi0 = from[0];
-	  bi1 = from[1];
-	  to_next[0] = bi0;
-	  to_next[1] = bi1;
-	  from += 2;
-	  to_next += 2;
-	  n_left_to_next -= 2;
-	  n_left_from -= 2;
-
-	  b0 = vlib_get_buffer (vm, bi0);
-	  b1 = vlib_get_buffer (vm, bi1);
-
-	  vxlan_gpe_encap_ioam_v4_two_inline (vm, node, ngm, b0, b1,
-					      &next0, &next1);
-
-
-	  vlib_validate_buffer_enqueue_x2 (vm, node, next_index, to_next,
-					   n_left_to_next, bi0, bi1, next0,
-					   next1);
-	}
-
-      while (n_left_from > 0 && n_left_to_next > 0)
-	{
-	  u32 bi0;
-	  vlib_buffer_t *b0;
-	  u32 next0 = VXLAN_GPE_ENCAP_IOAM_V4_NEXT_IP4_LOOKUP;
-
-	  bi0 = from[0];
-	  to_next[0] = bi0;
-	  from += 1;
-	  to_next += 1;
-	  n_left_from -= 1;
-	  n_left_to_next -= 1;
-
-	  b0 = vlib_get_buffer (vm, bi0);
-
-	  vxlan_gpe_encap_decap_ioam_v4_one_inline (vm, node, b0,
-						    &next0,
-						    VXLAN_GPE_ENCAP_IOAM_V4_NEXT_DROP,
-						    0 /* use_adj */ );
-
-	  if (PREDICT_FALSE (b0->flags & VLIB_BUFFER_IS_TRACED))
-	    {
-	      vxlan_gpe_ioam_v4_trace_t *tr = vlib_add_trace (vm, node, b0,
-							      sizeof (*tr));
-	    }
-	  vlib_validate_buffer_enqueue_x1 (vm, node, next_index, to_next,
-					   n_left_to_next, bi0, next0);
-	}
-
-      vlib_put_next_frame (vm, node, next_index, n_left_to_next);
-    }
-
-  return from_frame->n_vectors;
-}
-
-
-
-/* *INDENT-OFF* */
-VLIB_REGISTER_NODE (vxlan_gpe_encap_ioam_v4_node) = {
-  .function = vxlan_gpe_encap_ioam_v4,
-  .name = "vxlan-gpe-encap-ioam-v4",
-  .vector_size = sizeof (u32),
-  .format_trace = format_vxlan_gpe_ioam_v4_trace,
-  .type = VLIB_NODE_TYPE_INTERNAL,
-
-  .n_errors = ARRAY_LEN(vxlan_gpe_encap_ioam_v4_error_strings),
-  .error_strings = vxlan_gpe_encap_ioam_v4_error_strings,
-
-  .n_next_nodes = VXLAN_GPE_ENCAP_IOAM_V4_N_NEXT,
-
-  .next_nodes = {
-    [VXLAN_GPE_ENCAP_IOAM_V4_NEXT_IP4_LOOKUP] = "ip4-lookup",
-    [VXLAN_GPE_ENCAP_IOAM_V4_NEXT_DROP] = "error-drop",
-  },
-};
-/* *INDENT-ON* */
-
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-vxlan-gpe/ioam_pop.c b/ioam/lib-vxlan-gpe/ioam_pop.c
deleted file mode 100644
index 84900eb..0000000
--- a/ioam/lib-vxlan-gpe/ioam_pop.c
+++ /dev/null
@@ -1,353 +0,0 @@
-/*
- * Copyright (c) 2015 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <vppinfra/error.h>
-#include <vppinfra/hash.h>
-#include <vnet/vnet.h>
-#include <vnet/ip/ip.h>
-#include <vnet/ethernet/ethernet.h>
-#include <vnet/vxlan-gpe/vxlan_gpe.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam.h>
-
-/* Statistics (not really errors) */
-#define foreach_vxlan_gpe_pop_ioam_v4_error    \
-_(POPPED, "good packets popped")
-
-static char *vxlan_gpe_pop_ioam_v4_error_strings[] = {
-#define _(sym,string) string,
-  foreach_vxlan_gpe_pop_ioam_v4_error
-#undef _
-};
-
-typedef enum
-{
-#define _(sym,str) VXLAN_GPE_POP_IOAM_V4_ERROR_##sym,
-  foreach_vxlan_gpe_pop_ioam_v4_error
-#undef _
-    VXLAN_GPE_POP_IOAM_V4_N_ERROR,
-} vxlan_gpe_pop_ioam_v4_error_t;
-
-typedef struct
-{
-  ioam_trace_t fmt_trace;
-} vxlan_gpe_pop_ioam_v4_trace_t;
-
-
-u8 *
-format_vxlan_gpe_pop_ioam_v4_trace (u8 * s, va_list * args)
-{
-  CLIB_UNUSED (vlib_main_t * vm) = va_arg (*args, vlib_main_t *);
-  CLIB_UNUSED (vlib_node_t * node) = va_arg (*args, vlib_node_t *);
-  vxlan_gpe_pop_ioam_v4_trace_t *t1
-    = va_arg (*args, vxlan_gpe_pop_ioam_v4_trace_t *);
-  ioam_trace_t *t = &(t1->fmt_trace);
-  vxlan_gpe_ioam_option_t *fmt_trace0;
-  vxlan_gpe_ioam_option_t *opt0, *limit0;
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-
-  u8 type0;
-
-  fmt_trace0 = (vxlan_gpe_ioam_option_t *) t->option_data;
-
-  s = format (s, "VXLAN_GPE_IOAM_POP: next_index %d len %d traced %d",
-	      t->next_index, fmt_trace0->length, t->trace_len);
-
-  opt0 = (vxlan_gpe_ioam_option_t *) (fmt_trace0 + 1);
-  limit0 = (vxlan_gpe_ioam_option_t *) ((u8 *) fmt_trace0) + t->trace_len;
-
-  while (opt0 < limit0)
-    {
-      type0 = opt0->type;
-      switch (type0)
-	{
-	case 0:		/* Pad, just stop */
-	  opt0 = (vxlan_gpe_ioam_option_t *) ((u8 *) opt0) + 1;
-	  break;
-
-	default:
-	  if (hm->trace[type0])
-	    {
-	      s = (*hm->trace[type0]) (s, opt0);
-	    }
-	  else
-	    {
-	      s =
-		format (s, "\n    unrecognized option %d length %d", type0,
-			opt0->length);
-	    }
-	  opt0 =
-	    (vxlan_gpe_ioam_option_t *) (((u8 *) opt0) + opt0->length +
-					 sizeof (vxlan_gpe_ioam_option_t));
-	  break;
-	}
-    }
-
-  return s;
-}
-
-always_inline void
-vxlan_gpe_ioam_pop_v4 (vlib_main_t * vm, vlib_node_runtime_t * node,
-		       vlib_buffer_t * b0)
-{
-  ip4_header_t *ip0;
-  udp_header_t *udp_hdr0;
-  vxlan_gpe_header_t *gpe_hdr0;
-  vxlan_gpe_ioam_hdr_t *gpe_ioam0;
-
-  ip0 = vlib_buffer_get_current (b0);
-
-  udp_hdr0 = (udp_header_t *) (ip0 + 1);
-  gpe_hdr0 = (vxlan_gpe_header_t *) (udp_hdr0 + 1);
-  gpe_ioam0 = (vxlan_gpe_ioam_hdr_t *) (gpe_hdr0 + 1);
-
-  /* Pop the iOAM data */
-  vlib_buffer_advance (b0,
-		       (word) (sizeof (udp_header_t) +
-			       sizeof (ip4_header_t) +
-			       sizeof (vxlan_gpe_header_t) +
-			       gpe_ioam0->length));
-
-  return;
-}
-
-
-
-always_inline void
-vxlan_gpe_pop_ioam_v4_one_inline (vlib_main_t * vm,
-				  vlib_node_runtime_t * node,
-				  vxlan_gpe_main_t * ngm,
-				  vlib_buffer_t * b0, u32 * next0)
-{
-  CLIB_UNUSED (ip4_header_t * ip0);
-  CLIB_UNUSED (udp_header_t * udp_hdr0);
-  CLIB_UNUSED (vxlan_gpe_header_t * gpe_hdr0);
-  CLIB_UNUSED (vxlan_gpe_ioam_hdr_t * gpe_ioam0);
-  CLIB_UNUSED (vxlan_gpe_ioam_option_t * opt0);
-  CLIB_UNUSED (vxlan_gpe_ioam_option_t * limit0);
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-
-
-  /* Pop the iOAM header */
-  ip0 = vlib_buffer_get_current (b0);
-  udp_hdr0 = (udp_header_t *) (ip0 + 1);
-  gpe_hdr0 = (vxlan_gpe_header_t *) (udp_hdr0 + 1);
-  gpe_ioam0 = (vxlan_gpe_ioam_hdr_t *) (gpe_hdr0 + 1);
-  opt0 = (vxlan_gpe_ioam_option_t *) (gpe_ioam0 + 1);
-  limit0 = (vxlan_gpe_ioam_option_t *) ((u8 *) gpe_ioam0 + gpe_ioam0->length);
-
-  /*
-   * Basic validity checks
-   */
-  if (gpe_ioam0->length > clib_net_to_host_u16 (ip0->length))
-    {
-      *next0 = VXLAN_GPE_INPUT_NEXT_DROP;
-      goto trace00;
-    }
-
-  /* Scan the set of h-b-h options, process ones that we understand */
-  while (opt0 < limit0)
-    {
-      u8 type0;
-      type0 = opt0->type;
-      switch (type0)
-	{
-	case 0:		/* Pad1 */
-	  opt0 = (vxlan_gpe_ioam_option_t *) ((u8 *) opt0) + 1;
-	  continue;
-	case 1:		/* PadN */
-	  break;
-	default:
-	  if (hm->pop_options[type0])
-	    {
-	      if ((*hm->pop_options[type0]) (ip0, opt0) < 0)
-		{
-		  *next0 = VXLAN_GPE_INPUT_NEXT_DROP;
-		  goto trace00;
-		}
-	    }
-	  break;
-	}
-      opt0 =
-	(vxlan_gpe_ioam_option_t *) (((u8 *) opt0) + opt0->length +
-				     sizeof (vxlan_gpe_ioam_hdr_t));
-    }
-
-
-  *next0 =
-    (gpe_ioam0->protocol < VXLAN_GPE_PROTOCOL_MAX) ?
-    ngm->
-    decap_next_node_list[gpe_ioam0->protocol] : VXLAN_GPE_INPUT_NEXT_DROP;
-
-trace00:
-  if (PREDICT_FALSE (b0->flags & VLIB_BUFFER_IS_TRACED))
-    {
-      vxlan_gpe_pop_ioam_v4_trace_t *t =
-	vlib_add_trace (vm, node, b0, sizeof (*t));
-      u32 trace_len = gpe_ioam0->length;
-      t->fmt_trace.next_index = *next0;
-      /* Capture the h-b-h option verbatim */
-      trace_len =
-	trace_len <
-	ARRAY_LEN (t->fmt_trace.
-		   option_data) ? trace_len : ARRAY_LEN (t->fmt_trace.
-							 option_data);
-      t->fmt_trace.trace_len = trace_len;
-      clib_memcpy_fast (&(t->fmt_trace.option_data), gpe_ioam0, trace_len);
-    }
-
-  /* Remove the iOAM header inside the VxLAN-GPE header */
-  vxlan_gpe_ioam_pop_v4 (vm, node, b0);
-  return;
-}
-
-always_inline void
-vxlan_gpe_pop_ioam_v4_two_inline (vlib_main_t * vm,
-				  vlib_node_runtime_t * node,
-				  vxlan_gpe_main_t * ngm,
-				  vlib_buffer_t * b0, vlib_buffer_t * b1,
-				  u32 * next0, u32 * next1)
-{
-
-  vxlan_gpe_pop_ioam_v4_one_inline (vm, node, ngm, b0, next0);
-  vxlan_gpe_pop_ioam_v4_one_inline (vm, node, ngm, b1, next1);
-}
-
-
-
-static uword
-vxlan_gpe_pop_ioam (vlib_main_t * vm,
-		    vlib_node_runtime_t * node,
-		    vlib_frame_t * from_frame, u8 is_ipv6)
-{
-  u32 n_left_from, next_index, *from, *to_next;
-  vxlan_gpe_main_t *ngm = &vxlan_gpe_main;
-
-  from = vlib_frame_vector_args (from_frame);
-  n_left_from = from_frame->n_vectors;
-
-  next_index = node->cached_next_index;
-
-  while (n_left_from > 0)
-    {
-      u32 n_left_to_next;
-
-      vlib_get_next_frame (vm, node, next_index, to_next, n_left_to_next);
-
-      while (n_left_from >= 4 && n_left_to_next >= 2)
-	{
-	  u32 bi0, bi1;
-	  vlib_buffer_t *b0, *b1;
-	  u32 next0, next1;
-
-	  /* Prefetch next iteration. */
-	  {
-	    vlib_buffer_t *p2, *p3;
-
-	    p2 = vlib_get_buffer (vm, from[2]);
-	    p3 = vlib_get_buffer (vm, from[3]);
-
-	    vlib_prefetch_buffer_header (p2, LOAD);
-	    vlib_prefetch_buffer_header (p3, LOAD);
-
-	    CLIB_PREFETCH (p2->data, 2 * CLIB_CACHE_LINE_BYTES, LOAD);
-	    CLIB_PREFETCH (p3->data, 2 * CLIB_CACHE_LINE_BYTES, LOAD);
-	  }
-
-	  bi0 = from[0];
-	  bi1 = from[1];
-	  to_next[0] = bi0;
-	  to_next[1] = bi1;
-	  from += 2;
-	  to_next += 2;
-	  n_left_to_next -= 2;
-	  n_left_from -= 2;
-
-	  b0 = vlib_get_buffer (vm, bi0);
-	  b1 = vlib_get_buffer (vm, bi1);
-
-	  vxlan_gpe_pop_ioam_v4_two_inline (vm, node, ngm, b0, b1, &next0,
-					    &next1);
-
-
-	  vlib_validate_buffer_enqueue_x2 (vm, node, next_index, to_next,
-					   n_left_to_next, bi0, bi1, next0,
-					   next1);
-	}
-
-      while (n_left_from > 0 && n_left_to_next > 0)
-	{
-	  u32 bi0;
-	  vlib_buffer_t *b0;
-	  u32 next0;
-
-	  bi0 = from[0];
-	  to_next[0] = bi0;
-	  from += 1;
-	  to_next += 1;
-	  n_left_from -= 1;
-	  n_left_to_next -= 1;
-
-	  b0 = vlib_get_buffer (vm, bi0);
-
-	  vxlan_gpe_pop_ioam_v4_one_inline (vm, node, ngm, b0, &next0);
-
-
-	  vlib_validate_buffer_enqueue_x1 (vm, node, next_index, to_next,
-					   n_left_to_next, bi0, next0);
-	}
-
-      vlib_put_next_frame (vm, node, next_index, n_left_to_next);
-    }
-
-  return from_frame->n_vectors;
-}
-
-
-static uword
-vxlan_gpe_pop_ioam_v4 (vlib_main_t * vm,
-		       vlib_node_runtime_t * node, vlib_frame_t * from_frame)
-{
-  return vxlan_gpe_pop_ioam (vm, node, from_frame, 0);
-}
-
-/* *INDENT-OFF* */
-VLIB_REGISTER_NODE (vxlan_gpe_pop_ioam_v4_node) = {
-  .function = vxlan_gpe_pop_ioam_v4,
-  .name = "vxlan-gpe-pop-ioam-v4",
-  .vector_size = sizeof (u32),
-  .format_trace = format_vxlan_gpe_pop_ioam_v4_trace,
-  .type = VLIB_NODE_TYPE_INTERNAL,
-
-  .n_errors = ARRAY_LEN(vxlan_gpe_pop_ioam_v4_error_strings),
-  .error_strings = vxlan_gpe_pop_ioam_v4_error_strings,
-
-  .n_next_nodes = VXLAN_GPE_INPUT_N_NEXT,
-
-  .next_nodes = {
-#define _(s,n) [VXLAN_GPE_INPUT_NEXT_##s] = n,
-    foreach_vxlan_gpe_input_next
-#undef _
-  },
-};
-/* *INDENT-ON* */
-
-
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-vxlan-gpe/ioam_transit.c b/ioam/lib-vxlan-gpe/ioam_transit.c
deleted file mode 100644
index 215f14b..0000000
--- a/ioam/lib-vxlan-gpe/ioam_transit.c
+++ /dev/null
@@ -1,187 +0,0 @@
- /*
-  * Copyright (c) 2015 Cisco and/or its affiliates.
-  * Licensed under the Apache License, Version 2.0 (the "License");
-  * you may not use this file except in compliance with the License.
-  * You may obtain a copy of the License at:
-  *
-  *     http://www.apache.org/licenses/LICENSE-2.0
-  *
-  * Unless required by applicable law or agreed to in writing, software
-  * distributed under the License is distributed on an "AS IS" BASIS,
-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  * See the License for the specific language governing permissions and
-  * limitations under the License.
-  */
-#include <vppinfra/error.h>
-#include <vppinfra/hash.h>
-#include <vnet/vnet.h>
-#include <vnet/ip/ip.h>
-#include <vnet/udp/udp_local.h>
-#include <vnet/ethernet/ethernet.h>
-#include <vnet/vxlan-gpe/vxlan_gpe.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam_packet.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam_util.h>
-#include <vnet/fib/ip4_fib.h>
-#include <vnet/fib/fib_entry.h>
-
-/* Statistics (not really errors) */
-#define foreach_vxlan_gpe_transit_ioam_error    \
-_(ENCAPSULATED, "good packets encapsulated")
-
-static char *vxlan_gpe_transit_ioam_error_strings[] = {
-#define _(sym,string) string,
-  foreach_vxlan_gpe_transit_ioam_error
-#undef _
-};
-
-typedef enum
-{
-#define _(sym,str) VXLAN_GPE_TRANSIT_IOAM_ERROR_##sym,
-  foreach_vxlan_gpe_transit_ioam_error
-#undef _
-    VXLAN_GPE_TRANSIT_IOAM_N_ERROR,
-} vxlan_gpe_transit_ioam_error_t;
-
-typedef enum
-{
-  VXLAN_GPE_TRANSIT_IOAM_NEXT_OUTPUT,
-  VXLAN_GPE_TRANSIT_IOAM_NEXT_DROP,
-  VXLAN_GPE_TRANSIT_IOAM_N_NEXT
-} vxlan_gpe_transit_ioam_next_t;
-
-
-/* *INDENT-OFF* */
-VNET_FEATURE_INIT (vxlan_gpe_transit_ioam, static) =
-{
-  .arc_name = "ip4-output",
-  .node_name = "vxlan-gpe-transit-ioam",
-  .runs_before = VNET_FEATURES ("interface-output"),
-};
-/* *INDENT-ON* */
-
-static uword
-vxlan_gpe_transit_ioam (vlib_main_t * vm,
-			vlib_node_runtime_t * node, vlib_frame_t * from_frame)
-{
-  u32 n_left_from, next_index, *from, *to_next;
-
-  from = vlib_frame_vector_args (from_frame);
-  n_left_from = from_frame->n_vectors;
-
-  next_index = node->cached_next_index;
-
-  while (n_left_from > 0)
-    {
-      u32 n_left_to_next;
-
-      vlib_get_next_frame (vm, node, next_index, to_next, n_left_to_next);
-
-
-      while (n_left_from > 0 && n_left_to_next > 0)
-	{
-	  u32 bi0;
-	  vlib_buffer_t *b0;
-	  u32 next0 = VXLAN_GPE_TRANSIT_IOAM_NEXT_OUTPUT;
-
-	  bi0 = from[0];
-	  to_next[0] = bi0;
-	  from += 1;
-	  to_next += 1;
-	  n_left_from -= 1;
-	  n_left_to_next -= 1;
-	  ip4_header_t *ip0;
-	  u32 iph_offset = 0;
-
-	  b0 = vlib_get_buffer (vm, bi0);
-	  iph_offset = vnet_buffer (b0)->ip.save_rewrite_length;
-	  ip0 = (ip4_header_t *) ((u8 *) vlib_buffer_get_current (b0)
-				  + iph_offset);
-
-	  /* just forward non ipv4 packets */
-	  if (PREDICT_FALSE
-	      ((ip0->ip_version_and_header_length & 0xF0) == 0x40))
-	    {
-	      /* ipv4 packets */
-	      udp_header_t *udp_hdr0 = (udp_header_t *) (ip0 + 1);
-	      if (PREDICT_FALSE
-		  ((ip0->protocol == IP_PROTOCOL_UDP) &&
-		   (clib_net_to_host_u16 (udp_hdr0->dst_port) ==
-		    UDP_DST_PORT_VXLAN_GPE)))
-		{
-
-		  /* Check the iOAM header */
-		  vxlan_gpe_header_t *gpe_hdr0 =
-		    (vxlan_gpe_header_t *) (udp_hdr0 + 1);
-
-		  if (PREDICT_FALSE
-		      (gpe_hdr0->protocol == VXLAN_GPE_PROTOCOL_IOAM))
-		    {
-		      uword *t = NULL;
-		      vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-		      fib_prefix_t key4;
-		      clib_memset (&key4, 0, sizeof (key4));
-		      key4.fp_proto = FIB_PROTOCOL_IP4;
-		      key4.fp_addr.ip4.as_u32 = ip0->dst_address.as_u32;
-		      t = hash_get_mem (hm->dst_by_ip4, &key4);
-		      if (t)
-			{
-
-
-			  vlib_buffer_advance (b0,
-					       (word) (sizeof
-						       (ethernet_header_t)));
-			  vxlan_gpe_encap_decap_ioam_v4_one_inline (vm, node,
-								    b0,
-								    &next0,
-								    VXLAN_GPE_TRANSIT_IOAM_NEXT_DROP,
-								    1
-								    /* use_adj */
-			    );
-			  vlib_buffer_advance (b0,
-					       -(word) (sizeof
-							(ethernet_header_t)));
-			}
-		    }
-		}
-	    }
-
-	  vlib_validate_buffer_enqueue_x1 (vm, node, next_index, to_next,
-					   n_left_to_next, bi0, next0);
-	}
-
-      vlib_put_next_frame (vm, node, next_index, n_left_to_next);
-    }
-
-  return from_frame->n_vectors;
-}
-
-/* *INDENT-OFF* */
-VLIB_REGISTER_NODE (vxlan_gpe_transit_ioam_node) = {
-  .function = vxlan_gpe_transit_ioam,
-  .name = "vxlan-gpe-transit-ioam",
-  .vector_size = sizeof (u32),
-  .format_trace = format_vxlan_gpe_ioam_v4_trace,
-  .type = VLIB_NODE_TYPE_INTERNAL,
-
-  .n_errors = ARRAY_LEN(vxlan_gpe_transit_ioam_error_strings),
-  .error_strings = vxlan_gpe_transit_ioam_error_strings,
-
-  .n_next_nodes = VXLAN_GPE_TRANSIT_IOAM_N_NEXT,
-
-  .next_nodes = {
-        [VXLAN_GPE_TRANSIT_IOAM_NEXT_OUTPUT] = "interface-output",
-        [VXLAN_GPE_TRANSIT_IOAM_NEXT_DROP] = "error-drop",
-  },
-
-};
-/* *INDENT-ON* */
-
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-vxlan-gpe/ioam_vxlan_gpe.api b/ioam/lib-vxlan-gpe/ioam_vxlan_gpe.api
deleted file mode 100644
index 36dc1a4..0000000
--- a/ioam/lib-vxlan-gpe/ioam_vxlan_gpe.api
+++ /dev/null
@@ -1,109 +0,0 @@
-/* Hey Emacs use -*- mode: C -*- */
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-option version = "1.0.0";
-import "vnet/ip/ip_types.api";
-
-/** \brief iOAM Over VxLAN-GPE - Set iOAM transport for VxLAN-GPE
-    @param client_index - opaque cookie to identify the sender
-    @param context - sender context, to match reply w/ request
-    @param id - profile id
-    @param trace_ppc - Trace PPC (none/encap/decap)
-    @param pow_enable - Proof of Work enabled or not flag
-    @param trace_enable - iOAM Trace enabled or not flag
-
-*/
-autoreply define vxlan_gpe_ioam_enable {
-  u32 client_index;
-  u32 context;
-  u16 id;
-  u8 trace_ppc;
-  bool pow_enable;
-  bool trace_enable;
-};
-
-/** \brief iOAM for VxLAN-GPE disable
-    @param client_index - opaque cookie to identify the sender
-    @param context - sender context, to match reply w/ request
-    @param id - profile id
-*/
-autoreply define vxlan_gpe_ioam_disable
-{
-  u32 client_index;
-  u32 context;
-  u16 id;
-};
-
-/** \brief Enable iOAM for a VNI (VXLAN-GPE)
-    @param client_index - opaque cookie to identify the sender
-    @param context - sender context, to match reply w/ request
-    @param vni - VXLAN-GPE VNI
-    @param local - IPv4/6 Address of the local VTEP
-    @param remote - IPv4/6 Address of the remote VTEP
-
-*/
-autoreply define vxlan_gpe_ioam_vni_enable {
-  u32 client_index;
-  u32 context;
-  u32 vni;
-  vl_api_address_t local;
-  vl_api_address_t remote;
-};
-
-/** \brief Disable iOAM for a VNI (VXLAN-GPE)
-    @param client_index - opaque cookie to identify the sender
-    @param context - sender context, to match reply w/ request
-    @param vni - VXLAN-GPE VNI
-    @param local - IPv4/6 Address of the local VTEP
-    @param remote - IPv4/6 Address of the remote VTEP
-
-*/
-autoreply define vxlan_gpe_ioam_vni_disable {
-  u32 client_index;
-  u32 context;
-  u32 vni;
-  vl_api_address_t local;
-  vl_api_address_t remote;
-};
-
-/** \brief Enable iOAM for a VXLAN-GPE transit
-    @param client_index - opaque cookie to identify the sender
-    @param context - sender context, to match reply w/ request
-    @param dst_addr - IPv4/6 Address of the local VTEP
-    @param outer_fib_index- FIB index
-
-*/
-autoreply define vxlan_gpe_ioam_transit_enable {
-  u32 client_index;
-  u32 context;
-  u32 outer_fib_index;
-  vl_api_address_t dst_addr;
-};
-
-/** \brief Disable iOAM for VXLAN-GPE transit
-    @param client_index - opaque cookie to identify the sender
-    @param context - sender context, to match reply w/ request
-    @param dst_addr - IPv4/6 Address of the local VTEP
-    @param outer_fib_index- FIB index
-
-*/
-autoreply define vxlan_gpe_ioam_transit_disable {
-  u32 client_index;
-  u32 context;
-  u32 outer_fib_index;
-  vl_api_address_t dst_addr;
-};
-
diff --git a/ioam/lib-vxlan-gpe/vxlan_gpe_api.c b/ioam/lib-vxlan-gpe/vxlan_gpe_api.c
deleted file mode 100644
index d61832d..0000000
--- a/ioam/lib-vxlan-gpe/vxlan_gpe_api.c
+++ /dev/null
@@ -1,254 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- *------------------------------------------------------------------
- * vxlan_gpe_api.c - iOAM VxLAN-GPE related APIs to create
- *               and maintain profiles
- *------------------------------------------------------------------
- */
-
-#include <vnet/vnet.h>
-#include <vnet/plugin/plugin.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam.h>
-#include <vlibapi/api_helper_macros.h>
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-#include <vnet/format_fns.h>
-#include <vnet/ip/ip_types_api.h>
-#include <vnet/udp/udp_local.h>
-
-/* define message IDs */
-#include <ioam/lib-vxlan-gpe/ioam_vxlan_gpe.api_enum.h>
-#include <ioam/lib-vxlan-gpe/ioam_vxlan_gpe.api_types.h>
-
-static void vl_api_vxlan_gpe_ioam_enable_t_handler
-  (vl_api_vxlan_gpe_ioam_enable_t * mp)
-{
-  int rv = 0;
-  vl_api_vxlan_gpe_ioam_enable_reply_t *rmp;
-  clib_error_t *error;
-
-  /* Ignoring the profile id as currently a single profile
-   * is supported */
-  error =
-    vxlan_gpe_ioam_enable (mp->trace_enable, mp->pow_enable, mp->trace_ppc);
-  if (error)
-    {
-      clib_error_report (error);
-      rv = clib_error_get_code (error);
-    }
-
-  REPLY_MACRO (VL_API_VXLAN_GPE_IOAM_ENABLE_REPLY);
-}
-
-static void vl_api_vxlan_gpe_ioam_disable_t_handler
-  (vl_api_vxlan_gpe_ioam_disable_t * mp)
-{
-  int rv = 0;
-  vl_api_vxlan_gpe_ioam_disable_reply_t *rmp;
-  clib_error_t *error;
-
-  /* Ignoring the profile id as currently a single profile
-   * is supported */
-  error = vxlan_gpe_ioam_disable (0, 0, 0);
-  if (error)
-    {
-      clib_error_report (error);
-      rv = clib_error_get_code (error);
-    }
-
-  REPLY_MACRO (VL_API_VXLAN_GPE_IOAM_DISABLE_REPLY);
-}
-
-static void vl_api_vxlan_gpe_ioam_vni_enable_t_handler
-  (vl_api_vxlan_gpe_ioam_vni_enable_t * mp)
-{
-  int rv = 0;
-  vl_api_vxlan_gpe_ioam_vni_enable_reply_t *rmp;
-  clib_error_t *error;
-  vxlan4_gpe_tunnel_key_t key4;
-  uword *p = NULL;
-  vxlan_gpe_main_t *gm = &vxlan_gpe_main;
-  vxlan_gpe_tunnel_t *t = 0;
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-  u32 vni;
-
-
-  if (clib_net_to_host_u32 (mp->local.af) == ADDRESS_IP4 &&
-      clib_net_to_host_u32 (mp->remote.af) == ADDRESS_IP4)
-    {
-      clib_memcpy (&key4.local, &mp->local.un.ip4, sizeof (key4.local));
-      clib_memcpy (&key4.remote, &mp->remote.un.ip4, sizeof (key4.remote));
-      vni = clib_net_to_host_u32 (mp->vni);
-      key4.vni = clib_host_to_net_u32 (vni << 8);
-      key4.port = clib_host_to_net_u16 (UDP_DST_PORT_VXLAN_GPE);
-
-      p = hash_get_mem (gm->vxlan4_gpe_tunnel_by_key, &key4);
-    }
-  else
-    {
-      return;
-    }
-
-  if (!p)
-    return;
-
-  t = pool_elt_at_index (gm->tunnels, p[0]);
-
-  error = vxlan_gpe_ioam_set (t, hm->has_trace_option,
-			      hm->has_pot_option,
-			      hm->has_ppc_option, 0 /* is_ipv6 */ );
-
-
-  if (error)
-    {
-      clib_error_report (error);
-      rv = clib_error_get_code (error);
-    }
-
-  REPLY_MACRO (VL_API_VXLAN_GPE_IOAM_VNI_ENABLE_REPLY);
-}
-
-
-static void vl_api_vxlan_gpe_ioam_vni_disable_t_handler
-  (vl_api_vxlan_gpe_ioam_vni_disable_t * mp)
-{
-  int rv = 0;
-  vl_api_vxlan_gpe_ioam_vni_enable_reply_t *rmp;
-  clib_error_t *error;
-  vxlan4_gpe_tunnel_key_t key4;
-  uword *p = NULL;
-  vxlan_gpe_main_t *gm = &vxlan_gpe_main;
-  vxlan_gpe_tunnel_t *t = 0;
-  u32 vni;
-
-
-  if (clib_net_to_host_u32 (mp->local.af) == ADDRESS_IP4 &&
-      clib_net_to_host_u32 (mp->remote.af) == ADDRESS_IP4)
-    {
-      clib_memcpy (&key4.local, &mp->local, sizeof (key4.local));
-      clib_memcpy (&key4.remote, &mp->remote, sizeof (key4.remote));
-      vni = clib_net_to_host_u32 (mp->vni);
-      key4.vni = clib_host_to_net_u32 (vni << 8);
-      key4.port = clib_host_to_net_u16 (UDP_DST_PORT_VXLAN_GPE);
-
-      p = hash_get_mem (gm->vxlan4_gpe_tunnel_by_key, &key4);
-    }
-  else
-    {
-      return;
-    }
-
-  if (!p)
-    return;
-
-  t = pool_elt_at_index (gm->tunnels, p[0]);
-
-  error = vxlan_gpe_ioam_clear (t, 0, 0, 0, 0);
-
-
-  if (error)
-    {
-      clib_error_report (error);
-      rv = clib_error_get_code (error);
-    }
-
-
-  REPLY_MACRO (VL_API_VXLAN_GPE_IOAM_VNI_DISABLE_REPLY);
-}
-
-static void vl_api_vxlan_gpe_ioam_transit_enable_t_handler
-  (vl_api_vxlan_gpe_ioam_transit_enable_t * mp)
-{
-  int rv = 0;
-  vl_api_vxlan_gpe_ioam_transit_enable_reply_t *rmp;
-  vxlan_gpe_ioam_main_t *sm = &vxlan_gpe_ioam_main;
-  ip46_address_t dst_addr;
-
-  ip_address_decode (&mp->dst_addr, &dst_addr);
-  bool is_ip6 = clib_net_to_host_u32 (mp->dst_addr.af) == ADDRESS_IP6;
-  rv = vxlan_gpe_enable_disable_ioam_for_dest (sm->vlib_main,
-					       dst_addr,
-					       ntohl (mp->outer_fib_index),
-					       is_ip6, 1 /* is_add */ );
-
-  REPLY_MACRO (VL_API_VXLAN_GPE_IOAM_TRANSIT_ENABLE_REPLY);
-}
-
-static void vl_api_vxlan_gpe_ioam_transit_disable_t_handler
-  (vl_api_vxlan_gpe_ioam_transit_disable_t * mp)
-{
-  int rv = 0;
-  vl_api_vxlan_gpe_ioam_transit_disable_reply_t *rmp;
-  vxlan_gpe_ioam_main_t *sm = &vxlan_gpe_ioam_main;
-  ip46_address_t dst_addr;
-
-  ip_address_decode (&mp->dst_addr, &dst_addr);
-  bool is_ip6 = clib_net_to_host_u32 (mp->dst_addr.af) == ADDRESS_IP6;
-  rv = vxlan_gpe_ioam_disable_for_dest (sm->vlib_main,
-					dst_addr,
-					ntohl (mp->outer_fib_index), is_ip6);
-  REPLY_MACRO (VL_API_VXLAN_GPE_IOAM_TRANSIT_DISABLE_REPLY);
-}
-
-#include <ioam/lib-vxlan-gpe/ioam_vxlan_gpe.api.c>
-static clib_error_t *
-ioam_vxlan_gpe_init (vlib_main_t * vm)
-{
-  vxlan_gpe_ioam_main_t *sm = &vxlan_gpe_ioam_main;
-  u32 encap_node_index = vxlan_gpe_encap_ioam_v4_node.index;
-  u32 decap_node_index = vxlan_gpe_decap_ioam_v4_node.index;
-  vlib_node_t *vxlan_gpe_encap_node = NULL;
-  vlib_node_t *vxlan_gpe_decap_node = NULL;
-  uword next_node = 0;
-
-  sm->vlib_main = vm;
-  sm->vnet_main = vnet_get_main ();
-  sm->unix_time_0 = (u32) time (0);	/* Store starting time */
-  sm->vlib_time_0 = vlib_time_now (vm);
-
-  /* Ask for a correctly-sized block of API message decode slots */
-  sm->msg_id_base = setup_message_id_table ();
-
-  /* Hook the ioam-encap node to vxlan-gpe-encap */
-  vxlan_gpe_encap_node = vlib_get_node_by_name (vm, (u8 *) "vxlan-gpe-encap");
-  sm->encap_v4_next_node =
-    vlib_node_add_next (vm, vxlan_gpe_encap_node->index, encap_node_index);
-
-  vxlan_gpe_decap_node =
-    vlib_get_node_by_name (vm, (u8 *) "vxlan4-gpe-input");
-  next_node =
-    vlib_node_add_next (vm, vxlan_gpe_decap_node->index, decap_node_index);
-  vxlan_gpe_register_decap_protocol (VXLAN_GPE_PROTOCOL_IOAM, next_node);
-
-  vec_new (vxlan_gpe_ioam_sw_interface_t, pool_elts (sm->sw_interfaces));
-  sm->dst_by_ip4 = hash_create_mem (0, sizeof (fib_prefix_t), sizeof (uword));
-
-  sm->dst_by_ip6 = hash_create_mem (0, sizeof (fib_prefix_t), sizeof (uword));
-
-  vxlan_gpe_ioam_interface_init ();
-
-  return 0;
-}
-
-VLIB_INIT_FUNCTION (ioam_vxlan_gpe_init);
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-vxlan-gpe/vxlan_gpe_ioam.c b/ioam/lib-vxlan-gpe/vxlan_gpe_ioam.c
deleted file mode 100644
index 870de92..0000000
--- a/ioam/lib-vxlan-gpe/vxlan_gpe_ioam.c
+++ /dev/null
@@ -1,765 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <vnet/vxlan-gpe/vxlan_gpe.h>
-#include <vnet/vxlan-gpe/vxlan_gpe_packet.h>
-#include <vnet/ip/format.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam.h>
-#include <vnet/dpo/load_balance.h>
-#include <vnet/fib/ip4_fib.h>
-#include <vnet/fib/fib_entry.h>
-#include <vnet/udp/udp_local.h>
-
-vxlan_gpe_ioam_main_t vxlan_gpe_ioam_main;
-
-int
-vxlan_gpe_ioam_set_rewrite (vxlan_gpe_tunnel_t * t, int has_trace_option,
-			    int has_pot_option, int has_ppc_option,
-			    u8 ipv6_set)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-  u32 size;
-  vxlan_gpe_ioam_hdr_t *vxlan_gpe_ioam_hdr;
-  u8 *current;
-  u8 trace_data_size = 0;
-  u8 pot_data_size = 0;
-
-  if (has_trace_option == 0 && has_pot_option == 0)
-    return -1;
-
-  /* Work out how much space we need */
-  size = sizeof (vxlan_gpe_ioam_hdr_t);
-
-  if (has_trace_option
-      && hm->add_options[VXLAN_GPE_OPTION_TYPE_IOAM_TRACE] != 0)
-    {
-      size += sizeof (vxlan_gpe_ioam_option_t);
-      size += hm->options_size[VXLAN_GPE_OPTION_TYPE_IOAM_TRACE];
-    }
-  if (has_pot_option
-      && hm->add_options[VXLAN_GPE_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT] != 0)
-    {
-      size += sizeof (vxlan_gpe_ioam_option_t);
-      size += hm->options_size[VXLAN_GPE_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT];
-    }
-
-  t->rewrite_size = size;
-
-  if (!ipv6_set)
-    {
-      vxlan4_gpe_rewrite (t, size, VXLAN_GPE_PROTOCOL_IOAM,
-			  hm->encap_v4_next_node);
-      vxlan_gpe_ioam_hdr =
-	(vxlan_gpe_ioam_hdr_t *) (t->rewrite +
-				  sizeof (ip4_vxlan_gpe_header_t));
-    }
-  else
-    {
-      vxlan6_gpe_rewrite (t, size, VXLAN_GPE_PROTOCOL_IOAM,
-			  VXLAN_GPE_ENCAP_NEXT_IP6_LOOKUP);
-      vxlan_gpe_ioam_hdr =
-	(vxlan_gpe_ioam_hdr_t *) (t->rewrite +
-				  sizeof (ip6_vxlan_gpe_header_t));
-    }
-
-
-  vxlan_gpe_ioam_hdr->type = VXLAN_GPE_PROTOCOL_IOAM;
-  /* Length of the header in octets */
-  vxlan_gpe_ioam_hdr->length = size;
-  vxlan_gpe_ioam_hdr->protocol = t->protocol;
-  current = (u8 *) vxlan_gpe_ioam_hdr + sizeof (vxlan_gpe_ioam_hdr_t);
-
-  if (has_trace_option
-      && hm->add_options[VXLAN_GPE_OPTION_TYPE_IOAM_TRACE] != 0)
-    {
-      if (0 != hm->add_options[VXLAN_GPE_OPTION_TYPE_IOAM_TRACE] (current,
-								  &trace_data_size))
-	return -1;
-      current += trace_data_size;
-    }
-  if (has_pot_option
-      && hm->add_options[VXLAN_GPE_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT] != 0)
-    {
-      pot_data_size =
-	hm->options_size[VXLAN_GPE_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT];
-      if (0 ==
-	  hm->add_options[VXLAN_GPE_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT]
-	  (current, &pot_data_size))
-	current += pot_data_size;
-    }
-
-  return 0;
-}
-
-int
-vxlan_gpe_ioam_clear_rewrite (vxlan_gpe_tunnel_t * t, int has_trace_option,
-			      int has_pot_option, int has_ppc_option,
-			      u8 ipv6_set)
-{
-
-  t->rewrite_size = 0;
-
-  if (!ipv6_set)
-    {
-      vxlan4_gpe_rewrite (t, 0, 0, VXLAN_GPE_ENCAP_NEXT_IP4_LOOKUP);
-    }
-  else
-    {
-      vxlan6_gpe_rewrite (t, 0, 0, VXLAN_GPE_ENCAP_NEXT_IP6_LOOKUP);
-    }
-
-
-  return 0;
-}
-
-clib_error_t *
-vxlan_gpe_ioam_clear (vxlan_gpe_tunnel_t * t,
-		      int has_trace_option, int has_pot_option,
-		      int has_ppc_option, u8 ipv6_set)
-{
-  int rv;
-  rv = vxlan_gpe_ioam_clear_rewrite (t, 0, 0, 0, 0);
-
-  if (rv == 0)
-    {
-      return (0);
-    }
-  else
-    {
-      return clib_error_return_code (0, rv, 0,
-				     "vxlan_gpe_ioam_clear_rewrite returned %d",
-				     rv);
-    }
-
-}
-
-
-clib_error_t *
-vxlan_gpe_ioam_set (vxlan_gpe_tunnel_t * t,
-		    int has_trace_option, int has_pot_option,
-		    int has_ppc_option, u8 ipv6_set)
-{
-  int rv;
-  rv = vxlan_gpe_ioam_set_rewrite (t, has_trace_option,
-				   has_pot_option, has_ppc_option, ipv6_set);
-
-  if (rv == 0)
-    {
-      return (0);
-    }
-  else
-    {
-      return clib_error_return_code (0, rv, 0,
-				     "vxlan_gpe_ioam_set_rewrite returned %d",
-				     rv);
-    }
-
-}
-
-static void
-vxlan_gpe_set_clear_output_feature_on_intf (vlib_main_t * vm,
-					    u32 sw_if_index0, u8 is_add)
-{
-
-
-
-  vnet_feature_enable_disable ("ip4-output", "vxlan-gpe-transit-ioam",
-			       sw_if_index0, is_add,
-			       0 /* void *feature_config */ ,
-			       0 /* u32 n_feature_config_bytes */ );
-  return;
-}
-
-void
-vxlan_gpe_clear_output_feature_on_all_intfs (vlib_main_t * vm)
-{
-  vnet_sw_interface_t *si = 0;
-  vnet_main_t *vnm = vnet_get_main ();
-  vnet_interface_main_t *im = &vnm->interface_main;
-
-  pool_foreach (si, im->sw_interfaces)
-  {
-    vxlan_gpe_set_clear_output_feature_on_intf (vm, si->sw_if_index, 0);
-  }
-  return;
-}
-
-
-extern fib_forward_chain_type_t
-fib_entry_get_default_chain_type (const fib_entry_t * fib_entry);
-
-int
-vxlan_gpe_enable_disable_ioam_for_dest (vlib_main_t * vm,
-					ip46_address_t dst_addr,
-					u32 outer_fib_index,
-					u8 is_ipv4, u8 is_add)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-  u32 fib_index0 = 0;
-  u32 sw_if_index0 = ~0;
-
-  fib_node_index_t fei = ~0;
-  fib_entry_t *fib_entry;
-  u32 adj_index0;
-  ip_adjacency_t *adj0;
-  fib_prefix_t fib_prefix;
-  //fib_forward_chain_type_t fct;
-  load_balance_t *lb_m, *lb_b;
-  const dpo_id_t *dpo0, *dpo1;
-  u32 i, j;
-  //vnet_hw_interface_t *hw;
-
-  if (is_ipv4)
-    {
-      clib_memset (&fib_prefix, 0, sizeof (fib_prefix_t));
-      fib_prefix.fp_len = 32;
-      fib_prefix.fp_proto = FIB_PROTOCOL_IP4;
-      fib_prefix.fp_addr = dst_addr;
-    }
-  else
-    {
-      return 0;
-    }
-
-  fei = fib_table_lookup (fib_index0, &fib_prefix);
-  fib_entry = fib_entry_get (fei);
-
-  //fct = fib_entry_get_default_chain_type (fib_entry);
-
-  if (!dpo_id_is_valid (&fib_entry->fe_lb /*[fct] */ ))
-    {
-      return (-1);
-    }
-
-  lb_m = load_balance_get (fib_entry->fe_lb /*[fct] */ .dpoi_index);
-
-  for (i = 0; i < lb_m->lb_n_buckets; i++)
-    {
-      dpo0 = load_balance_get_bucket_i (lb_m, i);
-
-      if (dpo0->dpoi_type == DPO_LOAD_BALANCE)
-	{
-	  lb_b = load_balance_get (dpo0->dpoi_index);
-
-	  for (j = 0; j < lb_b->lb_n_buckets; j++)
-	    {
-	      dpo1 = load_balance_get_bucket_i (lb_b, j);
-
-	      if (dpo1->dpoi_type == DPO_ADJACENCY)
-		{
-		  adj_index0 = dpo1->dpoi_index;
-
-		  if (ADJ_INDEX_INVALID == adj_index0)
-		    {
-		      continue;
-		    }
-
-		  adj0 = adj_get (adj_index0);
-		  sw_if_index0 = adj0->rewrite_header.sw_if_index;
-
-		  if (~0 == sw_if_index0)
-		    {
-		      continue;
-		    }
-
-
-		  if (is_add)
-		    {
-		      vnet_feature_enable_disable ("ip4-output",
-						   "vxlan-gpe-transit-ioam",
-						   sw_if_index0, is_add, 0
-						   /* void *feature_config */
-						   , 0	/* u32 n_feature_config_bytes */
-			);
-
-		      vec_validate_init_empty (hm->bool_ref_by_sw_if_index,
-					       sw_if_index0, ~0);
-		      hm->bool_ref_by_sw_if_index[sw_if_index0] = 1;
-		    }
-		  else
-		    {
-		      hm->bool_ref_by_sw_if_index[sw_if_index0] = ~0;
-		    }
-		}
-	    }
-	}
-    }
-
-  if (is_ipv4)
-    {
-
-      uword *t = NULL;
-      vxlan_gpe_ioam_dest_tunnels_t *t1;
-      fib_prefix_t key4, *key4_copy;
-      hash_pair_t *hp;
-      clib_memset (&key4, 0, sizeof (key4));
-      key4.fp_proto = FIB_PROTOCOL_IP4;
-      key4.fp_addr.ip4.as_u32 = fib_prefix.fp_addr.ip4.as_u32;
-      t = hash_get_mem (hm->dst_by_ip4, &key4);
-      if (is_add)
-	{
-	  if (t)
-	    {
-	      return 0;
-	    }
-	  pool_get_aligned (hm->dst_tunnels, t1, CLIB_CACHE_LINE_BYTES);
-	  clib_memset (t1, 0, sizeof (*t1));
-	  t1->fp_proto = FIB_PROTOCOL_IP4;
-	  t1->dst_addr.ip4.as_u32 = fib_prefix.fp_addr.ip4.as_u32;
-	  key4_copy = clib_mem_alloc (sizeof (*key4_copy));
-	  clib_memcpy (key4_copy, &key4, sizeof (*key4_copy));
-	  hash_set_mem (hm->dst_by_ip4, key4_copy, t1 - hm->dst_tunnels);
-	  /*
-	   * Attach to the FIB entry for the VxLAN-GPE destination
-	   * and become its child. The dest route will invoke a callback
-	   * when the fib entry changes, it can be used to
-	   * re-program the output feature on the egress interface.
-	   */
-
-	  const fib_prefix_t tun_dst_pfx = {
-	    .fp_len = 32,
-	    .fp_proto = FIB_PROTOCOL_IP4,
-	    .fp_addr = {.ip4 = t1->dst_addr.ip4,}
-	  };
-
-	  t1->fib_entry_index =
-	    fib_table_entry_special_add (outer_fib_index,
-					 &tun_dst_pfx,
-					 FIB_SOURCE_RR, FIB_ENTRY_FLAG_NONE);
-	  t1->sibling_index =
-	    fib_entry_child_add (t1->fib_entry_index,
-				 hm->fib_entry_type, t1 - hm->dst_tunnels);
-	  t1->outer_fib_index = outer_fib_index;
-
-	}
-      else
-	{
-	  if (!t)
-	    {
-	      return 0;
-	    }
-	  t1 = pool_elt_at_index (hm->dst_tunnels, t[0]);
-	  hp = hash_get_pair (hm->dst_by_ip4, &key4);
-	  key4_copy = (void *) (hp->key);
-	  hash_unset_mem (hm->dst_by_ip4, &key4);
-	  clib_mem_free (key4_copy);
-	  pool_put (hm->dst_tunnels, t1);
-	}
-    }
-  else
-    {
-      // TBD for IPv6
-    }
-
-  return 0;
-}
-
-void
-vxlan_gpe_refresh_output_feature_on_all_dest (void)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-  vxlan_gpe_ioam_dest_tunnels_t *t;
-  u32 i;
-  if (pool_elts (hm->dst_tunnels) == 0)
-    return;
-  vxlan_gpe_clear_output_feature_on_all_intfs (hm->vlib_main);
-  i = vec_len (hm->bool_ref_by_sw_if_index);
-  vec_free (hm->bool_ref_by_sw_if_index);
-  vec_validate_init_empty (hm->bool_ref_by_sw_if_index, i, ~0);
-  pool_foreach (t, hm->dst_tunnels)
-  {
-    vxlan_gpe_enable_disable_ioam_for_dest
-      (hm->vlib_main, t->dst_addr, t->outer_fib_index,
-       (t->fp_proto == FIB_PROTOCOL_IP4), 1 /* is_add */ );
-  }
-  return;
-}
-
-void
-vxlan_gpe_clear_output_feature_on_select_intfs (void)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-  u32 sw_if_index0 = 0;
-  for (sw_if_index0 = 0;
-       sw_if_index0 < vec_len (hm->bool_ref_by_sw_if_index); sw_if_index0++)
-    {
-      if (hm->bool_ref_by_sw_if_index[sw_if_index0] == 0xFF)
-	{
-	  vxlan_gpe_set_clear_output_feature_on_intf
-	    (hm->vlib_main, sw_if_index0, 0);
-	}
-    }
-
-  return;
-}
-
-static clib_error_t *
-vxlan_gpe_set_ioam_rewrite_command_fn (vlib_main_t *
-				       vm,
-				       unformat_input_t
-				       * input, vlib_cli_command_t * cmd)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-  ip46_address_t local, remote;
-  u8 local_set = 0;
-  u8 remote_set = 0;
-  u8 ipv4_set = 0;
-  u8 ipv6_set = 0;
-  u32 vni;
-  u8 vni_set = 0;
-  u8 disable = 0;
-  clib_error_t *rv = 0;
-  vxlan4_gpe_tunnel_key_t key4;
-  vxlan6_gpe_tunnel_key_t key6;
-  uword *p;
-  vxlan_gpe_main_t *gm = &vxlan_gpe_main;
-  vxlan_gpe_tunnel_t *t = 0;
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "local %U", unformat_ip4_address, &local.ip4))
-	{
-	  local_set = 1;
-	  ipv4_set = 1;
-	}
-      else
-	if (unformat (input, "remote %U", unformat_ip4_address, &remote.ip4))
-	{
-	  remote_set = 1;
-	  ipv4_set = 1;
-	}
-      else if (unformat (input, "local %U", unformat_ip6_address, &local.ip6))
-	{
-	  local_set = 1;
-	  ipv6_set = 1;
-	}
-      else
-	if (unformat (input, "remote %U", unformat_ip6_address, &remote.ip6))
-	{
-	  remote_set = 1;
-	  ipv6_set = 1;
-	}
-      else if (unformat (input, "vni %d", &vni))
-	vni_set = 1;
-      else if (unformat (input, "disable"))
-	disable = 1;
-      else
-	break;
-    }
-
-  if (local_set == 0)
-    return clib_error_return (0, "tunnel local address not specified");
-  if (remote_set == 0)
-    return clib_error_return (0, "tunnel remote address not specified");
-  if (ipv4_set && ipv6_set)
-    return clib_error_return (0, "both IPv4 and IPv6 addresses specified");
-  if ((ipv4_set
-       && memcmp (&local.ip4, &remote.ip4,
-		  sizeof (local.ip4)) == 0) || (ipv6_set
-						&&
-						memcmp
-						(&local.ip6,
-						 &remote.ip6,
-						 sizeof (local.ip6)) == 0))
-    return clib_error_return (0, "src and dst addresses are identical");
-  if (vni_set == 0)
-    return clib_error_return (0, "vni not specified");
-  if (!ipv6_set)
-    {
-      key4.local = local.ip4.as_u32;
-      key4.remote = remote.ip4.as_u32;
-      key4.vni = clib_host_to_net_u32 (vni << 8);
-      key4.port = clib_host_to_net_u16 (UDP_DST_PORT_VXLAN_GPE);
-      p = hash_get_mem (gm->vxlan4_gpe_tunnel_by_key, &key4);
-    }
-  else
-    {
-      key6.local.as_u64[0] = local.ip6.as_u64[0];
-      key6.local.as_u64[1] = local.ip6.as_u64[1];
-      key6.remote.as_u64[0] = remote.ip6.as_u64[0];
-      key6.remote.as_u64[1] = remote.ip6.as_u64[1];
-      key6.vni = clib_host_to_net_u32 (vni << 8);
-      key6.port = clib_host_to_net_u16 (UDP_DST_PORT_VXLAN6_GPE);
-      p = hash_get_mem (gm->vxlan6_gpe_tunnel_by_key, &key6);
-    }
-
-  if (!p)
-    return clib_error_return (0, "VxLAN Tunnel not found");
-  t = pool_elt_at_index (gm->tunnels, p[0]);
-  if (!disable)
-    {
-      rv =
-	vxlan_gpe_ioam_set (t, hm->has_trace_option,
-			    hm->has_pot_option, hm->has_ppc_option, ipv6_set);
-    }
-  else
-    {
-      rv = vxlan_gpe_ioam_clear (t, 0, 0, 0, 0);
-    }
-  return rv;
-}
-
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (vxlan_gpe_set_ioam_rewrite_cmd, static) = {
-  .path = "set vxlan-gpe-ioam",
-  .short_help = "set vxlan-gpe-ioam vxlan <src-ip> <dst_ip> <vnid> [disable]",
-  .function = vxlan_gpe_set_ioam_rewrite_command_fn,
-};
-/* *INDENT-ON* */
-
-
-
-clib_error_t *
-vxlan_gpe_ioam_enable (int has_trace_option,
-		       int has_pot_option, int has_ppc_option)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-  hm->has_trace_option = has_trace_option;
-  hm->has_pot_option = has_pot_option;
-  hm->has_ppc_option = has_ppc_option;
-  if (hm->has_trace_option)
-    {
-      vxlan_gpe_trace_profile_setup ();
-    }
-
-  return 0;
-}
-
-clib_error_t *
-vxlan_gpe_ioam_disable (int
-			has_trace_option,
-			int has_pot_option, int has_ppc_option)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-  hm->has_trace_option = has_trace_option;
-  hm->has_pot_option = has_pot_option;
-  hm->has_ppc_option = has_ppc_option;
-  if (!hm->has_trace_option)
-    {
-      vxlan_gpe_trace_profile_cleanup ();
-    }
-
-  return 0;
-}
-
-void
-vxlan_gpe_set_next_override (uword next)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-  hm->decap_v4_next_override = next;
-  return;
-}
-
-static clib_error_t *
-vxlan_gpe_set_ioam_flags_command_fn (vlib_main_t * vm,
-				     unformat_input_t
-				     * input, vlib_cli_command_t * cmd)
-{
-  int has_trace_option = 0;
-  int has_pot_option = 0;
-  int has_ppc_option = 0;
-  clib_error_t *rv = 0;
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "trace"))
-	has_trace_option = 1;
-      else if (unformat (input, "pot"))
-	has_pot_option = 1;
-      else if (unformat (input, "ppc encap"))
-	has_ppc_option = PPC_ENCAP;
-      else if (unformat (input, "ppc decap"))
-	has_ppc_option = PPC_DECAP;
-      else if (unformat (input, "ppc none"))
-	has_ppc_option = PPC_NONE;
-      else
-	break;
-    }
-
-
-  rv =
-    vxlan_gpe_ioam_enable (has_trace_option, has_pot_option, has_ppc_option);
-  return rv;
-}
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (vxlan_gpe_set_ioam_flags_cmd, static) =
-{
-.path = "set vxlan-gpe-ioam rewrite",
-.short_help = "set vxlan-gpe-ioam [trace] [pot] [ppc <encap|decap>]",
-.function = vxlan_gpe_set_ioam_flags_command_fn,};
-/* *INDENT-ON* */
-
-
-int vxlan_gpe_ioam_disable_for_dest
-  (vlib_main_t * vm, ip46_address_t dst_addr, u32 outer_fib_index,
-   u8 ipv4_set)
-{
-  vxlan_gpe_ioam_dest_tunnels_t *t;
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-
-  vxlan_gpe_enable_disable_ioam_for_dest (hm->vlib_main,
-					  dst_addr, outer_fib_index, ipv4_set,
-					  0);
-  if (pool_elts (hm->dst_tunnels) == 0)
-    {
-      vxlan_gpe_clear_output_feature_on_select_intfs ();
-      return 0;
-    }
-
-  pool_foreach (t, hm->dst_tunnels)
-  {
-    vxlan_gpe_enable_disable_ioam_for_dest
-      (hm->vlib_main,
-       t->dst_addr,
-       t->outer_fib_index,
-       (t->fp_proto == FIB_PROTOCOL_IP4), 1 /* is_add */ );
-  }
-  vxlan_gpe_clear_output_feature_on_select_intfs ();
-  return (0);
-
-}
-
-static clib_error_t *vxlan_gpe_set_ioam_transit_rewrite_command_fn
-  (vlib_main_t * vm, unformat_input_t * input, vlib_cli_command_t * cmd)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-  ip46_address_t dst_addr;
-  u8 dst_addr_set = 0;
-  u8 ipv4_set = 0;
-  u8 ipv6_set = 0;
-  u8 disable = 0;
-  clib_error_t *rv = 0;
-  u32 outer_fib_index = 0;
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "dst-ip %U", unformat_ip4_address, &dst_addr.ip4))
-	{
-	  dst_addr_set = 1;
-	  ipv4_set = 1;
-	}
-      else
-	if (unformat
-	    (input, "dst-ip %U", unformat_ip6_address, &dst_addr.ip6))
-	{
-	  dst_addr_set = 1;
-	  ipv6_set = 1;
-	}
-      else if (unformat (input, "outer-fib-index %d", &outer_fib_index))
-	{
-	}
-
-      else if (unformat (input, "disable"))
-	disable = 1;
-      else
-	break;
-    }
-
-  if (dst_addr_set == 0)
-    return clib_error_return (0, "tunnel destination address not specified");
-  if (ipv4_set && ipv6_set)
-    return clib_error_return (0, "both IPv4 and IPv6 addresses specified");
-  if (!disable)
-    {
-      vxlan_gpe_enable_disable_ioam_for_dest (hm->vlib_main,
-					      dst_addr, outer_fib_index,
-					      ipv4_set, 1);
-    }
-  else
-    {
-      vxlan_gpe_ioam_disable_for_dest
-	(vm, dst_addr, outer_fib_index, ipv4_set);
-    }
-  return rv;
-}
-
-       /* *INDENT-OFF* */
-VLIB_CLI_COMMAND (vxlan_gpe_set_ioam_transit_rewrite_cmd, static) = {
-  .path = "set vxlan-gpe-ioam-transit",
-  .short_help = "set vxlan-gpe-ioam-transit dst-ip <dst_ip> [outer-fib-index <outer_fib_index>] [disable]",
-  .function = vxlan_gpe_set_ioam_transit_rewrite_command_fn,
-};
-/* *INDENT-ON* */
-
-clib_error_t *clear_vxlan_gpe_ioam_rewrite_command_fn
-  (vlib_main_t * vm, unformat_input_t * input, vlib_cli_command_t * cmd)
-{
-  return (vxlan_gpe_ioam_disable (0, 0, 0));
-}
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (vxlan_gpe_clear_ioam_flags_cmd, static) =
-{
-.path = "clear vxlan-gpe-ioam rewrite",
-.short_help = "clear vxlan-gpe-ioam rewrite",
-.function = clear_vxlan_gpe_ioam_rewrite_command_fn,
-};
-/* *INDENT-ON* */
-
-
-/**
- * Function definition to backwalk a FIB node
- */
-static fib_node_back_walk_rc_t
-vxlan_gpe_ioam_back_walk (fib_node_t * node, fib_node_back_walk_ctx_t * ctx)
-{
-  vxlan_gpe_refresh_output_feature_on_all_dest ();
-  return (FIB_NODE_BACK_WALK_CONTINUE);
-}
-
-/**
- * Function definition to get a FIB node from its index
- */
-static fib_node_t *
-vxlan_gpe_ioam_fib_node_get (fib_node_index_t index)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-  return (&hm->node);
-}
-
-/**
- * Function definition to inform the FIB node that its last lock has gone.
- */
-static void
-vxlan_gpe_ioam_last_lock_gone (fib_node_t * node)
-{
-  ASSERT (0);
-}
-
-
-/*
- * Virtual function table registered by MPLS GRE tunnels
- * for participation in the FIB object graph.
- */
-const static fib_node_vft_t vxlan_gpe_ioam_vft = {
-  .fnv_get = vxlan_gpe_ioam_fib_node_get,
-  .fnv_last_lock = vxlan_gpe_ioam_last_lock_gone,
-  .fnv_back_walk = vxlan_gpe_ioam_back_walk,
-};
-
-void
-vxlan_gpe_ioam_interface_init (void)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-  hm->fib_entry_type =
-    fib_node_register_new_type ("vxlan-gpe", &vxlan_gpe_ioam_vft);
-  return;
-}
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-vxlan-gpe/vxlan_gpe_ioam.h b/ioam/lib-vxlan-gpe/vxlan_gpe_ioam.h
deleted file mode 100644
index 7c451ec..0000000
--- a/ioam/lib-vxlan-gpe/vxlan_gpe_ioam.h
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Copyright (c) 2015 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef __included_vxlan_gpe_ioam_h__
-#define __included_vxlan_gpe_ioam_h__
-
-#include <vnet/vxlan-gpe/vxlan_gpe.h>
-#include <vnet/vxlan-gpe/vxlan_gpe_packet.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam_packet.h>
-#include <vnet/ip/ip.h>
-
-
-typedef struct vxlan_gpe_sw_interface_
-{
-  u32 sw_if_index;
-} vxlan_gpe_ioam_sw_interface_t;
-
-typedef struct vxlan_gpe_dest_tunnels_
-{
-  ip46_address_t dst_addr;
-  u32 fp_proto;
-  u32 sibling_index;
-  fib_node_index_t fib_entry_index;
-  u32 outer_fib_index;
-} vxlan_gpe_ioam_dest_tunnels_t;
-
-typedef struct vxlan_gpe_ioam_main_
-{
-  /**
-   * Linkage into the FIB object graph
-   */
-  fib_node_t node;
-
-  /* time scale transform. Joy. */
-  u32 unix_time_0;
-  f64 vlib_time_0;
-
-
-  /* Trace option */
-  u8 has_trace_option;
-
-  /* Pot option */
-  u8 has_pot_option;
-
-#define PPC_NONE  0
-#define PPC_ENCAP 1
-#define PPC_DECAP 2
-  u8 has_ppc_option;
-
-  /* Array of function pointers to ADD and POP VxLAN-GPE iOAM option handling routines */
-  u8 options_size[256];
-  int (*add_options[256]) (u8 * rewrite_string, u8 * rewrite_size);
-  int (*pop_options[256]) (ip4_header_t * ip, vxlan_gpe_ioam_option_t * opt);
-
-  /* Array of function pointers to iOAM option handling routines */
-  int (*options[256]) (vlib_buffer_t * b, vxlan_gpe_ioam_option_t * opt,
-		       u8 is_ipv4, u8 use_adj);
-  u8 *(*trace[256]) (u8 * s, vxlan_gpe_ioam_option_t * opt);
-
-  /* API message ID base */
-  u16 msg_id_base;
-
-  /* Override to export for iOAM */
-  uword decap_v4_next_override;
-  uword decap_v6_next_override;
-
-  /* sequence of node graph for encap */
-  uword encap_v4_next_node;
-  uword encap_v6_next_node;
-
-  /* Software interfaces. */
-  vxlan_gpe_ioam_sw_interface_t *sw_interfaces;
-
-  /* hash ip4/ip6 -> list of destinations for doing transit iOAM operation */
-  vxlan_gpe_ioam_dest_tunnels_t *dst_tunnels;
-  uword *dst_by_ip4;
-  uword *dst_by_ip6;
-
-  /** per sw_if_index, to maintain bitmap */
-  u8 *bool_ref_by_sw_if_index;
-  fib_node_type_t fib_entry_type;
-
-  /** State convenience vlib_main_t */
-  vlib_main_t *vlib_main;
-  /** State convenience vnet_main_t */
-  vnet_main_t *vnet_main;
-
-
-} vxlan_gpe_ioam_main_t;
-extern vxlan_gpe_ioam_main_t vxlan_gpe_ioam_main;
-
-/*
- * Primary h-b-h handler trace support
- */
-typedef struct
-{
-  u32 next_index;
-  u32 trace_len;
-  u8 option_data[256];
-} ioam_trace_t;
-
-
-extern vlib_node_registration_t vxlan_gpe_encap_ioam_v4_node;
-extern vlib_node_registration_t vxlan_gpe_decap_ioam_v4_node;
-extern vlib_node_registration_t vxlan_gpe_transit_ioam_v4_node;
-
-clib_error_t *vxlan_gpe_ioam_enable (int has_trace_option, int has_pot_option,
-				     int has_ppc_option);
-
-clib_error_t *vxlan_gpe_ioam_disable (int has_trace_option,
-				      int has_pot_option, int has_ppc_option);
-
-clib_error_t *vxlan_gpe_ioam_set (vxlan_gpe_tunnel_t * t,
-				  int has_trace_option,
-				  int has_pot_option,
-				  int has_ppc_option, u8 ipv6_set);
-clib_error_t *vxlan_gpe_ioam_clear (vxlan_gpe_tunnel_t * t,
-				    int has_trace_option, int has_pot_option,
-				    int has_ppc_option, u8 ipv6_set);
-
-int vxlan_gpe_ioam_add_register_option (u8 option,
-					u8 size,
-					int rewrite_options (u8 *
-							     rewrite_string,
-							     u8 *
-							     rewrite_size));
-
-int vxlan_gpe_add_unregister_option (u8 option);
-
-int vxlan_gpe_ioam_register_option (u8 option,
-				    int options (vlib_buffer_t * b,
-						 vxlan_gpe_ioam_option_t *
-						 opt, u8 is_ipv4, u8 use_adj),
-				    u8 * trace (u8 * s,
-						vxlan_gpe_ioam_option_t *
-						opt));
-int vxlan_gpe_ioam_unregister_option (u8 option);
-
-int vxlan_gpe_trace_profile_setup (void);
-
-int vxlan_gpe_trace_profile_cleanup (void);
-extern void vxlan_gpe_ioam_interface_init (void);
-int
-vxlan_gpe_enable_disable_ioam_for_dest (vlib_main_t * vm,
-					ip46_address_t dst_addr,
-					u32 outer_fib_index,
-					u8 is_ipv4, u8 is_add);
-int vxlan_gpe_ioam_disable_for_dest
-  (vlib_main_t * vm, ip46_address_t dst_addr, u32 outer_fib_index,
-   u8 ipv4_set);
-
-typedef enum
-{
-  VXLAN_GPE_DECAP_IOAM_V4_NEXT_POP,
-  VXLAN_GPE_DECAP_IOAM_V4_NEXT_DROP,
-  VXLAN_GPE_DECAP_IOAM_V4_N_NEXT
-} vxlan_gpe_decap_ioam_v4_next_t;
-
-#endif
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-vxlan-gpe/vxlan_gpe_ioam_packet.h b/ioam/lib-vxlan-gpe/vxlan_gpe_ioam_packet.h
deleted file mode 100644
index a7ef859..0000000
--- a/ioam/lib-vxlan-gpe/vxlan_gpe_ioam_packet.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2015 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef __included_vxlan_gpe_ioam_packet_h__
-#define __included_vxlan_gpe_ioam_packet_h__
-
-#include <vnet/vxlan-gpe/vxlan_gpe.h>
-#include <vnet/vxlan-gpe/vxlan_gpe_packet.h>
-#include <vnet/ip/ip.h>
-
-
-
-#define VXLAN_GPE_OPTION_TYPE_IOAM_TRACE   59
-#define VXLAN_GPE_OPTION_TYPE_IOAM_PROOF_OF_TRANSIT 60
-
-/**
- * @brief VXLAN GPE Extension (iOAM) Header definition
- */
-typedef struct
-{
-  u8 type;
-  u8 length;
-  /** Reserved */
-  u8 reserved;
-  /** see vxlan_gpe_protocol_t */
-  u8 protocol;
-} vxlan_gpe_ioam_hdr_t;
-
-/*
- * @brief VxLAN GPE iOAM Option definition
- */
-typedef struct
-{
-  /* Option Type */
-  u8 type;
-  /* Length in octets of the option data field */
-  u8 length;
-} vxlan_gpe_ioam_option_t;
-
-
-#endif
-
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-vxlan-gpe/vxlan_gpe_ioam_trace.c b/ioam/lib-vxlan-gpe/vxlan_gpe_ioam_trace.c
deleted file mode 100644
index 9f25507..0000000
--- a/ioam/lib-vxlan-gpe/vxlan_gpe_ioam_trace.c
+++ /dev/null
@@ -1,546 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <vlib/vlib.h>
-#include <vnet/vnet.h>
-#include <vnet/pg/pg.h>
-#include <vppinfra/error.h>
-
-#include <vnet/vxlan-gpe/vxlan_gpe.h>
-#include <vnet/vxlan-gpe/vxlan_gpe_packet.h>
-
-#include <vppinfra/hash.h>
-#include <vppinfra/error.h>
-#include <vppinfra/elog.h>
-
-#include <ioam/lib-trace/trace_util.h>
-#include <ioam/lib-trace/trace_config.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam.h>
-
-/* Timestamp precision multipliers for seconds, milliseconds, microseconds
- * and nanoseconds respectively.
- */
-static f64 trace_tsp_mul[4] = { 1, 1e3, 1e6, 1e9 };
-
-typedef union
-{
-  u64 as_u64;
-  u32 as_u32[2];
-} time_u64_t;
-
-
-/* *INDENT-OFF* */
-typedef CLIB_PACKED(struct {
-  vxlan_gpe_ioam_option_t hdr;
-  u8 ioam_trace_type;
-  u8 data_list_elts_left;
-  u32 elts[0]; /* Variable type. So keep it generic */
-}) vxlan_gpe_ioam_trace_option_t;
-/* *INDENT-ON* */
-
-
-#define foreach_vxlan_gpe_ioam_trace_stats				\
-  _(SUCCESS, "Pkts updated with TRACE records")					\
-  _(FAILED, "Errors in TRACE due to lack of TRACE records")
-
-static char *vxlan_gpe_ioam_trace_stats_strings[] = {
-#define _(sym,string) string,
-  foreach_vxlan_gpe_ioam_trace_stats
-#undef _
-};
-
-typedef enum
-{
-#define _(sym,str) VXLAN_GPE_IOAM_TRACE_##sym,
-  foreach_vxlan_gpe_ioam_trace_stats
-#undef _
-    VXLAN_GPE_IOAM_TRACE_N_STATS,
-} vxlan_gpe_ioam_trace_stats_t;
-
-
-typedef struct
-{
-  /* stats */
-  u64 counters[ARRAY_LEN (vxlan_gpe_ioam_trace_stats_strings)];
-
-  /* convenience */
-  vlib_main_t *vlib_main;
-  vnet_main_t *vnet_main;
-} vxlan_gpe_ioam_trace_main_t;
-
-vxlan_gpe_ioam_trace_main_t vxlan_gpe_ioam_trace_main;
-
-int
-vxlan_gpe_ioam_add_register_option (u8 option,
-				    u8 size,
-				    int rewrite_options (u8 * rewrite_string,
-							 u8 * rewrite_size))
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-
-  ASSERT ((u32) option < ARRAY_LEN (hm->add_options));
-
-  /* Already registered */
-  if (hm->add_options[option])
-    return (-1);
-
-  hm->add_options[option] = rewrite_options;
-  hm->options_size[option] = size;
-
-  return (0);
-}
-
-int
-vxlan_gpe_add_unregister_option (u8 option)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-
-  ASSERT ((u32) option < ARRAY_LEN (hm->add_options));
-
-  /* Not registered */
-  if (!hm->add_options[option])
-    return (-1);
-
-  hm->add_options[option] = NULL;
-  hm->options_size[option] = 0;
-  return (0);
-}
-
-
-int
-vxlan_gpe_ioam_register_option (u8 option,
-                                int options (vlib_buffer_t * b,
-                                vxlan_gpe_ioam_option_t * opt,
-                                u8 is_ipv4, u8 use_adj),
-                                u8 * trace (u8 * s,
-                                vxlan_gpe_ioam_option_t * opt))
-{
-  vxlan_gpe_ioam_main_t *im = &vxlan_gpe_ioam_main;
-
-  ASSERT ((u32) option < ARRAY_LEN (im->options));
-
-  /* Already registered */
-  if (im->options[option])
-    return (-1);
-
-  im->options[option] = options;
-  im->trace[option] = trace;
-
-  return (0);
-}
-
-int
-vxlan_gpe_ioam_unregister_option (u8 option)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-
-  ASSERT ((u32) option < ARRAY_LEN (hm->options));
-
-  /* Not registered */
-  if (!hm->options[option])
-    return (-1);
-
-  hm->options[option] = NULL;
-  hm->trace[option] = NULL;
-
-  return (0);
-}
-
-
-always_inline void
-vxlan_gpe_ioam_trace_stats_increment_counter (u32 counter_index,
-					      u64 increment)
-{
-  vxlan_gpe_ioam_trace_main_t *hm = &vxlan_gpe_ioam_trace_main;
-
-  hm->counters[counter_index] += increment;
-}
-
-
-static u8 *
-format_ioam_data_list_element (u8 * s, va_list * args)
-{
-  u32 *elt = va_arg (*args, u32 *);
-  u8 *trace_type_p = va_arg (*args, u8 *);
-  u8 trace_type = *trace_type_p;
-
-  if (trace_type & IOAM_BIT_TTL_NODEID_SHORT)
-  {
-    u32 ttl_node_id_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, "ttl 0x%x node id 0x%x ",
-    ttl_node_id_host_byte_order >> 24,
-    ttl_node_id_host_byte_order & 0x00FFFFFF);
-
-    elt++;
-  }
-
-  if (trace_type & IOAM_BIT_ING_EGR_INT_SHORT)
-  {
-    u32 ingress_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, "ingress 0x%x egress 0x%x ",
-    ingress_host_byte_order >> 16,
-    ingress_host_byte_order & 0xFFFF);
-    elt++;
-  }
-
-  if (trace_type & IOAM_BIT_TIMESTAMP_SEC)
-  {
-    u32 ts_in_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, "ts 0x%x \n", ts_in_host_byte_order);
-    elt++;
-  }
-
-  if (trace_type & IOAM_BIT_APPDATA_SHORT_DATA)
-  {
-    u32 appdata_in_host_byte_order = clib_net_to_host_u32 (*elt);
-    s = format (s, "app 0x%x ", appdata_in_host_byte_order);
-    elt++;
-  }
-
-  return s;
-}
-
-
-
-int
-vxlan_gpe_ioam_trace_rewrite_handler (u8 * rewrite_string, u8 * rewrite_size)
-{
-  vxlan_gpe_ioam_trace_option_t *trace_option = NULL;
-  u32 trace_data_size = 0;
-  u8 trace_option_elts = 0;
-  trace_profile *profile = NULL;
-
-
-  profile = trace_profile_find ();
-
-  if (PREDICT_FALSE (!profile))
-    {
-      return (-1);
-    }
-
-  if (PREDICT_FALSE (!rewrite_string))
-    return -1;
-
-  trace_option_elts = profile->num_elts;
-  trace_data_size = fetch_trace_data_size (profile);
-  trace_option = (vxlan_gpe_ioam_trace_option_t *) rewrite_string;
-  trace_option->hdr.type = VXLAN_GPE_OPTION_TYPE_IOAM_TRACE;
-  trace_option->hdr.length = 2 /*ioam_trace_type,data_list_elts_left */  +
-                            trace_option_elts * trace_data_size;
-  trace_option->ioam_trace_type = profile->trace_type & IOAM_INSTR_BITMAP_MASK;
-  trace_option->data_list_elts_left = trace_option_elts;
-  *rewrite_size =
-    sizeof (vxlan_gpe_ioam_trace_option_t) +
-    (trace_option_elts * trace_data_size);
-
-  return 0;
-}
-
-
-int
-vxlan_gpe_ioam_trace_data_list_handler (vlib_buffer_t * b,
-                                        vxlan_gpe_ioam_option_t * opt,
-                                        u8 is_ipv4, u8 use_adj)
-{
-  u8 elt_index = 0;
-  vxlan_gpe_ioam_trace_option_t *trace =
-    (vxlan_gpe_ioam_trace_option_t *) opt;
-  time_u64_t time_u64;
-  u32 *elt;
-  int rv = 0;
-  trace_profile *profile = NULL;
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-
-
-  profile = trace_profile_find ();
-
-  if (PREDICT_FALSE (!profile))
-    {
-      return (-1);
-    }
-
-
-  time_u64.as_u64 = 0;
-
-  if (PREDICT_TRUE (trace->data_list_elts_left))
-  {
-    trace->data_list_elts_left--;
-    /* fetch_trace_data_size returns in bytes. Convert it to 4-bytes
-      * to skip to this node's location.
-    */
-    elt_index =
-      trace->data_list_elts_left * fetch_trace_data_size (profile) / 4;
-    elt = &trace->elts[elt_index];
-    if (is_ipv4)
-	  {
-	    if (trace->ioam_trace_type & IOAM_BIT_TTL_NODEID_SHORT)
-	    {
-	      ip4_header_t *ip0 = vlib_buffer_get_current (b);
-	      /* The transit case is the only case where the TTL decrement happens
-	       * before iOAM processing. For now, use the use_adj flag as an overload.
-	       * We can probably use a separate flag instead of overloading the use_adj flag.
-	       */
-	      *elt = clib_host_to_net_u32 (((ip0->ttl - 1 + use_adj) << 24) |
-					   profile->node_id_short);
-        elt++;
-	    }
-
-	    if (trace->ioam_trace_type & IOAM_BIT_ING_EGR_INT_SHORT)
-	    {
-	      u16 tx_if = 0;
-	      u32 adj_index = vnet_buffer (b)->ip.adj_index[VLIB_TX];
-
-	      if (use_adj)
-        {
-          ip_adjacency_t *adj = adj_get (adj_index);
-          tx_if = adj->rewrite_header.sw_if_index & 0xFFFF;
-        }
-
-	      *elt =
-		(vnet_buffer (b)->sw_if_index[VLIB_RX] & 0xFFFF) << 16 |
-		tx_if;
-    *elt = clib_host_to_net_u32 (*elt);
-	      elt++;
-	    }
-	  }
-    else
-	  {
-	    if (trace->ioam_trace_type & IOAM_BIT_TTL_NODEID_SHORT)
-	    {
-	      ip6_header_t *ip0 = vlib_buffer_get_current (b);
-	      *elt = clib_host_to_net_u32 ((ip0->hop_limit << 24) |
-					   profile->node_id_short);
-        elt++;
-	    }
-	    if (trace->ioam_trace_type & IOAM_BIT_ING_EGR_INT_SHORT)
-	    {
-	      u16 tx_if = 0;
-	      u32 adj_index = vnet_buffer (b)->ip.adj_index[VLIB_TX];
-
-        if (use_adj)
-        {
-          ip_adjacency_t *adj = adj_get (adj_index);
-          tx_if = adj->rewrite_header.sw_if_index & 0xFFFF;
-        }
-
-	      *elt =
-		(vnet_buffer (b)->sw_if_index[VLIB_RX] & 0xFFFF) << 16 |
-		tx_if;
-        *elt = clib_host_to_net_u32 (*elt);
-	      elt++;
-	    }
-	  }
-
-    if (trace->ioam_trace_type & IOAM_BIT_TIMESTAMP_SEC)
-    {
-      /* Send least significant 32 bits */
-      f64 time_f64 =
-        (f64) (((f64) hm->unix_time_0) +
-        (vlib_time_now (hm->vlib_main) - hm->vlib_time_0));
-
-      time_u64.as_u64 = time_f64 * trace_tsp_mul[profile->ts_format];
-      *elt = clib_host_to_net_u32 (time_u64.as_u32[0]);
-      elt++;
-    }
-
-    if (trace->ioam_trace_type & IOAM_BIT_APPDATA_SHORT_DATA)
-    {
-      /* $$$ set elt0->app_data */
-      *elt = clib_host_to_net_u32 (profile->app_data_short);
-      elt++;
-    }
-      vxlan_gpe_ioam_trace_stats_increment_counter
-	      (VXLAN_GPE_IOAM_TRACE_SUCCESS, 1);
-    }
-  else
-  {
-    vxlan_gpe_ioam_trace_stats_increment_counter
-	    (VXLAN_GPE_IOAM_TRACE_FAILED, 1);
-  }
-  return (rv);
-}
-
-u8 *
-vxlan_gpe_ioam_trace_data_list_trace_handler (u8 * s,
-					      vxlan_gpe_ioam_option_t * opt)
-{
-  vxlan_gpe_ioam_trace_option_t *trace;
-  u32 trace_data_size_in_words = 0;
-  u32 *elt;
-  int elt_index = 0;
-
-  trace = (vxlan_gpe_ioam_trace_option_t *) opt;
-  s =
-    format (s, "  Trace Type 0x%x , %d elts left\n", trace->ioam_trace_type,
-	    trace->data_list_elts_left);
-  trace_data_size_in_words =
-    fetch_trace_data_size (trace_profile_find()) / 4;
-  elt = &trace->elts[0];
-  while ((u8 *) elt < ((u8 *) (&trace->elts[0]) + trace->hdr.length - 2
-		       /* -2 accounts for ioam_trace_type,elts_left */ ))
-  {
-    s = format (s, "    [%d] %U\n", elt_index,
-    format_ioam_data_list_element,
-    elt, &trace->ioam_trace_type);
-    elt_index++;
-    elt += trace_data_size_in_words;
-  }
-  return (s);
-}
-
-
-static clib_error_t *
-vxlan_gpe_show_ioam_trace_cmd_fn (vlib_main_t * vm,
-                                  unformat_input_t * input,
-                                  vlib_cli_command_t * cmd)
-{
-  vxlan_gpe_ioam_trace_main_t *hm = &vxlan_gpe_ioam_trace_main;
-  u8 *s = 0;
-  int i = 0;
-
-  for (i = 0; i < VXLAN_GPE_IOAM_TRACE_N_STATS; i++)
-  {
-    s = format (s, " %s - %lu\n", vxlan_gpe_ioam_trace_stats_strings[i],
-    hm->counters[i]);
-  }
-
-  vlib_cli_output (vm, "%v", s);
-  vec_free (s);
-  return 0;
-}
-
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (vxlan_gpe_show_ioam_trace_cmd, static) = {
-  .path = "show ioam vxlan-gpe trace",
-  .short_help = "iOAM trace statistics",
-  .function = vxlan_gpe_show_ioam_trace_cmd_fn,
-};
-/* *INDENT-ON* */
-
-
-static clib_error_t *
-vxlan_gpe_ioam_trace_init (vlib_main_t * vm)
-{
-  vxlan_gpe_ioam_trace_main_t *hm = &vxlan_gpe_ioam_trace_main;
-
-  hm->vlib_main = vm;
-  hm->vnet_main = vnet_get_main ();
-  clib_memset (hm->counters, 0, sizeof (hm->counters));
-
-  if (vxlan_gpe_ioam_register_option
-      (VXLAN_GPE_OPTION_TYPE_IOAM_TRACE,
-       vxlan_gpe_ioam_trace_data_list_handler,
-       vxlan_gpe_ioam_trace_data_list_trace_handler) < 0)
-    return (clib_error_create
-	    ("registration of VXLAN_GPE_OPTION_TYPE_IOAM_TRACE failed"));
-
-
-  if (vxlan_gpe_ioam_add_register_option
-      (VXLAN_GPE_OPTION_TYPE_IOAM_TRACE,
-       sizeof (vxlan_gpe_ioam_trace_option_t),
-       vxlan_gpe_ioam_trace_rewrite_handler) < 0)
-    return (clib_error_create
-	    ("registration of VXLAN_GPE_OPTION_TYPE_IOAM_TRACE for rewrite failed"));
-
-
-  return (0);
-}
-
-/* *INDENT-OFF* */
-VLIB_INIT_FUNCTION (vxlan_gpe_ioam_trace_init) =
-{
-  .runs_after = VLIB_INITS("ip_main_init", "ip6_lookup_init",
-                           "vxlan_gpe_init"),
-};
-/* *INDENT-ON* */
-
-
-int
-vxlan_gpe_trace_profile_cleanup (void)
-{
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-
-  hm->options_size[VXLAN_GPE_OPTION_TYPE_IOAM_TRACE] = 0;
-
-  return 0;
-
-}
-
-static int
-vxlan_gpe_ioam_trace_get_sizeof_handler (u32 * result)
-{
-  u16 size = 0;
-  u32 trace_data_size = 0;
-  trace_profile *profile = NULL;
-
-  *result = 0;
-
-  profile = trace_profile_find ();
-
-  if (PREDICT_FALSE (!profile))
-  {
-    return (-1);
-  }
-
-  trace_data_size = fetch_trace_data_size (profile);
-  if (PREDICT_FALSE (trace_data_size == 0))
-    return VNET_API_ERROR_INVALID_VALUE;
-
-  if (PREDICT_FALSE (profile->num_elts * trace_data_size > 254))
-    return VNET_API_ERROR_INVALID_VALUE;
-
-  size +=
-    sizeof (vxlan_gpe_ioam_trace_option_t) +
-    profile->num_elts * trace_data_size;
-  *result = size;
-
-  return 0;
-}
-
-
-int
-vxlan_gpe_trace_profile_setup (void)
-{
-  u32 trace_size = 0;
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-
-  trace_profile *profile = NULL;
-
-
-  profile = trace_profile_find ();
-
-  if (PREDICT_FALSE (!profile))
-  {
-    return (-1);
-  }
-
-
-  if (vxlan_gpe_ioam_trace_get_sizeof_handler (&trace_size) < 0)
-    return (-1);
-
-  hm->options_size[VXLAN_GPE_OPTION_TYPE_IOAM_TRACE] = trace_size;
-
-  return (0);
-}
-
-
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-vxlan-gpe/vxlan_gpe_ioam_util.h b/ioam/lib-vxlan-gpe/vxlan_gpe_ioam_util.h
deleted file mode 100644
index c0ad8d9..0000000
--- a/ioam/lib-vxlan-gpe/vxlan_gpe_ioam_util.h
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Copyright (c) 2015 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef __included_vxlan_gpe_ioam_util_h__
-#define __included_vxlan_gpe_ioam_util_h__
-
-#include <vnet/vxlan-gpe/vxlan_gpe.h>
-#include <vnet/vxlan-gpe/vxlan_gpe_packet.h>
-#include <vnet/ip/ip.h>
-
-
-typedef struct
-{
-  u32 tunnel_index;
-  ioam_trace_t fmt_trace;
-} vxlan_gpe_ioam_v4_trace_t;
-
-
-static u8 *
-format_vxlan_gpe_ioam_v4_trace (u8 * s, va_list * args)
-{
-  CLIB_UNUSED (vlib_main_t * vm) = va_arg (*args, vlib_main_t *);
-  CLIB_UNUSED (vlib_node_t * node) = va_arg (*args, vlib_node_t *);
-  vxlan_gpe_ioam_v4_trace_t *t1 = va_arg (*args, vxlan_gpe_ioam_v4_trace_t *);
-  ioam_trace_t *t = &(t1->fmt_trace);
-  vxlan_gpe_ioam_option_t *fmt_trace0;
-  vxlan_gpe_ioam_option_t *opt0, *limit0;
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-
-  u8 type0;
-
-  fmt_trace0 = (vxlan_gpe_ioam_option_t *) t->option_data;
-
-  s = format (s, "VXLAN-GPE-IOAM: next_index %d len %d traced %d",
-	      t->next_index, fmt_trace0->length, t->trace_len);
-
-  opt0 = (vxlan_gpe_ioam_option_t *) (fmt_trace0 + 1);
-  limit0 = (vxlan_gpe_ioam_option_t *) ((u8 *) fmt_trace0) + t->trace_len;
-
-  while (opt0 < limit0)
-    {
-      type0 = opt0->type;
-      switch (type0)
-	{
-	case 0:		/* Pad, just stop */
-	  opt0 = (vxlan_gpe_ioam_option_t *) ((u8 *) opt0) + 1;
-	  break;
-
-	default:
-	  if (hm->trace[type0])
-	    {
-	      s = (*hm->trace[type0]) (s, opt0);
-	    }
-	  else
-	    {
-	      s =
-		format (s, "\n    unrecognized option %d length %d", type0,
-			opt0->length);
-	    }
-	  opt0 =
-	    (vxlan_gpe_ioam_option_t *) (((u8 *) opt0) + opt0->length +
-					 sizeof (vxlan_gpe_ioam_option_t));
-	  break;
-	}
-    }
-
-  s = format (s, "VXLAN-GPE-IOAM: tunnel %d", t1->tunnel_index);
-  return s;
-}
-
-
-always_inline void
-vxlan_gpe_encap_decap_ioam_v4_one_inline (vlib_main_t * vm,
-					  vlib_node_runtime_t * node,
-					  vlib_buffer_t * b0,
-					  u32 * next0, u32 drop_node_val,
-					  u8 use_adj)
-{
-  ip4_header_t *ip0;
-  udp_header_t *udp_hdr0;
-  vxlan_gpe_header_t *gpe_hdr0;
-  vxlan_gpe_ioam_hdr_t *gpe_ioam0;
-  vxlan_gpe_ioam_option_t *opt0;
-  vxlan_gpe_ioam_option_t *limit0;
-  vxlan_gpe_ioam_main_t *hm = &vxlan_gpe_ioam_main;
-
-  /* Populate the iOAM header */
-  ip0 = vlib_buffer_get_current (b0);
-  udp_hdr0 = (udp_header_t *) (ip0 + 1);
-  gpe_hdr0 = (vxlan_gpe_header_t *) (udp_hdr0 + 1);
-  gpe_ioam0 = (vxlan_gpe_ioam_hdr_t *) (gpe_hdr0 + 1);
-  opt0 = (vxlan_gpe_ioam_option_t *) (gpe_ioam0 + 1);
-  limit0 = (vxlan_gpe_ioam_option_t *) ((u8 *) gpe_ioam0 + gpe_ioam0->length);
-
-  /*
-   * Basic validity checks
-   */
-  if (gpe_ioam0->length > clib_net_to_host_u16 (ip0->length))
-    {
-      *next0 = drop_node_val;
-      return;
-    }
-
-  /* Scan the set of h-b-h options, process ones that we understand */
-  while (opt0 < limit0)
-    {
-      u8 type0;
-      type0 = opt0->type;
-      switch (type0)
-	{
-	case 0:		/* Pad1 */
-	  opt0 = (vxlan_gpe_ioam_option_t *) ((u8 *) opt0) + 1;
-	  continue;
-	case 1:		/* PadN */
-	  break;
-	default:
-	  if (hm->options[type0])
-	    {
-	      if ((*hm->options[type0]) (b0, opt0, 1 /* is_ipv4 */ ,
-					 use_adj) < 0)
-		{
-		  *next0 = drop_node_val;
-		  return;
-		}
-	    }
-	  break;
-	}
-      opt0 =
-	(vxlan_gpe_ioam_option_t *) (((u8 *) opt0) + opt0->length +
-				     sizeof (vxlan_gpe_ioam_hdr_t));
-    }
-
-
-  if (PREDICT_FALSE (b0->flags & VLIB_BUFFER_IS_TRACED))
-    {
-      vxlan_gpe_ioam_v4_trace_t *t =
-	vlib_add_trace (vm, node, b0, sizeof (*t));
-      u32 trace_len = gpe_ioam0->length;
-      t->fmt_trace.next_index = *next0;
-      /* Capture the ioam option verbatim */
-      trace_len =
-	trace_len <
-	ARRAY_LEN (t->fmt_trace.
-		   option_data) ? trace_len : ARRAY_LEN (t->fmt_trace.
-							 option_data);
-      t->fmt_trace.trace_len = trace_len;
-      clib_memcpy (&(t->fmt_trace.option_data), gpe_ioam0, trace_len);
-    }
-  return;
-}
-
-
-#endif
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/lib-vxlan-gpe/vxlan_gpe_test.c b/ioam/lib-vxlan-gpe/vxlan_gpe_test.c
deleted file mode 100644
index dad39f2..0000000
--- a/ioam/lib-vxlan-gpe/vxlan_gpe_test.c
+++ /dev/null
@@ -1,347 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- *------------------------------------------------------------------
- * vxlan_gpe_test.c - test harness for vxlan_gpe plugin
- *------------------------------------------------------------------
- */
-
-#include <vat/vat.h>
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-
-#include <vppinfra/error.h>
-#include <vnet/format_fns.h>
-#include <vnet/ip/ip_types_api.h>
-
-#define __plugin_msg_base ioam_vxlan_gpe_test_main.msg_id_base
-#include <vlibapi/vat_helper_macros.h>
-
-/* Declare message IDs */
-#include <ioam/lib-vxlan-gpe/ioam_vxlan_gpe.api_enum.h>
-#include <ioam/lib-vxlan-gpe/ioam_vxlan_gpe.api_types.h>
-
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam_packet.h>
-#include <ioam/lib-vxlan-gpe/vxlan_gpe_ioam.h>
-
-typedef struct
-{
-  /* API message ID base */
-  u16 msg_id_base;
-  vat_main_t *vat_main;
-} ioam_vxlan_gpe_test_main_t;
-
-ioam_vxlan_gpe_test_main_t ioam_vxlan_gpe_test_main;
-
-static int
-api_vxlan_gpe_ioam_enable (vat_main_t * vam)
-{
-  unformat_input_t *input = vam->input;
-  vl_api_vxlan_gpe_ioam_enable_t *mp;
-  u32 id = 0;
-  int has_trace_option = 0;
-  int has_pow_option = 0;
-  int has_ppc_option = 0;
-  int ret;
-
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "trace"))
-	has_trace_option = 1;
-      else if (unformat (input, "pow"))
-	has_pow_option = 1;
-      else if (unformat (input, "ppc encap"))
-	has_ppc_option = PPC_ENCAP;
-      else if (unformat (input, "ppc decap"))
-	has_ppc_option = PPC_DECAP;
-      else if (unformat (input, "ppc none"))
-	has_ppc_option = PPC_NONE;
-      else
-	break;
-    }
-  M (VXLAN_GPE_IOAM_ENABLE, mp);
-  mp->id = htons (id);
-  mp->trace_ppc = has_ppc_option;
-  mp->pow_enable = has_pow_option;
-  mp->trace_enable = has_trace_option;
-
-
-  S (mp);
-  W (ret);
-  return ret;
-}
-
-
-static int
-api_vxlan_gpe_ioam_disable (vat_main_t * vam)
-{
-  vl_api_vxlan_gpe_ioam_disable_t *mp;
-  int ret;
-
-  M (VXLAN_GPE_IOAM_DISABLE, mp);
-  S (mp);
-  W (ret);
-  return ret;
-}
-
-static int
-api_vxlan_gpe_ioam_vni_enable (vat_main_t * vam)
-{
-  unformat_input_t *line_input = vam->input;
-  vl_api_vxlan_gpe_ioam_vni_enable_t *mp;
-  ip46_address_t local, remote;
-  u8 local_set = 0;
-  u8 remote_set = 0;
-  u32 vni;
-  u8 vni_set = 0;
-  int ret;
-
-
-  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (line_input, "local %U", unformat_ip46_address, &local))
-	{
-	  local_set = 1;
-	}
-      else if (unformat (line_input, "remote %U",
-			 unformat_ip46_address, &remote))
-	{
-	  remote_set = 1;
-	}
-      else if (unformat (line_input, "vni %d", &vni))
-	vni_set = 1;
-      else
-	{
-	  errmsg ("parse error '%U'\n", format_unformat_error, line_input);
-	  return -99;
-	}
-    }
-
-  if (local_set == 0)
-    {
-      errmsg ("tunnel local address not specified\n");
-      return -99;
-    }
-  if (remote_set == 0)
-    {
-      errmsg ("tunnel remote address not specified\n");
-      return -99;
-    }
-  if (ip46_address_is_ip4 (&local) != ip46_address_is_ip4 (&remote))
-    {
-      errmsg ("both IPv4 and IPv6 addresses specified");
-      return -99;
-    }
-
-  if (vni_set == 0)
-    {
-      errmsg ("vni not specified\n");
-      return -99;
-    }
-
-  M (VXLAN_GPE_IOAM_VNI_ENABLE, mp);
-
-  ip_address_encode (&local,
-		     ip46_address_is_ip4 (&local) ? IP46_TYPE_IP4 :
-		     IP46_TYPE_IP6, &mp->local);
-  ip_address_encode (&local,
-		     ip46_address_is_ip4 (&remote) ? IP46_TYPE_IP4 :
-		     IP46_TYPE_IP6, &mp->remote);
-
-  mp->vni = ntohl (vni);
-
-  S (mp);
-  W (ret);
-  return ret;
-}
-
-static int
-api_vxlan_gpe_ioam_vni_disable (vat_main_t * vam)
-{
-  unformat_input_t *line_input = vam->input;
-  vl_api_vxlan_gpe_ioam_vni_disable_t *mp;
-  ip46_address_t local, remote;
-  u8 local_set = 0;
-  u8 remote_set = 0;
-  u32 vni;
-  u8 vni_set = 0;
-  int ret;
-
-
-  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (line_input, "local %U", unformat_ip46_address, &local))
-	{
-	  local_set = 1;
-	}
-      else if (unformat (line_input, "remote %U",
-			 unformat_ip46_address, &remote))
-	{
-	  remote_set = 1;
-	}
-      else if (unformat (line_input, "vni %d", &vni))
-	vni_set = 1;
-      else
-	{
-	  errmsg ("parse error '%U'\n", format_unformat_error, line_input);
-	  return -99;
-	}
-    }
-
-  if (local_set == 0)
-    {
-      errmsg ("tunnel local address not specified\n");
-      return -99;
-    }
-  if (remote_set == 0)
-    {
-      errmsg ("tunnel remote address not specified\n");
-      return -99;
-    }
-  if (ip46_address_is_ip4 (&local) != ip46_address_is_ip4 (&remote))
-    {
-      errmsg ("both IPv4 and IPv6 addresses specified");
-      return -99;
-    }
-
-  if (vni_set == 0)
-    {
-      errmsg ("vni not specified\n");
-      return -99;
-    }
-
-  M (VXLAN_GPE_IOAM_VNI_DISABLE, mp);
-
-  ip_address_encode (&local,
-		     ip46_address_is_ip4 (&local) ? IP46_TYPE_IP4 :
-		     IP46_TYPE_IP6, &mp->local);
-  ip_address_encode (&local,
-		     ip46_address_is_ip4 (&remote) ? IP46_TYPE_IP4 :
-		     IP46_TYPE_IP6, &mp->remote);
-
-  mp->vni = ntohl (vni);
-
-  S (mp);
-  W (ret);
-  return ret;
-}
-
-static int
-api_vxlan_gpe_ioam_transit_enable (vat_main_t * vam)
-{
-  unformat_input_t *line_input = vam->input;
-  vl_api_vxlan_gpe_ioam_transit_enable_t *mp;
-  ip46_address_t local;
-  u8 local_set = 0;
-  u32 outer_fib_index = 0;
-  int ret;
-
-
-  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (line_input, "dst-ip %U", unformat_ip46_address, &local))
-	{
-	  local_set = 1;
-	}
-      else if (unformat (line_input, "outer-fib-index %d", &outer_fib_index))
-	;
-      else
-	{
-	  errmsg ("parse error '%U'\n", format_unformat_error, line_input);
-	  return -99;
-	}
-    }
-
-  if (local_set == 0)
-    {
-      errmsg ("destination address not specified\n");
-      return -99;
-    }
-
-  M (VXLAN_GPE_IOAM_TRANSIT_ENABLE, mp);
-
-
-  if (!ip46_address_is_ip4 (&local))
-    {
-      errmsg ("IPv6 currently unsupported");
-      return -1;
-    }
-  ip_address_encode (&local, IP46_TYPE_IP4, &mp->dst_addr);
-  mp->outer_fib_index = htonl (outer_fib_index);
-
-  S (mp);
-  W (ret);
-  return ret;
-}
-
-static int
-api_vxlan_gpe_ioam_transit_disable (vat_main_t * vam)
-{
-  unformat_input_t *line_input = vam->input;
-  vl_api_vxlan_gpe_ioam_transit_disable_t *mp;
-  ip46_address_t local;
-  u8 local_set = 0;
-  u32 outer_fib_index = 0;
-  int ret;
-
-
-  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (line_input, "dst-ip %U", unformat_ip46_address, &local))
-	{
-	  local_set = 1;
-	}
-      else if (unformat (line_input, "outer-fib-index %d", &outer_fib_index))
-	;
-      else
-	{
-	  errmsg ("parse error '%U'\n", format_unformat_error, line_input);
-	  return -99;
-	}
-    }
-
-  if (local_set == 0)
-    {
-      errmsg ("destination address not specified\n");
-      return -99;
-    }
-
-  M (VXLAN_GPE_IOAM_TRANSIT_DISABLE, mp);
-
-
-  if (!ip46_address_is_ip4 (&local))
-    {
-      return -1;
-    }
-  ip_address_encode (&local, IP46_TYPE_IP4, &mp->dst_addr);
-
-  mp->outer_fib_index = htonl (outer_fib_index);
-
-  S (mp);
-  W (ret);
-  return ret;
-}
-
-/* Override generated plugin register symbol */
-#define vat_plugin_register vxlan_gpe_vat_plugin_register
-#include <ioam/lib-vxlan-gpe/ioam_vxlan_gpe.api_test.c>
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/udp-ping/udp_ping.api b/ioam/udp-ping/udp_ping.api
deleted file mode 100644
index 6b6213a..0000000
--- a/ioam/udp-ping/udp_ping.api
+++ /dev/null
@@ -1,56 +0,0 @@
-/* Hey Emacs use -*- mode: C -*- */
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-option version = "3.0.0";
-import "vnet/ip/ip_types.api";
-
-/** \brief UDP-Probe Add/Delete request 
-    @param src_ip_address - Source ipv4/v6 address for the udp-ping flow
-    @param dst_ip_address - Destination ipv4/v6 address for the udp-ping flow
-    @param start_src_port - Starting source port of port range for udp-ping
-    @param end_src_port - End source port of port range for udp-ping
-    @param start_dst_port - Starting destination port of port range for udp-ping
-    @param end_dst_port - End destination port of port range for udp-ping
-    @param interval - Time interval in seconds at which udp-probe need to be sent
-    @param is_ipv4 - To determine whether IPv4 or IPv6 address is used
-    @param dis - TRUE is delete, FALSE if Add
-*/
-autoreply define udp_ping_add_del {
-  u32 client_index;
-  u32 context;
-  vl_api_address_t src_ip_address;
-  vl_api_address_t dst_ip_address;
-  u16 start_src_port;
-  u16 end_src_port;
-  u16 start_dst_port;
-  u16 end_dst_port;
-  u16 interval;
-  u8 dis;
-  u8 fault_det;
-  u8 reserve[3];
-};
-
-/** \brief Udp-probe export add/del request
-    @param context - sender context, to match reply w/ request
-    @param retval - return value for request
-    @param enable - If TRUE then enable export else disable
-*/
-autoreply define udp_ping_export {
-   u32 client_index;
-   u32 context;
-   bool enable;
-};
-
diff --git a/ioam/udp-ping/udp_ping.h b/ioam/udp-ping/udp_ping.h
deleted file mode 100644
index 2c0d214..0000000
--- a/ioam/udp-ping/udp_ping.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef PLUGINS_IOAM_PLUGIN_IOAM_UDP_PING_UDP_PING_H_
-#define PLUGINS_IOAM_PLUGIN_IOAM_UDP_PING_UDP_PING_H_
-
-#include <ioam/analyse/ioam_analyse.h>
-
-#define MAX_PING_RETRIES 5
-
-#define EVENT_SIG_RECHECK 2
-
-/** @brief udp-ping session data.
-    @note cache aligned.
-*/
-typedef struct
-{
-  /** UDP ping packet */
-  u8 *ping_rewrite;
-
-  /** Ping packet rewrite string len. */
-  u16 rewrite_len;
-
-  /** Number of times ping response was dropped.
-   * If retry > MAX_PING_RETRIES then declare connectivity as down.
-   */
-  u16 retry;
-
-  u16 reserve[2];
-
-  /** Analysed data. */
-  ioam_analyser_data_t analyse_data;
-
-  /** This is used by ioam e2e for identifying flow and add seq number. */
-  u32 flow_ctx;
-
-  /** No of packets sent for this flow. */
-  u32 pak_sent;
-} udp_ping_flow_data;
-
-/** @brief udp-ping flow data.
-    @note cache aligned.
-*/
-typedef struct
-{
-  /** Time at which next udp-ping probe has to be sent out. */
-  f64 next_send_time;
-
-  /** Interval for which ping packet to be sent. */
-  u16 interval;
-
-  u16 reserve[3];
-
-  /** Defines start port of the src port range. */
-  u16 start_src_port;
-
-  /** Defines end port of the src port range. */
-  u16 end_src_port;
-
-  /** Defines start port of the dest port range. */
-  u16 start_dst_port;
-
-  /** Defines end port of the dest port range. */
-  u16 end_dst_port;
-
-  /** Ping statistics. */
-  udp_ping_flow_data *stats;
-
-} udp_ping_flow;
-
-/** @brief udp-ping data.
-*/
-typedef struct
-{
-  /** Required for pool_get_aligned */
-  CLIB_CACHE_LINE_ALIGN_MARK (cacheline0);
-
-  /** Local source IPv4/6 address to be used. */
-  ip46_address_t src;
-
-  /** Remote destination IPv4/6 address to be used. */
-  ip46_address_t dst;
-
-  /** Per flow data. */
-  udp_ping_flow udp_data;
-
-  /** To enable fault detection/isolation in network. */
-  u8 fault_det;
-} ip46_udp_ping_flow;
-
-/** @brief udp-ping main data-structure.
-*/
-typedef struct
-{
-  /** Vector od udp-ping data */
-  ip46_udp_ping_flow *ip46_flow;
-
-  /** Stores the time interval at which process node has to wake up. */
-  u64 timer_interval;
-
-  /** Pointer to VLib main for the node - ipfix-collector. */
-  vlib_main_t *vlib_main;
-
-  /** Pointer to vnet main for convenience. */
-  vnet_main_t *vnet_main;
-
-  /** API message ID base */
-  u16 msg_id_base;
-} udp_ping_main_t;
-
-extern udp_ping_main_t udp_ping_main;
-
-void
-ip46_udp_ping_set_flow (ip46_address_t src, ip46_address_t dst,
-			u16 start_src_port, u16 end_src_port,
-			u16 start_dst_port, u16 end_dst_port,
-			u16 interval, u8 fault_det, u8 is_disable);
-
-clib_error_t *udp_ping_flow_create (u8 del);
-
-#endif /* PLUGINS_IOAM_PLUGIN_IOAM_UDP_PING_UDP_PING_H_ */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/udp-ping/udp_ping_api.c b/ioam/udp-ping/udp_ping_api.c
deleted file mode 100644
index 6c54e0d..0000000
--- a/ioam/udp-ping/udp_ping_api.c
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- *------------------------------------------------------------------
- * udp_ping_api.c - UDP Ping related APIs to create
- *             and maintain ping flows
- *------------------------------------------------------------------
- */
-
-#include <vnet/vnet.h>
-#include <vnet/ip/ip.h>
-#include <ioam/udp-ping/udp_ping.h>
-
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-#include <vnet/format_fns.h>
-#include <vnet/ip/ip_types_api.h>
-
-/* define message IDs */
-#include <ioam/udp-ping/udp_ping.api_enum.h>
-#include <ioam/udp-ping/udp_ping.api_types.h>
-
-#define REPLY_MSG_ID_BASE sm->msg_id_base
-#include <vlibapi/api_helper_macros.h>
-
-static void
-vl_api_udp_ping_add_del_t_handler (vl_api_udp_ping_add_del_t * mp)
-{
-  ip46_address_t dst, src;
-  int rv = 0;
-  udp_ping_main_t *sm = &udp_ping_main;
-  vl_api_udp_ping_add_del_reply_t *rmp;
-
-  if (clib_net_to_host_u32 (mp->src_ip_address.af) == ADDRESS_IP4)
-    {
-      rv = -1;			//Not supported
-      goto ERROROUT;
-    }
-  ip_address_decode (&mp->src_ip_address, &src);
-  ip_address_decode (&mp->dst_ip_address, &dst);
-
-  ip46_udp_ping_set_flow (src, dst,
-			  ntohs (mp->start_src_port),
-			  ntohs (mp->end_src_port),
-			  ntohs (mp->start_dst_port),
-			  ntohs (mp->end_dst_port),
-			  ntohs (mp->interval), mp->fault_det, mp->dis);
-  rv = 0;			//FIXME
-
-ERROROUT:
-  REPLY_MACRO (VL_API_UDP_PING_ADD_DEL_REPLY);
-}
-
-static void
-vl_api_udp_ping_export_t_handler (vl_api_udp_ping_export_t * mp)
-{
-  udp_ping_main_t *sm = &udp_ping_main;
-  int rv = 0;
-  vl_api_udp_ping_export_reply_t *rmp;
-
-  (void) udp_ping_flow_create (!mp->enable);
-  rv = 0;			//FIXME
-
-  REPLY_MACRO (VL_API_UDP_PING_EXPORT_REPLY);
-}
-
-#include <ioam/udp-ping/udp_ping.api.c>
-static clib_error_t *
-udp_ping_api_init (vlib_main_t * vm)
-{
-  udp_ping_main_t *sm = &udp_ping_main;
-
-  /* Ask for a correctly-sized block of API message decode slots */
-  sm->msg_id_base = setup_message_id_table ();
-
-  return 0;
-}
-
-VLIB_INIT_FUNCTION (udp_ping_api_init);
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/udp-ping/udp_ping_export.c b/ioam/udp-ping/udp_ping_export.c
deleted file mode 100644
index 3dc1436..0000000
--- a/ioam/udp-ping/udp_ping_export.c
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * Copyright (c) 2016 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <vnet/ipfix-export/flow_report.h>
-#include <ioam/analyse/ioam_summary_export.h>
-#include <vnet/api_errno.h>
-#include <vnet/ip/ip4.h>
-#include <vnet/udp/udp_local.h>
-#include <ioam/udp-ping/udp_ping.h>
-
-#define UDP_PING_EXPORT_RECORD_SIZE 400
-
-static u8 *
-udp_ping_template_rewrite (ipfix_exporter_t *exp, flow_report_t *fr,
-			   u16 collector_port, ipfix_report_element_t *elts,
-			   u32 n_elts, u32 *stream_index)
-{
-  return ioam_template_rewrite (exp, fr, collector_port, elts, n_elts,
-				stream_index);
-}
-
-static vlib_frame_t *
-udp_ping_send_flows (flow_report_main_t *frm, ipfix_exporter_t *exp,
-		     flow_report_t *fr, vlib_frame_t *f, u32 *to_next,
-		     u32 node_index)
-{
-  vlib_buffer_t *b0 = NULL;
-  u32 next_offset = 0;
-  u32 bi0 = ~0;
-  int i, j;
-  ip4_ipfix_template_packet_t *tp;
-  ipfix_message_header_t *h;
-  ipfix_set_header_t *s = NULL;
-  ip4_header_t *ip;
-  udp_header_t *udp;
-  u32 records_this_buffer;
-  u16 new_l0, old_l0;
-  ip_csum_t sum0;
-  vlib_main_t *vm = vlib_get_main ();
-  flow_report_stream_t *stream;
-  udp_ping_flow_data *stats;
-  ip46_udp_ping_flow *ip46_flow;
-  u16 src_port, dst_port;
-  u16 data_len;
-
-  stream = &exp->streams[fr->stream_index];
-  data_len = vec_len (udp_ping_main.ip46_flow);
-
-  for (i = 0; i < data_len; i++)
-    {
-      if (pool_is_free_index (udp_ping_main.ip46_flow, i))
-	continue;
-
-      ip46_flow = pool_elt_at_index (udp_ping_main.ip46_flow, i);
-      j = 0;
-      for (src_port = ip46_flow->udp_data.start_src_port;
-	   src_port <= ip46_flow->udp_data.end_src_port; src_port++)
-	{
-	  for (dst_port = ip46_flow->udp_data.start_dst_port;
-	       dst_port <= ip46_flow->udp_data.end_dst_port; dst_port++, j++)
-	    {
-	      stats = ip46_flow->udp_data.stats + j;
-	      if (PREDICT_FALSE (b0 == NULL))
-		{
-		  if (vlib_buffer_alloc (vm, &bi0, 1) != 1)
-		    break;
-
-
-		  b0 = vlib_get_buffer (vm, bi0);
-		  memcpy (b0->data, fr->rewrite, vec_len (fr->rewrite));
-		  b0->current_data = 0;
-		  b0->current_length = vec_len (fr->rewrite);
-		  b0->flags |= VLIB_BUFFER_TOTAL_LENGTH_VALID;
-		  vnet_buffer (b0)->sw_if_index[VLIB_RX] = 0;
-		  vnet_buffer (b0)->sw_if_index[VLIB_TX] = ~0;
-
-		  tp = vlib_buffer_get_current (b0);
-		  ip = &tp->ip4;
-		  h = &tp->ipfix.h;
-		  s = &tp->ipfix.s;
-
-		  /* FIXUP: message header export_time */
-		  h->export_time = clib_host_to_net_u32 (((u32) time (NULL)));
-
-		  /* FIXUP: message header sequence_number */
-		  h->sequence_number = stream->sequence_number++;
-		  h->sequence_number =
-		    clib_host_to_net_u32 (h->sequence_number);
-		  next_offset = (u32) (((u8 *) (s + 1)) - (u8 *) tp);
-		  records_this_buffer = 0;
-		}
-
-	      next_offset = ioam_analyse_add_ipfix_record (fr,
-							   &stats->analyse_data,
-							   b0, next_offset,
-							   &ip46_flow->
-							   src.ip6,
-							   &ip46_flow->
-							   dst.ip6, src_port,
-							   dst_port);
-
-	      //u32 pak_sent = clib_host_to_net_u32(stats->pak_sent);
-	      //memcpy (b0->data + next_offset, &pak_sent, sizeof(u32));
-	      //next_offset += sizeof(u32);
-
-	      records_this_buffer++;
-
-	      /* Flush data if packet len is about to reach path mtu */
-	      if (next_offset > (exp->path_mtu - UDP_PING_EXPORT_RECORD_SIZE))
-		{
-		  b0->current_length = next_offset;
-		  b0->flags |= VLIB_BUFFER_TOTAL_LENGTH_VALID;
-		  tp = vlib_buffer_get_current (b0);
-		  ip = (ip4_header_t *) & tp->ip4;
-		  udp = (udp_header_t *) (ip + 1);
-		  h = &tp->ipfix.h;
-		  s = &tp->ipfix.s;
-
-		  s->set_id_length =
-		    ipfix_set_id_length (IOAM_FLOW_TEMPLATE_ID,
-					 next_offset - (sizeof (*ip) +
-							sizeof (*udp) +
-							sizeof (*h)));
-		  h->version_length =
-		    version_length (next_offset -
-				    (sizeof (*ip) + sizeof (*udp)));
-
-		  sum0 = ip->checksum;
-		  old_l0 = ip->length;
-		  new_l0 = clib_host_to_net_u16 ((u16) next_offset);
-		  sum0 = ip_csum_update (sum0, old_l0, new_l0, ip4_header_t,
-					 length /* changed member */ );
-
-		  ip->checksum = ip_csum_fold (sum0);
-		  ip->length = new_l0;
-		  udp->length =
-		    clib_host_to_net_u16 (b0->current_length - sizeof (*ip));
-
-		  udp->checksum = ip4_tcp_udp_compute_checksum (vm, b0, ip);
-		  if (udp->checksum == 0)
-		    udp->checksum = 0xffff;
-
-		  ASSERT (ip4_header_checksum_is_valid (ip));
-
-		  to_next[0] = bi0;
-		  f->n_vectors++;
-		  to_next++;
-
-		  if (f->n_vectors == VLIB_FRAME_SIZE)
-		    {
-		      vlib_put_frame_to_node (vm, node_index, f);
-		      f = vlib_get_frame_to_node (vm, node_index);
-		      f->n_vectors = 0;
-		      to_next = vlib_frame_vector_args (f);
-		    }
-		  b0 = 0;
-		  bi0 = ~0;
-		}
-	    }
-	}
-    }
-
-  if (b0)
-    {
-      b0->current_length = next_offset;
-      b0->flags |= VLIB_BUFFER_TOTAL_LENGTH_VALID;
-      tp = vlib_buffer_get_current (b0);
-      ip = (ip4_header_t *) & tp->ip4;
-      udp = (udp_header_t *) (ip + 1);
-      h = &tp->ipfix.h;
-      s = &tp->ipfix.s;
-
-      s->set_id_length = ipfix_set_id_length (IOAM_FLOW_TEMPLATE_ID,
-					      next_offset - (sizeof (*ip) +
-							     sizeof (*udp) +
-							     sizeof (*h)));
-      h->version_length =
-	version_length (next_offset - (sizeof (*ip) + sizeof (*udp)));
-
-      sum0 = ip->checksum;
-      old_l0 = ip->length;
-      new_l0 = clib_host_to_net_u16 ((u16) next_offset);
-      sum0 = ip_csum_update (sum0, old_l0, new_l0, ip4_header_t,
-			     length /* changed member */ );
-
-      ip->checksum = ip_csum_fold (sum0);
-      ip->length = new_l0;
-      udp->length = clib_host_to_net_u16 (b0->current_length - sizeof (*ip));
-
-      udp->checksum = ip4_tcp_udp_compute_checksum (vm, b0, ip);
-      if (udp->checksum == 0)
-	udp->checksum = 0xffff;
-
-      ASSERT (ip4_header_checksum_is_valid (ip));
-
-      to_next[0] = bi0;
-      f->n_vectors++;
-      to_next++;
-
-      if (f->n_vectors == VLIB_FRAME_SIZE)
-	{
-	  vlib_put_frame_to_node (vm, node_index, f);
-	  f = vlib_get_frame_to_node (vm, node_index);
-	  f->n_vectors = 0;
-	  to_next = vlib_frame_vector_args (f);
-	}
-      b0 = 0;
-      bi0 = ~0;
-    }
-  return f;
-}
-
-clib_error_t *
-udp_ping_flow_create (u8 del)
-{
-  vnet_flow_report_add_del_args_t args;
-  int rv;
-  u32 domain_id = 0;
-  ipfix_exporter_t *exp = &flow_report_main.exporters[0];
-  u16 template_id;
-
-  clib_memset (&args, 0, sizeof (args));
-  args.rewrite_callback = udp_ping_template_rewrite;
-  args.flow_data_callback = udp_ping_send_flows;
-  del ? (args.is_add = 0) : (args.is_add = 1);
-  args.domain_id = domain_id;
-  args.src_port = UDP_DST_PORT_ipfix;
-
-  rv = vnet_flow_report_add_del (exp, &args, &template_id);
-
-  switch (rv)
-    {
-    case 0:
-      break;
-    case VNET_API_ERROR_NO_SUCH_ENTRY:
-      return clib_error_return (0, "registration not found...");
-    default:
-      return clib_error_return (0, "vnet_flow_report_add_del returned %d",
-				rv);
-    }
-
-  return 0;
-}
-
-static clib_error_t *
-set_udp_ping_export_command_fn (vlib_main_t * vm, unformat_input_t * input,
-				vlib_cli_command_t * cmd)
-{
-  //int rv;
-  int is_add = 1;
-
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "export-ipfix"))
-	is_add = 1;
-      else if (unformat (input, "disable"))
-	is_add = 0;
-      else
-	break;
-    }
-
-  if (is_add)
-    (void) udp_ping_flow_create (0);
-  else
-    (void) udp_ping_flow_create (1);
-
-  return 0;
-}
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (set_udp_ping_export_command, static) = {
-    .path = "set udp-ping export-ipfix",
-    .short_help = "set udp-ping export-ipfix [disable]",
-    .function = set_udp_ping_export_command_fn,
-};
-/* *INDENT-ON* */
-
-clib_error_t *
-udp_ping_flow_report_init (vlib_main_t * vm)
-{
-  return 0;
-}
-
-/* *INDENT-OFF* */
-VLIB_INIT_FUNCTION (udp_ping_flow_report_init) =
-{
-  .runs_after = VLIB_INITS ("flow_report_init"),
-};
-/* *INDENT-ON* */
-
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/udp-ping/udp_ping_node.c b/ioam/udp-ping/udp_ping_node.c
deleted file mode 100644
index 656ae2c..0000000
--- a/ioam/udp-ping/udp_ping_node.c
+++ /dev/null
@@ -1,844 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <vnet/vnet.h>
-#include <vlib/vlib.h>
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-
-#include <vnet/ip/ip.h>
-#include <vnet/ip/ip6_hop_by_hop.h>
-#include <ioam/encap/ip6_ioam_trace.h>
-#include <ioam/encap/ip6_ioam_e2e.h>
-#include <ioam/udp-ping/udp_ping_packet.h>
-#include <ioam/udp-ping/udp_ping.h>
-#include <ioam/udp-ping/udp_ping_util.h>
-#include <vnet/srv6/sr_packet.h>
-
-typedef enum
-{
-  UDP_PING_NEXT_DROP,
-  UDP_PING_NEXT_PUNT,
-  UDP_PING_NEXT_UDP_LOOKUP,
-  UDP_PING_NEXT_ICMP,
-  UDP_PING_NEXT_IP6_LOOKUP,
-  UDP_PING_NEXT_IP6_DROP,
-  UDP_PING_N_NEXT,
-} udp_ping_next_t;
-
-#define foreach_udp_ping_error                  \
-_(BADHBH, "Malformed hop-by-hop header")
-
-typedef enum
-{
-#define _(sym,str) UDP_PING_ERROR_##sym,
-  foreach_udp_ping_error
-#undef _
-    UDP_PING_N_ERROR,
-} udp_ping_error_t;
-
-static char *udp_ping_error_strings[] = {
-#define _(sym,string) string,
-  foreach_udp_ping_error
-#undef _
-};
-
-udp_ping_main_t udp_ping_main;
-
-uword
-udp_ping_process (vlib_main_t * vm,
-		  vlib_node_runtime_t * rt, vlib_frame_t * f);
-
-extern int
-ip6_hbh_ioam_trace_data_list_handler (vlib_buffer_t * b, ip6_header_t * ip,
-				      ip6_hop_by_hop_option_t * opt);
-
-typedef struct
-{
-  ip6_address_t src;
-  ip6_address_t dst;
-  u16 src_port;
-  u16 dst_port;
-  u16 handle;
-  u16 next_index;
-  u8 msg_type;
-} udp_ping_trace_t;
-
-/* packet trace format function */
-static u8 *
-format_udp_ping_trace (u8 * s, va_list * args)
-{
-  CLIB_UNUSED (vlib_main_t * vm) = va_arg (*args, vlib_main_t *);
-  CLIB_UNUSED (vlib_node_t * node) = va_arg (*args, vlib_node_t *);
-  udp_ping_trace_t *t = va_arg (*args, udp_ping_trace_t *);
-
-  s = format (s, "udp-ping-local: src %U, dst %U, src_port %u, dst_port %u "
-	      "handle %u, next_index %u, msg_type %u",
-	      format_ip6_address, &t->src,
-	      format_ip6_address, &t->dst,
-	      t->src_port, t->dst_port,
-	      t->handle, t->next_index, t->msg_type);
-  return s;
-}
-
-/* *INDENT-OFF* */
-VLIB_REGISTER_NODE (udp_ping_node, static) =
-{
-  .function = udp_ping_process,
-  .type = VLIB_NODE_TYPE_PROCESS,
-  .name = "udp-ping-process",
-};
-/* *INDENT-ON* */
-
-void
-udp_ping_calculate_timer_interval (void)
-{
-  int i;
-  ip46_udp_ping_flow *flow = NULL;
-  u16 min_interval = 0x1e9;
-
-  for (i = 0; i < vec_len (udp_ping_main.ip46_flow); i++)
-    {
-      if (pool_is_free_index (udp_ping_main.ip46_flow, i))
-	continue;
-
-      flow = pool_elt_at_index (udp_ping_main.ip46_flow, i);
-
-      if (min_interval > flow->udp_data.interval)
-	min_interval = flow->udp_data.interval;
-    }
-
-  if (udp_ping_main.timer_interval != min_interval)
-    {
-      udp_ping_main.timer_interval = min_interval;
-      vlib_process_signal_event (udp_ping_main.vlib_main,
-				 udp_ping_node.index, EVENT_SIG_RECHECK, 0);
-    }
-}
-
-void
-ip46_udp_ping_set_flow (ip46_address_t src, ip46_address_t dst,
-			u16 start_src_port, u16 end_src_port,
-			u16 start_dst_port, u16 end_dst_port,
-			u16 interval, u8 fault_det, u8 is_disable)
-{
-  u8 found = 0;
-  ip46_udp_ping_flow *flow = NULL;
-  int i;
-
-  for (i = 0; i < vec_len (udp_ping_main.ip46_flow); i++)
-    {
-      if (pool_is_free_index (udp_ping_main.ip46_flow, i))
-	continue;
-
-      flow = pool_elt_at_index (udp_ping_main.ip46_flow, i);
-      if ((0 == udp_ping_compare_flow (src, dst,
-				       start_src_port, end_src_port,
-				       start_dst_port, end_dst_port, flow)))
-	{
-	  found = 1;
-	  break;
-	}
-    }
-
-  if (found)
-    {
-      u16 cur_interval;
-      if (is_disable)
-	{
-	  cur_interval = flow->udp_data.interval;
-	  udp_ping_free_flow_data (flow);
-	  pool_put_index (udp_ping_main.ip46_flow, i);
-	  if (udp_ping_main.timer_interval == interval)
-	    udp_ping_calculate_timer_interval ();
-	  return;
-	}
-
-      cur_interval = flow->udp_data.interval;
-      flow->udp_data.interval = interval;
-      if (udp_ping_main.timer_interval > interval)
-	{
-	  udp_ping_main.timer_interval = interval;
-	  vlib_process_signal_event (udp_ping_main.vlib_main,
-				     udp_ping_node.index,
-				     EVENT_SIG_RECHECK, 0);
-	}
-      else if (udp_ping_main.timer_interval == cur_interval)
-	udp_ping_calculate_timer_interval ();
-
-      return;
-    }
-
-  /* Delete operation and item not found */
-  if (is_disable)
-    return;
-
-  /* Alloc new session */
-  pool_get_aligned (udp_ping_main.ip46_flow, flow, CLIB_CACHE_LINE_BYTES);
-  udp_ping_populate_flow (src, dst,
-			  start_src_port, end_src_port,
-			  start_dst_port, end_dst_port,
-			  interval, fault_det, flow);
-
-  udp_ping_create_rewrite (flow, (flow - udp_ping_main.ip46_flow));
-
-  if (udp_ping_main.timer_interval > interval)
-    {
-      udp_ping_main.timer_interval = interval;
-      vlib_process_signal_event (udp_ping_main.vlib_main,
-				 udp_ping_node.index, EVENT_SIG_RECHECK, 0);
-    }
-  return;
-}
-
-uword
-unformat_port_range (unformat_input_t * input, va_list * args)
-{
-  u16 *start_port, *end_port;
-  uword c;
-  u8 colon_present = 0;
-
-  start_port = va_arg (*args, u16 *);
-  end_port = va_arg (*args, u16 *);
-
-  *start_port = *end_port = 0;
-  /* Get start port */
-  while ((c = unformat_get_input (input)) != UNFORMAT_END_OF_INPUT)
-    {
-      switch (c)
-	{
-	case '0' ... '9':
-	  *start_port = ((*start_port) * 10) + (c - '0');
-	  break;
-
-	case ':':
-	  colon_present = 1;
-	  break;
-
-	default:
-	  return 0;
-	}
-
-      if (colon_present)
-	break;
-    }
-
-  if (!colon_present)
-    return 0;
-
-  /* Get end port */
-  while ((c = unformat_get_input (input)) != UNFORMAT_END_OF_INPUT)
-    {
-      switch (c)
-	{
-	case '0' ... '9':
-	  *end_port = ((*end_port) * 10) + (c - '0');
-	  break;
-
-	default:
-	  return 1;
-	}
-    }
-
-  if (end_port < start_port)
-    return 0;
-
-  return 1;
-}
-
-static clib_error_t *
-set_udp_ping_command_fn (vlib_main_t * vm,
-			 unformat_input_t * input, vlib_cli_command_t * cmd)
-{
-  ip46_address_t dst, src;
-  u16 start_src_port, end_src_port;
-  u16 start_dst_port, end_dst_port;
-  u32 interval;
-  u8 is_disable = 0;
-  u8 fault_det = 0;
-
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat
-	  (input, "src %U", unformat_ip46_address, &src, IP46_TYPE_ANY))
-	;
-      else if (unformat (input, "src-port-range %U",
-			 unformat_port_range, &start_src_port, &end_src_port))
-	;
-      else
-	if (unformat
-	    (input, "dst %U", unformat_ip46_address, &dst, IP46_TYPE_ANY))
-	;
-      else if (unformat (input, "dst-port-range %U",
-			 unformat_port_range, &start_dst_port, &end_dst_port))
-	;
-      else if (unformat (input, "interval %d", &interval))
-	;
-      else if (unformat (input, "fault-detect"))
-	fault_det = 1;
-      else if (unformat (input, "disable"))
-	is_disable = 1;
-      else
-	break;
-    }
-
-  ip46_udp_ping_set_flow (src, dst, start_src_port, end_src_port,
-			  start_dst_port, end_dst_port, (u16) interval,
-			  fault_det, is_disable);
-
-  return 0;
-}
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (set_udp_ping_command, static) =
-{
-  .path = "set udp-ping",
-  .short_help =
-      "set udp-ping src <local IPv6 address>  src-port-range <local port range> \
-      dst <remote IPv6 address> dst-port-range <destination port range> \
-      interval <time interval in sec for which ping packet will be sent> \
-      [disable]",
-  .function = set_udp_ping_command_fn,
-};
-/* *INDENT-ON* */
-
-static clib_error_t *
-show_udp_ping_summary_cmd_fn (vlib_main_t * vm,
-			      unformat_input_t * input,
-			      vlib_cli_command_t * cmd)
-{
-  u8 *s = 0;
-  int i, j;
-  ip46_udp_ping_flow *ip46_flow;
-  u16 src_port, dst_port;
-  udp_ping_flow_data *stats;
-
-  s = format (s, "UDP-Ping data:\n");
-
-  for (i = 0; i < vec_len (udp_ping_main.ip46_flow); i++)
-    {
-      if (pool_is_free_index (udp_ping_main.ip46_flow, i))
-	continue;
-
-      ip46_flow = pool_elt_at_index (udp_ping_main.ip46_flow, i);
-      s = format (s, "Src: %U, Dst: %U\n",
-		  format_ip46_address, &ip46_flow->src, IP46_TYPE_ANY,
-		  format_ip46_address, &ip46_flow->dst, IP46_TYPE_ANY);
-
-      s = format (s, "Start src port: %u, End src port: %u\n",
-		  ip46_flow->udp_data.start_src_port,
-		  ip46_flow->udp_data.end_src_port);
-      s = format (s, "Start dst port: %u, End dst port: %u\n",
-		  ip46_flow->udp_data.start_dst_port,
-		  ip46_flow->udp_data.end_dst_port);
-      s = format (s, "Interval: %u\n", ip46_flow->udp_data.interval);
-
-      j = 0;
-      for (src_port = ip46_flow->udp_data.start_src_port;
-	   src_port <= ip46_flow->udp_data.end_src_port; src_port++)
-	{
-	  for (dst_port = ip46_flow->udp_data.start_dst_port;
-	       dst_port <= ip46_flow->udp_data.end_dst_port; dst_port++)
-	    {
-	      stats = ip46_flow->udp_data.stats + j;
-	      s =
-		format (s, "\nSrc Port - %u, Dst Port - %u, Flow CTX - %u\n",
-			src_port, dst_port, stats->flow_ctx);
-	      s =
-		format (s, "Path State - %s\n",
-			(stats->retry > MAX_PING_RETRIES) ? "Down" : "Up");
-	      s = format (s, "Path Data:\n");
-	      s = print_analyse_flow (s,
-				      &ip46_flow->udp_data.
-				      stats[j].analyse_data);
-	      j++;
-	    }
-	}
-      s = format (s, "\n\n");
-    }
-
-  vlib_cli_output (vm, "%v", s);
-  vec_free (s);
-  return 0;
-}
-
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (show_udp_ping_cmd, static) =
-{
-  .path = "show udp-ping summary",
-  .short_help = "Summary of udp-ping",
-  .function = show_udp_ping_summary_cmd_fn,
-};
-/* *INDENT-ON* */
-
-/**
- * @brief UDP-Ping Process node.
- * @node udp-ping-process
- *
- * This is process node which wakes up when periodically to send
- * out udp probe packets for all configured sessions.
- *
- * @param vm    vlib_main_t corresponding to the current thread.
- * @param rt    vlib_node_runtime_t data for this node.
- * @param f     vlib_frame_t whose contents should be dispatched.
- *
- */
-uword
-udp_ping_process (vlib_main_t * vm,
-		  vlib_node_runtime_t * rt, vlib_frame_t * f)
-{
-  f64 now;
-  uword *event_data = 0;
-  int i;
-  ip46_udp_ping_flow *ip46_flow;
-
-  while (1)
-    {
-      vec_reset_length (event_data);
-      vlib_process_wait_for_event_or_clock (vm, udp_ping_main.timer_interval);
-      (void) vlib_process_get_events (vm, &event_data);
-      now = vlib_time_now (vm);
-
-      for (i = 0; i < vec_len (udp_ping_main.ip46_flow); i++)
-	{
-	  if (pool_is_free_index (udp_ping_main.ip46_flow, i))
-	    continue;
-
-	  ip46_flow = pool_elt_at_index (udp_ping_main.ip46_flow, i);
-	  if (ip46_flow->udp_data.next_send_time < now)
-	    udp_ping_send_ip6_pak (udp_ping_main.vlib_main, ip46_flow);
-	}
-    }
-  return 0;
-}
-
-/**
- * @brief HopByHop analyse function for udp-ping response.
- *
- * Walks through all hbh options present in udp-ping response
- * and uses analyser library for the analysis.
- *
- */
-void
-udp_ping_analyse_hbh (vlib_buffer_t * b0,
-		      u32 flow_id,
-		      u16 src_port,
-		      u16 dst_port,
-		      ip6_hop_by_hop_option_t * opt0,
-		      ip6_hop_by_hop_option_t * limit0, u16 len)
-{
-  u8 type0;
-  ip46_udp_ping_flow *ip46_flow;
-  u16 flow_index;
-  ioam_analyser_data_t *data;
-  ioam_e2e_option_t *e2e;
-  ioam_trace_option_t *trace;
-
-  /* If the packet doesnt match UDP session then return */
-  if (PREDICT_FALSE (pool_is_free_index (udp_ping_main.ip46_flow, flow_id)))
-    return;
-
-  ip46_flow = udp_ping_main.ip46_flow + flow_id;
-  /* Check port is within range */
-  if (PREDICT_FALSE ((src_port < ip46_flow->udp_data.start_src_port) ||
-		     (src_port > ip46_flow->udp_data.end_src_port) ||
-		     (dst_port < ip46_flow->udp_data.start_dst_port) ||
-		     (dst_port > ip46_flow->udp_data.end_dst_port)))
-    return;
-
-  flow_index = (src_port - ip46_flow->udp_data.start_src_port) *
-    (ip46_flow->udp_data.end_dst_port - ip46_flow->udp_data.start_dst_port +
-     1);
-  flow_index += (dst_port - ip46_flow->udp_data.start_dst_port);
-  data = &(ip46_flow->udp_data.stats[flow_index].analyse_data);
-
-  data->pkt_counter++;
-  data->bytes_counter += len;
-
-  vnet_buffer (b0)->l2_classify.opaque_index =
-    ip46_flow->udp_data.stats[flow_index].flow_ctx;
-
-  while (opt0 < limit0)
-    {
-      type0 = opt0->type;
-      switch (type0)
-	{
-	case HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST:
-	  /* Add trace for here as it hasnt been done yet */
-	  vnet_buffer (b0)->sw_if_index[VLIB_TX] = ~0;
-	  trace = (ioam_trace_option_t *) opt0;
-	  if (PREDICT_FALSE
-	      ((trace->trace_hdr.trace_type & IOAM_FLAGS_MASK) & IOAM_BIT_FLAG_LOOPBACK_REPLY))
-	    {
-	      ip6_ioam_analyse_hbh_trace_loopback (data, &trace->trace_hdr,
-						   (trace->hdr.length - 2));
-	      return;
-	    }
-	  ip6_hbh_ioam_trace_data_list_handler (b0,
-						vlib_buffer_get_current (b0),
-						opt0);
-	  (void) ip6_ioam_analyse_hbh_trace (data, &trace->trace_hdr, len,
-					     (trace->hdr.length - 2));
-	  break;
-	case HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE:
-	  e2e = (ioam_e2e_option_t *) opt0;
-	  (void) ip6_ioam_analyse_hbh_e2e (data, &e2e->e2e_hdr, len);
-	  break;
-	case 0:		/* Pad1 */
-	  opt0 = (ip6_hop_by_hop_option_t *) ((u8 *) opt0) + 1;
-	  continue;
-	case 1:		/* PadN */
-	  break;
-	default:
-	  break;
-	}
-      opt0 = (ip6_hop_by_hop_option_t *) (((u8 *) opt0) + opt0->length +
-					  sizeof (ip6_hop_by_hop_option_t));
-    }
-  ip46_flow->udp_data.stats[flow_index].retry = 0;
-}
-
-/**
- * @brief UDP-Ping request/response handler function.
- *
- * Checks udp-ping packet type - request/response and handles them.
- * If not udp-ping packet then, strips off hbh options and enques
- * packet to protocol registered node to enable next protocol processing.
- *
- */
-void
-udp_ping_local_analyse (vlib_node_runtime_t * node, vlib_buffer_t * b0,
-			ip6_header_t * ip0, ip6_hop_by_hop_header_t * hbh0,
-			u16 * next0)
-{
-  ip6_main_t *im = &ip6_main;
-  ip_lookup_main_t *lm = &im->lookup_main;
-
-  *next0 = UDP_PING_NEXT_IP6_DROP;
-
-  /*
-   * Sanity check: hbh header length must be less than
-   * b0->current_length.
-   */
-  if (PREDICT_FALSE ((hbh0->length + 1) << 3) >= b0->current_length)
-    {
-      *next0 = UDP_PING_NEXT_DROP;
-      b0->error = node->errors[UDP_PING_ERROR_BADHBH];
-      return;
-    }
-
-  if (PREDICT_TRUE (hbh0->protocol == IP_PROTOCOL_UDP))
-    {
-      ip6_hop_by_hop_option_t *opt0;
-      ip6_hop_by_hop_option_t *limit0;
-      u16 p_len0;
-      udp_ping_t *udp0;
-
-      /* Check for udp ping packet */
-      udp0 = (udp_ping_t *) ((u8 *) hbh0 + ((hbh0->length + 1) << 3));
-      opt0 = (ip6_hop_by_hop_option_t *) (hbh0 + 1);
-      if ((udp0->ping_data.probe_marker1 ==
-	   clib_host_to_net_u32 (UDP_PING_PROBE_MARKER1)) &&
-	  (udp0->ping_data.probe_marker2 ==
-	   clib_host_to_net_u32 (UDP_PING_PROBE_MARKER2)))
-	{
-	  if (udp0->ping_data.msg_type == UDP_PING_PROBE)
-	    {
-	      udp_ping_create_reply_from_probe_ip6 (ip0, hbh0, udp0);
-	      /* Skip e2e processing */
-	      vnet_buffer (b0)->l2_classify.opaque_index = 0x7FFFFFFF;
-	      *next0 = UDP_PING_NEXT_IP6_LOOKUP;
-	      return;
-	    }
-
-	  /* Reply */
-	  opt0 = (ip6_hop_by_hop_option_t *) (hbh0 + 1);
-	  limit0 = (ip6_hop_by_hop_option_t *)
-	    ((u8 *) hbh0 + ((hbh0->length + 1) << 3));
-	  p_len0 = clib_net_to_host_u16 (ip0->payload_length);
-	  udp_ping_analyse_hbh (b0,
-				clib_net_to_host_u16 (udp0->
-						      ping_data.sender_handle),
-				clib_net_to_host_u16 (udp0->udp.dst_port),
-				clib_net_to_host_u16 (udp0->udp.src_port),
-				opt0, limit0, p_len0);
-
-	  /* UDP Ping packet, so return */
-	  return;
-	}
-    }
-
-  /* If next header is SR, then destination may get overwritten to
-   * remote address. So pass it to SR processing as it may be local packet
-   * afterall
-   */
-  if (PREDICT_FALSE (hbh0->protocol == IPPROTO_IPV6_ROUTE))
-    goto end;
-
-  /* Other case remove hbh-ioam headers */
-  u64 *copy_dst0, *copy_src0;
-  u16 new_l0;
-
-  vlib_buffer_advance (b0, (hbh0->length + 1) << 3);
-
-  new_l0 = clib_net_to_host_u16 (ip0->payload_length) -
-    ((hbh0->length + 1) << 3);
-
-  ip0->payload_length = clib_host_to_net_u16 (new_l0);
-
-  ip0->protocol = hbh0->protocol;
-
-  copy_src0 = (u64 *) ip0;
-  copy_dst0 = copy_src0 + (hbh0->length + 1);
-  copy_dst0[4] = copy_src0[4];
-  copy_dst0[3] = copy_src0[3];
-  copy_dst0[2] = copy_src0[2];
-  copy_dst0[1] = copy_src0[1];
-  copy_dst0[0] = copy_src0[0];
-
-end:
-  *next0 = lm->local_next_by_ip_protocol[hbh0->protocol];
-  return;
-}
-
-/**
- * @brief udp ping request/response packet receive node.
- * @node udp-ping-local
- *
- * This function receives udp ping request/response packets and process them.
- * For request packets, response is created and sent.
- * For response packets, they are analysed and results stored.
- *
- * @param vm    vlib_main_t corresponding to the current thread.
- * @param node  vlib_node_runtime_t data for this node.
- * @param frame vlib_frame_t whose contents should be dispatched.
- *
- * @par Graph mechanics: buffer, next index usage
- *
- * <em>Uses:</em>
- * - <code>udp_ping_local_analyse(node, p0, ip0, hbh0, &next0)</code>
- *     - Checks packet type - request/respnse and process them.
- *
- * <em>Next Index:</em>
- * - Dispatches the packet to ip6-lookup/ip6-drop depending on type of packet.
- */
-static uword
-udp_ping_local_node_fn (vlib_main_t * vm,
-			vlib_node_runtime_t * node, vlib_frame_t * frame)
-{
-  udp_ping_next_t next_index;
-  u32 *from, *to_next, n_left_from, n_left_to_next;
-
-  from = vlib_frame_vector_args (frame);
-  n_left_from = frame->n_vectors;
-  next_index = node->cached_next_index;
-
-  while (n_left_from > 0)
-    {
-      vlib_get_next_frame (vm, node, next_index, to_next, n_left_to_next);
-
-      while (n_left_from >= 4 && n_left_to_next >= 2)
-	{
-	  vlib_buffer_t *p0, *p1;
-	  ip6_header_t *ip0, *ip1;
-	  ip6_hop_by_hop_header_t *hbh0, *hbh1;
-	  u16 next0, next1;
-	  u32 pi0, pi1;
-
-	  /* Prefetch next iteration. */
-	  {
-	    vlib_buffer_t *p2, *p3;
-
-	    p2 = vlib_get_buffer (vm, from[2]);
-	    p3 = vlib_get_buffer (vm, from[3]);
-
-	    vlib_prefetch_buffer_header (p2, LOAD);
-	    vlib_prefetch_buffer_header (p3, LOAD);
-
-	    /* Prefetch 3 cache lines as we need to look deep into packet */
-	    CLIB_PREFETCH (p2->data, 3 * CLIB_CACHE_LINE_BYTES, STORE);
-	    CLIB_PREFETCH (p3->data, 3 * CLIB_CACHE_LINE_BYTES, STORE);
-	  }
-
-	  pi0 = to_next[0] = from[0];
-	  pi1 = to_next[1] = from[1];
-	  from += 2;
-	  n_left_from -= 2;
-	  to_next += 2;
-	  n_left_to_next -= 2;
-
-	  p0 = vlib_get_buffer (vm, pi0);
-	  p1 = vlib_get_buffer (vm, pi1);
-
-	  ip0 = vlib_buffer_get_current (p0);
-	  ip1 = vlib_buffer_get_current (p1);
-
-	  hbh0 = (ip6_hop_by_hop_header_t *) (ip0 + 1);
-	  hbh1 = (ip6_hop_by_hop_header_t *) (ip1 + 1);
-
-	  udp_ping_local_analyse (node, p0, ip0, hbh0, &next0);
-	  udp_ping_local_analyse (node, p1, ip1, hbh1, &next1);
-
-	  if (PREDICT_FALSE ((node->flags & VLIB_NODE_FLAG_TRACE)))
-	    {
-	      if (p0->flags & VLIB_BUFFER_IS_TRACED)
-		{
-		  udp_ping_trace_t *t0 =
-		    vlib_add_trace (vm, node, p0, sizeof (*t0));
-		  udp_ping_t *udp0;
-
-		  /* Check for udp ping packet */
-		  udp0 =
-		    (udp_ping_t *) ((u8 *) hbh0 + ((hbh0->length + 1) << 3));
-		  t0->src = ip0->src_address;
-		  t0->dst = ip0->dst_address;
-		  t0->src_port = clib_net_to_host_u16 (udp0->udp.src_port);
-		  t0->dst_port = clib_net_to_host_u16 (udp0->udp.dst_port);
-		  t0->handle =
-		    clib_net_to_host_u16 (udp0->ping_data.sender_handle);
-		  t0->msg_type = udp0->ping_data.msg_type;
-		  t0->next_index = next0;
-		}
-	      if (p1->flags & VLIB_BUFFER_IS_TRACED)
-		{
-		  udp_ping_trace_t *t1 =
-		    vlib_add_trace (vm, node, p1, sizeof (*t1));
-		  udp_ping_t *udp1;
-
-		  /* Check for udp ping packet */
-		  udp1 =
-		    (udp_ping_t *) ((u8 *) hbh1 + ((hbh1->length + 1) << 3));
-		  t1->src = ip1->src_address;
-		  t1->dst = ip1->dst_address;
-		  t1->src_port = clib_net_to_host_u16 (udp1->udp.src_port);
-		  t1->dst_port = clib_net_to_host_u16 (udp1->udp.dst_port);
-		  t1->handle =
-		    clib_net_to_host_u16 (udp1->ping_data.sender_handle);
-		  t1->msg_type = udp1->ping_data.msg_type;
-		  t1->next_index = next1;
-		}
-	    }
-
-	  vlib_validate_buffer_enqueue_x2 (vm, node, next_index,
-					   to_next, n_left_to_next,
-					   pi0, pi1, next0, next1);
-	}
-
-      while (n_left_from > 0 && n_left_to_next > 0)
-	{
-	  vlib_buffer_t *p0;
-	  ip6_header_t *ip0;
-	  ip6_hop_by_hop_header_t *hbh0;
-	  u16 next0;
-	  u32 pi0;
-
-	  pi0 = from[0];
-	  to_next[0] = pi0;
-	  from += 1;
-	  to_next += 1;
-	  n_left_from -= 1;
-	  n_left_to_next -= 1;
-
-	  p0 = vlib_get_buffer (vm, pi0);
-	  ip0 = vlib_buffer_get_current (p0);
-	  hbh0 = (ip6_hop_by_hop_header_t *) (ip0 + 1);
-
-	  udp_ping_local_analyse (node, p0, ip0, hbh0, &next0);
-
-	  if (PREDICT_FALSE ((node->flags & VLIB_NODE_FLAG_TRACE)))
-	    {
-	      if (p0->flags & VLIB_BUFFER_IS_TRACED)
-		{
-		  udp_ping_trace_t *t0 =
-		    vlib_add_trace (vm, node, p0, sizeof (*t0));
-		  udp_ping_t *udp0;
-
-		  /* Check for udp ping packet */
-		  udp0 =
-		    (udp_ping_t *) ((u8 *) hbh0 + ((hbh0->length + 1) << 3));
-		  t0->src = ip0->src_address;
-		  t0->dst = ip0->dst_address;
-		  t0->src_port = clib_net_to_host_u16 (udp0->udp.src_port);
-		  t0->dst_port = clib_net_to_host_u16 (udp0->udp.dst_port);
-		  t0->handle =
-		    clib_net_to_host_u16 (udp0->ping_data.sender_handle);
-		  t0->msg_type = udp0->ping_data.msg_type;
-		  t0->next_index = next0;
-		}
-	    }
-
-	  vlib_validate_buffer_enqueue_x1 (vm, node, next_index,
-					   to_next, n_left_to_next,
-					   pi0, next0);
-	}
-
-      vlib_put_next_frame (vm, node, next_index, n_left_to_next);
-    }
-
-  return frame->n_vectors;
-}
-
-/* *INDENT-OFF* */
-/*
- * Node for udp-ping-local
- */
-VLIB_REGISTER_NODE (udp_ping_local, static) =
-{
-  .function = udp_ping_local_node_fn,
-  .name = "udp-ping-local",
-  .vector_size = sizeof (u32),
-  .format_trace = format_udp_ping_trace,
-  .type = VLIB_NODE_TYPE_INTERNAL,
-  .n_next_nodes = UDP_PING_N_NEXT,
-  .n_errors = UDP_PING_N_ERROR,
-  .error_strings = udp_ping_error_strings,
-  .next_nodes =
-    {
-      [UDP_PING_NEXT_DROP] = "error-drop",
-      [UDP_PING_NEXT_PUNT] = "error-punt",
-      [UDP_PING_NEXT_UDP_LOOKUP] = "ip6-udp-lookup",
-      [UDP_PING_NEXT_ICMP] = "ip6-icmp-input",
-      [UDP_PING_NEXT_IP6_LOOKUP] = "ip6-lookup",
-      [UDP_PING_NEXT_IP6_DROP] = "ip6-drop",
-    },
-};
-/* *INDENT-ON* */
-
-static clib_error_t *
-udp_ping_init (vlib_main_t * vm)
-{
-  udp_ping_main.vlib_main = vm;
-  udp_ping_main.vnet_main = vnet_get_main ();
-  udp_ping_main.timer_interval = 1e9;
-
-  ip6_local_hop_by_hop_register_protocol (IP_PROTOCOL_UDP,
-					  udp_ping_local.index);
-  return 0;
-}
-
-/* *INDENT-OFF* */
-VLIB_INIT_FUNCTION (udp_ping_init) =
-{
-  .runs_after = VLIB_INITS("ip_main_init"),
-};
-/* *INDENT-ON* */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/udp-ping/udp_ping_packet.h b/ioam/udp-ping/udp_ping_packet.h
deleted file mode 100644
index 09dcb1c..0000000
--- a/ioam/udp-ping/udp_ping_packet.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef PLUGINS_IOAM_PLUGIN_IOAM_UDP_PING_UDP_PING_PACKET_H_
-#define PLUGINS_IOAM_PLUGIN_IOAM_UDP_PING_UDP_PING_PACKET_H_
-
-#include <vppinfra/clib.h>
-#include <vnet/ip/ip6_hop_by_hop_packet.h>
-#include <vnet/udp/udp_packet.h>
-
-#define UDP_PING_PROBE 1
-#define UDP_PING_REPLY 2
-
-#define UDP_PING_PROBE_MARKER1          0xDEAD
-#define UDP_PING_PROBE_MARKER2          0xBEEF
-
-/*
- * Refer to:
- * https://tools.ietf.org/html/draft-lapukhov-dataplane-probe-01
- *  0                   1                   2                   3
-    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   |                         Probe Marker (1)                      |
-   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   |                         Probe Marker (2)                      |
-   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   |   Version     | Message Type  |             Flags             |
-   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   |                     Telemetry Request Vector                  |
-   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   |   Hop Limit   |   Hop Count   |         Must Be Zero          |
-   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   |         Maximum Length        |        Current Length         |
-   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   |        Sender's Handle        |        Sequence Number        |
-   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
- *
- * (1)   The "Probe Marker" fields are arbitrary 32-bit values generally
-         used by the network elements to identify the packet as a probe
-         packet.  These fields should be interpreted as unsigned integer
-         values, stored in network byte order.  For example, a network
-         element may be configured to recognize a UDP packet destined to
-         port 31337 and having 0xDEAD 0xBEEF as the values in "Probe
-         Marker" field as an active probe, and treat it respectively.
-
-   (2)   "Version Number" is currently set to 1.
-
-   (3)   The "Message Type" field value could be either "1" - "Probe" or
-         "2" - "Probe Reply"
-
-   (4)   The "Flags" field is 8 bits, and defines the following flags:
-
-   (5)
-         (1)  "Overflow" (O-bit) (least significant bit).  This bit is
-              set by the network element if the number of records on the
-              packet is at the maximum limit as specified by the packet:
-              i.e. the packet is already "full" of telemetry
-              information.
-
-   (6)   "Telemetry Request Vector" is a 32-bit long field that requests
-         well-known inband telemetry information from the network
-         elements on the path.  A bit set in this vector translates to a
-         request of a particular type of information.  The following
-         types/bits are currently defined, starting with the least
-         significant bit first:
-
-         (1)  Bit 0: Device identifier.
-
-         (2)  Bit 1: Timestamp.
-
-         (3)  Bit 2: Queueing delay.
-
-         (4)  Bit 3: Ingress/Egress port identifiers.
-
-         (5)  Bit 31: Opaque state snapshot request.
-
-   (7)   "Hop Limit" is defined only for "Message Type" of "1"
-         ("Probe").  For "Probe Reply" the "Hop Limit" field must be set
-         to zero.  This field is treated as an integer value
-         representing the number of network elements.  See the Section 4
-         section on the intended use of the field.
-
-   (8)   The "Hop Count" field specifies the current number of hops of
-         capable network elements the packet has transit through.  It
-         begins with zero and must be incremented by one for every
-         network element that adds a telemetry record.  Combined with a
-         push mechanism, this simplifies the work for the subsequent
-         network element and the packet receiver.  The subsequent
-         network element just needs to parse the template and then
-         insert new record(s) immediately after the template.
-
-   (9)   The "Max Length" field specifies the maximum length of the
-         telemetry payload in bytes.  Given that the sender knows the
-         minimum path MTU, the sender can set the maximum of payload
-         bytes allowed before exceeding the MTU.  Thus, a simple
-         comparison between "Current Length" and "Max Length" allows to
-         decide whether or not data could be added.
-
-   (10)  The "Current Length" field specifies the current length of data
-         stored in the probe.  This field is incremented by eacn network
-         element by the number of bytes it has added with the telemetry
-         data frame.
-
-   (11)  The "Sender's Handle" field is set by the sender to allow the
-         receiver to identify a particular originator of probe packets.
-         Along with "Sequence Number" it allows for tracking of packet
-         order and loss within the network.
-
- *
- */
-typedef struct
-{
-  u32 probe_marker1;
-  u32 probe_marker2;
-  u8 version;
-  u8 msg_type;
-  u16 flags;
-  u32 tel_req_vec;
-  u8 hop_limit;
-  u8 hop_count;
-  u16 reserve;
-  u16 max_len;
-  u16 cur_len;
-  u16 sender_handle;
-  u16 seq_no;
-} udp_ping_data;
-
-typedef struct
-{
-  udp_header_t udp;
-  udp_ping_data ping_data;
-} udp_ping_t;
-
-#endif /* PLUGINS_IOAM_PLUGIN_IOAM_UDP_PING_UDP_PING_PACKET_H_ */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/udp-ping/udp_ping_test.c b/ioam/udp-ping/udp_ping_test.c
deleted file mode 100644
index 84b878c..0000000
--- a/ioam/udp-ping/udp_ping_test.c
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- *------------------------------------------------------------------
- * udp_ping_test.c - test harness for udp ping plugin
- *------------------------------------------------------------------
- */
-
-#include <vat/vat.h>
-#include <vlibapi/api.h>
-#include <vlibmemory/api.h>
-
-#include <vppinfra/error.h>
-#include <vnet/ip/ip.h>
-#include <vnet/format_fns.h>
-#include <vnet/ip/ip_types_api.h>
-
-#define __plugin_msg_base udp_ping_test_main.msg_id_base
-#include <vlibapi/vat_helper_macros.h>
-
-/* Declare message IDs */
-#include <ioam/udp-ping/udp_ping.api_enum.h>
-#include <ioam/udp-ping/udp_ping.api_types.h>
-
-typedef struct
-{
-  /* API message ID base */
-  u16 msg_id_base;
-  vat_main_t *vat_main;
-} udp_ping_test_main_t;
-
-udp_ping_test_main_t udp_ping_test_main;
-
-static int
-api_udp_ping_add_del (vat_main_t * vam)
-{
-  unformat_input_t *input = vam->input;
-  vl_api_udp_ping_add_del_t *mp;
-  int rv = 0;
-  ip46_address_t dst, src;
-  u32 start_src_port, end_src_port;
-  u32 start_dst_port, end_dst_port;
-  u32 interval;
-  u8 is_disable = 0;
-
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "src %U", unformat_ip46_address, &src))
-	;
-      else if (unformat (input, "start-src-port %d", &start_src_port))
-	;
-      else if (unformat (input, "end-src-port %d", &end_src_port))
-	;
-      else if (unformat (input, "start-dst-port %d", &start_dst_port))
-	;
-      else if (unformat (input, "end-dst-port %d", &end_dst_port))
-	;
-      else if (unformat (input, "dst %U", unformat_ip46_address, &dst))
-	;
-      else if (unformat (input, "interval %d", &interval))
-	;
-      else if (unformat (input, "disable"))
-	is_disable = 1;
-      else
-	break;
-    }
-
-  M (UDP_PING_ADD_DEL, mp);
-
-  ip_address_encode (&src, IP46_TYPE_IP6, &mp->src_ip_address);
-  ip_address_encode (&dst, IP46_TYPE_IP6, &mp->dst_ip_address);
-  mp->start_src_port = (u16) start_src_port;
-  mp->end_src_port = (u16) end_src_port;
-  mp->start_dst_port = (u16) start_dst_port;
-  mp->end_dst_port = (u16) end_dst_port;
-  mp->interval = (u16) interval;
-  mp->dis = is_disable;
-
-  S (mp);
-  W (rv);
-
-  return (rv);
-}
-
-static int
-api_udp_ping_export (vat_main_t * vam)
-{
-  unformat_input_t *input = vam->input;
-  vl_api_udp_ping_export_t *mp;
-  int rv = 0;
-  int is_add = 1;
-
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "export"))
-	is_add = 1;
-      else if (unformat (input, "disable"))
-	is_add = 0;
-      else
-	break;
-    }
-
-  M (UDP_PING_EXPORT, mp);
-
-  mp->enable = is_add;
-
-  S (mp);
-  W (rv);
-
-  return (rv);
-}
-
-/* Override generated plugin register symbol */
-#define vat_plugin_register udp_ping_vat_plugin_register
-#include <ioam/udp-ping/udp_ping.api_test.c>
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/udp-ping/udp_ping_util.c b/ioam/udp-ping/udp_ping_util.c
deleted file mode 100644
index 2b7ea30..0000000
--- a/ioam/udp-ping/udp_ping_util.c
+++ /dev/null
@@ -1,331 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <vnet/vnet.h>
-#include <vnet/ip/ip.h>
-#include <vnet/ip/ip6_hop_by_hop.h>
-#include <ioam/encap/ip6_ioam_e2e.h>
-#include <ioam/encap/ip6_ioam_trace.h>
-#include <ioam/udp-ping/udp_ping_packet.h>
-#include <ioam/udp-ping/udp_ping.h>
-
-#define UDP_PING_REWRITE_LEN 1000
-
-u16
-udp_ping_fill_udp_data (udp_ping_t * udp_ping,
-			u16 src_port, u16 dst_port, u8 msg_type, u16 ctx)
-{
-  /* Populate udp ping header */
-  udp_ping->udp.src_port = clib_host_to_net_u16 (src_port);
-  udp_ping->udp.dst_port = clib_host_to_net_u16 (dst_port);
-  udp_ping->udp.length = clib_host_to_net_u16 (sizeof (udp_ping_t));
-  udp_ping->udp.checksum = 0;
-  udp_ping->ping_data.probe_marker1 =
-    clib_host_to_net_u32 (UDP_PING_PROBE_MARKER1);
-  udp_ping->ping_data.probe_marker2 =
-    clib_host_to_net_u32 (UDP_PING_PROBE_MARKER2);
-  udp_ping->ping_data.version = 1;
-  udp_ping->ping_data.msg_type = msg_type;
-  udp_ping->ping_data.flags = clib_host_to_net_u16 (0);
-  udp_ping->ping_data.tel_req_vec = clib_host_to_net_u16 (0);
-  udp_ping->ping_data.hop_limit = 254;
-  udp_ping->ping_data.hop_count = 0;
-  udp_ping->ping_data.reserve = clib_host_to_net_u16 (0);
-  udp_ping->ping_data.max_len =
-    udp_ping->ping_data.cur_len = clib_host_to_net_u16 (0);
-  udp_ping->ping_data.sender_handle = clib_host_to_net_u16 (ctx);
-  udp_ping->ping_data.seq_no = clib_host_to_net_u16 (0);
-
-  return (sizeof (udp_ping_t));
-}
-
-/**
- * @brief Frame IPv6 udp-ping probe packet.
- *
- * Creates IPv6 UDP-Ping probe packet along with iOAM headers.
- *
- */
-int
-udp_ping_create_ip6_pak (u8 * buf,	/*u16 len, */
-			 ip6_address_t src, ip6_address_t dst,
-			 u16 src_port, u16 dst_port, u8 msg_type, u16 ctx)
-{
-  ip6_header_t *ip0;
-  ip6_hop_by_hop_header_t *hbh0;
-  //trace_profile *profile = NULL;
-  u16 hbh_len = 0, rnd_size = 0, ip0_len = 0, udp_len = 0;
-  u16 trace_len = 0, trace_data_size = 0;
-  u16 e2e_len = sizeof (ioam_e2e_option_t) - sizeof (ip6_hop_by_hop_option_t);
-  u8 *current = NULL;
-  ioam_trace_option_t *trace_option;
-  ioam_e2e_option_t *e2e;
-
-  ip0 = (ip6_header_t *) buf;
-
-  ip0->ip_version_traffic_class_and_flow_label =
-    clib_host_to_net_u32 (0x6 << 28);
-
-  ip0->protocol = IP_PROTOCOL_IP6_HOP_BY_HOP_OPTIONS;
-  ip0->hop_limit = 255;
-
-  ip0->src_address = src;
-  ip0->dst_address = dst;
-
-  hbh0 = (ip6_hop_by_hop_header_t *) (ip0 + 1);
-
-  /* Calculate hbh header len */
-  //profile = trace_profile_find();
-  trace_data_size = fetch_trace_data_size (trace_profile_find()); // NOTE: INSTR_BITMAP_MASK & ~(BIT_VAR_LEN_OP_ST_SNSH));
-  /* We need 2 times data for trace as packet traverse back to source */
-  trace_len = sizeof (ioam_trace_option_t) +
-    (5 * trace_data_size * 2) - sizeof (ip6_hop_by_hop_option_t);
-  //(profile->num_elts * trace_data_size * 2);
-  hbh_len = e2e_len + trace_len + sizeof (ip6_hop_by_hop_header_t);
-  rnd_size = (hbh_len + 7) & ~7;
-
-  /* Length of header in 8 octet units, not incl first 8 octets */
-  hbh0->length = (rnd_size >> 3) - 1;
-  hbh0->protocol = IP_PROTOCOL_UDP;
-
-  /* Populate hbh header */
-  current = (u8 *) (hbh0 + 1);
-
-  /* Populate trace */
-  trace_option = (ioam_trace_option_t *) current;
-  trace_option->hdr.type = HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST |
-    HBH_OPTION_TYPE_DATA_CHANGE_ENROUTE;
-  trace_option->hdr.length = trace_len;
-  trace_option->trace_hdr.trace_type =
-          IOAM_INSTR_BITMAP_MASK & ~(IOAM_BIT_VAR_LEN_OP_ST_SNSH);
-
-  trace_option->trace_hdr.node_len_flags_remaining_len &= (~IOAM_REMAIN_LEN_MASK);
-  trace_option->trace_hdr.node_len_flags_remaining_len |= 5 * 2;
-  //profile->num_elts * 2;
-
-  current += trace_option->hdr.length + sizeof (ip6_hop_by_hop_option_t);
-
-  /* Populate e2e */
-  e2e = (ioam_e2e_option_t *) current;
-  e2e->hdr.type = HBH_OPTION_TYPE_IOAM_EDGE_TO_EDGE;
-  e2e->hdr.length = e2e_len;
-
-  /* Move past hbh header */
-  current = ((u8 *) hbh0) + ((hbh0->length + 1) << 3);
-
-  /* Populate udp ping header */
-  udp_len = udp_ping_fill_udp_data ((udp_ping_t *) current,
-				    src_port, dst_port, msg_type, ctx);
-
-  /* Calculate total length and set it in ip6 header */
-  ip0_len = ((hbh0->length + 1) << 3) + udp_len;
-  //ip0_len = (len > ip0_len) ? len : ip0_len;
-  ip0->payload_length = clib_host_to_net_u16 (ip0_len);
-
-  return (ip0_len + sizeof (ip6_header_t));
-}
-
-int
-udp_ping_compare_flow (ip46_address_t src, ip46_address_t dst,
-		       u16 start_src_port, u16 end_src_port,
-		       u16 start_dst_port, u16 end_dst_port,
-		       ip46_udp_ping_flow * flow)
-{
-  if ((0 == ip46_address_cmp (&flow->src, &src)) &&
-      (0 == ip46_address_cmp (&flow->dst, &dst)) &&
-      (flow->udp_data.start_src_port == start_src_port) &&
-      (flow->udp_data.end_src_port == end_src_port) &&
-      (flow->udp_data.start_dst_port == start_dst_port) &&
-      (flow->udp_data.end_dst_port == end_dst_port))
-    {
-      return 0;
-    }
-
-  return -1;
-}
-
-void
-udp_ping_populate_flow (ip46_address_t src, ip46_address_t dst,
-			u16 start_src_port, u16 end_src_port,
-			u16 start_dst_port, u16 end_dst_port,
-			u16 interval, u8 fault_det, ip46_udp_ping_flow * flow)
-{
-  flow->src = src;
-  flow->dst = dst;
-  flow->udp_data.start_src_port = start_src_port;
-  flow->udp_data.end_src_port = end_src_port;
-  flow->udp_data.start_dst_port = start_dst_port;
-  flow->udp_data.end_dst_port = end_dst_port;
-  flow->udp_data.interval = interval;
-  flow->udp_data.next_send_time = 0;
-  flow->fault_det = fault_det;
-}
-
-void
-udp_ping_create_rewrite (ip46_udp_ping_flow * flow, u16 ctx)
-{
-  u16 src_port;
-  u16 dst_port;
-  u16 no_flows;
-  int i;
-  udp_ping_flow_data *stats;
-
-  no_flows =
-    (flow->udp_data.end_dst_port - flow->udp_data.start_dst_port) + 1;
-  no_flows *=
-    ((flow->udp_data.end_src_port - flow->udp_data.start_src_port) + 1);
-
-  vec_validate_aligned (flow->udp_data.stats,
-			no_flows - 1, CLIB_CACHE_LINE_BYTES);
-
-  i = 0;
-  for (src_port = flow->udp_data.start_src_port;
-       src_port <= flow->udp_data.end_src_port; src_port++)
-    {
-      for (dst_port = flow->udp_data.start_dst_port;
-	   dst_port <= flow->udp_data.end_dst_port; dst_port++)
-	{
-	  u8 *rewrite = NULL;
-
-	  stats = flow->udp_data.stats + i;
-	  ioam_analyse_init_data (&stats->analyse_data);
-	  stats->analyse_data.is_free = 0;
-
-	  vec_validate (rewrite, UDP_PING_REWRITE_LEN - 1);
-	  stats->ping_rewrite = rewrite;
-	  stats->rewrite_len =
-	    udp_ping_create_ip6_pak (rewrite,
-				     flow->src.ip6, flow->dst.ip6,
-				     src_port, dst_port, UDP_PING_PROBE, ctx);
-	  /* For each flow we need to create ioam e2e flow */
-	  stats->flow_ctx = ioam_flow_add (1, (u8 *) "udp_ping");	//FIXME
-	  i++;
-	}
-    }
-}
-
-void
-udp_ping_free_flow_data (ip46_udp_ping_flow * flow)
-{
-  int i;
-  udp_ping_flow_data *stats;
-
-  for (i = 0; i < vec_len (flow->udp_data.stats); i++)
-    {
-      stats = flow->udp_data.stats + i;
-      vec_free (stats->ping_rewrite);
-      stats->ping_rewrite = NULL;
-      stats->rewrite_len = 0;
-    }
-
-  vec_free (flow->udp_data.stats);
-  flow->udp_data.stats = NULL;
-}
-
-/**
- * @brief Create and send ipv6 udp-ping probe packet.
- *
- */
-void
-udp_ping_send_ip6_pak (vlib_main_t * vm, ip46_udp_ping_flow * flow)
-{
-  u16 no_pak;
-  u32 *buffers = NULL;
-  int i;
-  vlib_buffer_t *b0;
-  udp_ping_flow_data *stats;
-  vlib_frame_t *nf = 0;
-  u32 *to_next;
-  vlib_node_t *next_node;
-
-  next_node = vlib_get_node_by_name (vm, (u8 *) "ip6-lookup");
-  nf = vlib_get_frame_to_node (vm, next_node->index);
-  nf->n_vectors = 0;
-  to_next = vlib_frame_vector_args (nf);
-
-  no_pak = vec_len (flow->udp_data.stats);
-  vec_validate (buffers, (no_pak - 1));
-  if (vlib_buffer_alloc (vm, buffers, vec_len (buffers)) != no_pak)
-    {
-      //Error
-      return;
-    }
-
-  for (i = 0; i < no_pak; i++)
-    {
-      int bogus;
-      b0 = vlib_get_buffer (vm, buffers[i]);
-      stats = flow->udp_data.stats + i;
-      clib_memcpy_fast (b0->data, stats->ping_rewrite, stats->rewrite_len);
-      b0->current_data = 0;
-      b0->current_length = stats->rewrite_len;
-      b0->flags |= VLIB_BUFFER_TOTAL_LENGTH_VALID;
-
-      /* If session is going down, then set path down */
-      if ((stats->retry != 0) && ((stats->retry % MAX_PING_RETRIES) == 0))
-	ip6_ioam_analyse_set_paths_down (&stats->analyse_data);
-
-      stats->retry++;
-      stats->analyse_data.pkt_sent++;
-      vnet_buffer (b0)->sw_if_index[VLIB_RX] = 0;
-      vnet_buffer (b0)->sw_if_index[VLIB_TX] = ~0;
-      vnet_buffer (b0)->l2_classify.opaque_index = stats->flow_ctx;
-
-      ip6_header_t *ip6 = vlib_buffer_get_current (b0);
-      ip6_hop_by_hop_header_t *hbh = (ip6_hop_by_hop_header_t *) (ip6 + 1);
-      udp_header_t *udp =
-	(udp_header_t *) ((u8 *) hbh + ((hbh->length + 1) << 3));
-
-      /* If session is down, then set loopback flag in probe.
-       * This is for fault isolation.
-       */
-      if (flow->fault_det && (stats->retry > MAX_PING_RETRIES))
-	{
-	  ioam_trace_option_t *opt = (ioam_trace_option_t *)
-	    ip6_hbh_get_option (hbh, HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST);
-	  ip6_hbh_ioam_trace_set_flag_bit (opt, IOAM_BIT_FLAG_LOOPBACK);
-	}
-
-      /* Checksum not pre-computed as we intend to vary packet length for every
-       * probe. its isnt done yet, but to be taken up later.
-       */
-      udp->checksum = ip6_tcp_udp_icmp_compute_checksum (vm, b0, ip6, &bogus);
-      ASSERT (bogus == 0);
-      if (udp->checksum == 0)
-	udp->checksum = 0xffff;
-
-      if (nf->n_vectors == VLIB_FRAME_SIZE)
-	{
-	  vlib_put_frame_to_node (vm, next_node->index, nf);
-	  nf = vlib_get_frame_to_node (vm, next_node->index);
-	  nf->n_vectors = 0;
-	  to_next = vlib_frame_vector_args (nf);
-	}
-      *to_next = buffers[i];
-      nf->n_vectors++;
-      to_next++;
-    }
-  vlib_put_frame_to_node (vm, next_node->index, nf);
-
-  flow->udp_data.next_send_time =
-    vlib_time_now (vm) + flow->udp_data.interval;
-}
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/ioam/udp-ping/udp_ping_util.h b/ioam/udp-ping/udp_ping_util.h
deleted file mode 100644
index fcaf27b..0000000
--- a/ioam/udp-ping/udp_ping_util.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (c) 2017 Cisco and/or its affiliates.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef PLUGINS_IOAM_PLUGIN_IOAM_UDP_PING_UDP_PING_UTIL_H_
-#define PLUGINS_IOAM_PLUGIN_IOAM_UDP_PING_UDP_PING_UTIL_H_
-
-int udp_ping_create_ip6_pak (u8 * buf,	/*u16 len, */
-			     ip6_address_t src, ip6_address_t dst,
-			     u16 src_port, u16 dst_port,
-			     u8 msg_type, u16 ctx);
-
-int
-udp_ping_compare_flow (ip46_address_t src, ip46_address_t dst,
-		       u16 start_src_port, u16 end_src_port,
-		       u16 start_dst_port, u16 end_dst_port,
-		       ip46_udp_ping_flow * flow);
-
-void
-udp_ping_populate_flow (ip46_address_t src, ip46_address_t dst,
-			u16 start_src_port, u16 end_src_port,
-			u16 start_dst_port, u16 end_dst_port,
-			u16 interval, u8 fault_det,
-			ip46_udp_ping_flow * flow);
-
-void udp_ping_free_flow_data (ip46_udp_ping_flow * flow);
-
-void udp_ping_create_rewrite (ip46_udp_ping_flow * flow, u16 ctx);
-
-void udp_ping_send_ip6_pak (vlib_main_t * vm, ip46_udp_ping_flow * flow);
-
-/**
- * @brief Create and send ipv6 udp-ping response packet.
- *
- */
-always_inline void
-udp_ping_create_reply_from_probe_ip6 (ip6_header_t * ip,
-				      ip6_hop_by_hop_header_t * hbh,
-				      udp_ping_t * udp)
-{
-  ip6_address_t src;
-  u16 src_port;
-  ioam_trace_option_t *trace;
-
-  src = ip->src_address;
-
-  ip->src_address = ip->dst_address;
-  ip->dst_address = src;
-
-  trace = (ioam_trace_option_t *)
-    ip6_hbh_get_option (hbh, HBH_OPTION_TYPE_IOAM_TRACE_DATA_LIST);
-  ip6_hbh_ioam_trace_reset_bit (trace, BIT_LOOPBACK);
-
-  /* No need of endian transform */
-  src_port = udp->udp.src_port;
-
-  udp->udp.src_port = udp->udp.dst_port;
-  udp->udp.dst_port = src_port;
-  udp->udp.checksum = 0;	//FIXME
-
-  udp->ping_data.msg_type = UDP_PING_REPLY;
-}
-
-#endif /* PLUGINS_IOAM_PLUGIN_IOAM_UDP_PING_UDP_PING_UTIL_H_ */
-
-/*
- * fd.io coding-style-patch-verification: ON
- *
- * Local Variables:
- * eval: (c-set-style "gnu")
- * End:
- */
diff --git a/updates/crypto/aes256/aes256.c b/updates/crypto/aes256/aes256.c
deleted file mode 100644
index 612ee1d..0000000
--- a/updates/crypto/aes256/aes256.c
+++ /dev/null
@@ -1,415 +0,0 @@
-#include "aes256.h"
-
-#define KEY_LENGTH 8
-#define BLOCK_SIZE 4
-#define NUMB_ROUNDS 14
-
-uint8_t S_Box[256] = {
-  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
-  0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
-  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
-  0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
-  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
-  0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
-  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
-  0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
-  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
-  0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
-  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
-  0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
-  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
-  0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
-  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
-  0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
-  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
-  0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
-  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
-  0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
-  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
-  0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
-  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
-  0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
-  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
-  0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
-  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
-  0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
-  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
-  0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
-  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
-  0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
-};
-
-uint8_t Inverse_S_Box[256] = {
-  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,
-  0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
-  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
-  0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
-  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,
-  0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
-  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,
-  0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
-  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
-  0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
-  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,
-  0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
-  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,
-  0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
-  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
-  0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
-  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,
-  0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
-  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,
-  0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
-  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
-  0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
-  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,
-  0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
-  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,
-  0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
-  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
-  0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
-  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,
-  0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
-  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,
-  0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,
-};
-
-uint8_t R_Con[30] = {
-  0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
-  0x40, 0x80, 0x1b, 0x36, 0x6c, 0xc0, 
-  0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 
-  0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 
-  0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91,
-};
-
-void AES256MainECB(uint8_t *key, uint8_t *data, uint32_t datalen, uint8_t *returndata, uint32_t *returnlen, bool encrypt){
-  int temp = datalen;
-  int numbBlocks = ceil(datalen/16.0);
-  int dataBytes = 0;
-  int returnBytes = 0;
-  int i,x,y;
-  for(i = 0; i < numbBlocks; i++){
-    AES256_State state;
-    for(y = 0; y < 4; y++){
-      for(x = 0; x < 4; x++){
-        if(dataBytes < datalen){
-          state.x[y].x[x] = data[dataBytes++];
-        }else{
-          state.x[y].x[x] = 0x00;
-        }
-      }
-    }
-    if(encrypt)
-      state = AES256Encrypt(state, key);
-    else
-      state = AES256Decrypt(state, key);
-    for(y = 0; y < 4; y++){
-      for(x = 0; x < 4; x++){
-        returndata[returnBytes++] = state.x[y].x[x];
-      }
-    }
-  }
-  *returnlen = returnBytes;
-}
-
-void AES256MainCBC(uint8_t *key, uint8_t *data, uint8_t *iv, uint32_t datalen, uint8_t *returndata, uint32_t *returnlen, bool encrypt){
-  int temp = datalen;
-  int numbBlocks = ceil(datalen/16.0);
-  int dataBytes = 0;
-  int returnBytes = 0;
-  int i,x,y;
-  AES256_State ivState;
-  for(y = 0; y < 4; y++){
-    for(x = 0; x < 4; x++){
-      ivState.x[y].x[x] = iv[y * 4 + x];
-    }
-  }
-  for(i = 0; i < numbBlocks; i++){
-    AES256_State state;
-    for(y = 0; y < 4; y++){
-      for(x = 0; x < 4; x++){
-        if(dataBytes < datalen){
-          state.x[y].x[x] = data[dataBytes++];
-        }else{
-          state.x[y].x[x] = 0x00;
-        }
-      }
-    }
-    if(encrypt){
-      state = XorState(state, ivState);
-      state = AES256Encrypt(state, key);
-      ivState = state;
-    }else{
-      AES256_State temp = state;
-      state = AES256Decrypt(state, key);
-      state = XorState(state, ivState);
-      ivState = temp;
-    }
-    for(y = 0; y < 4; y++){
-      for(x = 0; x < 4; x++){
-        returndata[returnBytes++] = state.x[y].x[x];
-      }
-    }
-  }
-  *returnlen = returnBytes;
-}
-
-void AES256MainCTR(uint8_t *key, uint8_t *data, uint8_t *iv, uint32_t datalen, uint8_t *returndata, uint32_t *returnlen, bool encrypt){
-  int temp = datalen;
-  int numbBlocks = ceil(datalen/16.0);
-  int dataBytes = 0;
-  int returnBytes = 0;
-  int i,x,y;
-  AES256_State ivState;
-  for(y = 0; y < 4; y++){
-    for(x = 0; x < 4; x++){
-      ivState.x[y].x[x] = iv[y * 4 + x];
-    }
-  }
-  for(i = 0; i < numbBlocks; i++){
-    AES256_State state;
-    for(y = 0; y < 4; y++){
-      for(x = 0; x < 4; x++){
-        if(dataBytes < datalen){
-          state.x[y].x[x] = data[dataBytes++];
-        }else{
-          state.x[y].x[x] = 0x00;
-        }
-      }
-    }
-    AES256_State temp = AES256Encrypt(ivState, key);
-    state = XorState(state,temp);
-    ivState = IncState(ivState);
-    for(y = 0; y < 4; y++){
-      for(x = 0; x < 4; x++){
-        if(returnBytes == datalen)
-          break;
-        returndata[returnBytes++] = state.x[y].x[x];
-      }
-    }
-  }
-  *returnlen = returnBytes;
-}
-
-AES256_State AES256Encrypt(AES256_State state, uint8_t key[32]){
-  AES256_Word expanse[60];
-  KeyExpansion(key, expanse);
-  state = AddRoundKey(state, expanse, 0);
-  int i;
-  for(i = 0; i < NUMB_ROUNDS - 1; i++){
-    state = SubBytes(state, false);
-    state = ShiftRows(state);
-    state = MixColumns(state, false);
-    state = AddRoundKey(state, expanse, i+1);
-  }
-  state = SubBytes(state, false);
-  state = ShiftRows(state);
-  state = AddRoundKey(state, expanse, NUMB_ROUNDS);
-  return state;
-}
-
-AES256_State AES256Decrypt(AES256_State state, uint8_t key[32]){
-  AES256_Word expanse[60];
-  KeyExpansion(key, expanse);
-  state = AddRoundKey(state, expanse, NUMB_ROUNDS);
-  int i;
-  for(i = NUMB_ROUNDS - 1; i > 0; i--){
-    state = InvShiftRows(state);
-    state = SubBytes(state, true);
-    state = AddRoundKey(state, expanse, i);
-    state = MixColumns(state, true);
-  }
-  
-	state = InvShiftRows(state);
-  state = SubBytes(state, true);
-  state = AddRoundKey(state, expanse, 0);
-  return state;
-}
-
-char * _Print_Word(AES256_Word word){
-  static char buffer[10];
-  sprintf(buffer, "%02x%02x%02x%02x",word.x[0],word.x[1],word.x[2],word.x[3]);
-  return buffer;
-}
-
-char * _Print_State(AES256_State state){
-  static char buffer[40];
-  sprintf(buffer, "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
-          state.x[0].x[0],state.x[0].x[1],state.x[0].x[2],state.x[0].x[3],
-          state.x[1].x[0],state.x[1].x[1],state.x[1].x[2],state.x[1].x[3],
-          state.x[2].x[0],state.x[2].x[1],state.x[2].x[2],state.x[2].x[3],
-          state.x[3].x[0],state.x[3].x[1],state.x[3].x[2],state.x[3].x[3]
-          );
-  return buffer;
-}
-
-AES256_Word SubWord(AES256_Word word, bool inverse){
-  int i;
-  for(i = 0; i < 4; i++){
-    uint8_t higher = word.x[i] >> 4;
-    uint8_t lower = word.x[i] & 0x0f;
-    if(inverse)
-      word.x[i] = Inverse_S_Box[higher * 16 + lower];
-    else
-      word.x[i] = S_Box[higher * 16 + lower];
-  }
-  return word;
-}
-
-AES256_Word RotWord(AES256_Word word, uint8_t shift){
-  AES256_Word temp;
-  int i,j;
-  j = shift;
-  for(i = 0; i < 4; i++){
-    temp.x[i] = word.x[j];
-    j++;
-    if(j >= 4)
-      j = 0;
-  }
-  return temp;
-}
-
-AES256_Word XorRcon(AES256_Word word, uint8_t rcon){
-  uint8_t temp = R_Con[rcon];
-  word.x[0] = word.x[0] ^ temp;
-  return word;
-}
-
-AES256_Word XorWord(AES256_Word a, AES256_Word b){
-  AES256_Word temp;
-  int i;
-  for(i = 0; i < 4; i++)
-    temp.x[i] = a.x[i] ^ b.x[i];
-  return temp;
-}
-
-void KeyExpansion(uint8_t key[32], AES256_Word *expanse){
-  int i;
-  for(i = 0; i < 60; i++){
-    if(i < KEY_LENGTH){
-      expanse[i].x[0] = key[4*i];
-      expanse[i].x[1] = key[4*i+1];
-      expanse[i].x[2] = key[4*i+2];
-      expanse[i].x[3] = key[4*i+3];
-      // printf("[%02d]%s\n",i,_Print_Word(expanse[i]));
-    }else{
-      AES256_Word temp = expanse[i-1];
-      if(i % KEY_LENGTH == 0){
-        temp = XorRcon(SubWord(RotWord(temp,1), false),i/KEY_LENGTH-1);
-      }else if(KEY_LENGTH > 6 && i % KEY_LENGTH == 4){
-        temp = SubWord(temp, false);
-      }
-      expanse[i] = XorWord(expanse[i-KEY_LENGTH],temp);
-      // printf("[%02d]%s\n",i,_Print_Word(expanse[i]));
-    }
-  }
-}
-
-AES256_State AddRoundKey(AES256_State in, AES256_Word *expanse, uint8_t round){
-  int i;
-  for(i = 0; i < 4; i++){
-    in.x[i] = XorWord(in.x[i],expanse[round * 4 + i]);
-  }
-  return in;
-}
-
-AES256_State SubBytes(AES256_State in, bool inverse){
-  int i;
-  for(i = 0; i < 4; i++)
-    in.x[i] = SubWord(in.x[i],inverse);
-  return in;
-}
-
-AES256_State ShiftRows(AES256_State in){
-  AES256_State temp;
-  int i,j,k;
-  for(j = 0; j < 4; j++)
-    for(i = 0; i < 4; i++){
-      k = i+j;
-      if(k >= 4)
-        k -= 4;
-      temp.x[i].x[j] = in.x[k].x[j];
-    }  
-  return temp;  
-}
-
-AES256_State MixColumns(AES256_State in, bool inverse){
-  int i;
-  for(i = 0; i < 4; i++){
-    if(!inverse)
-      in.x[i] = MixColumn(in.x[i]);
-    else
-      in.x[i] = InvMixColumn(in.x[i]);
-  }
-  return in;
-}
-
-uint8_t gmul(uint8_t a, uint8_t b) {
-	uint8_t p = 0; 
-	while (a && b) {
-    if (b & 1) 
-      p ^= a;
-    if (a & 0x80) 
-      a = (a << 1) ^ 0x11b; 
-    else
-      a <<= 1;
-    b >>= 1;
-	}
-	return p;
-}
-
-AES256_Word MixColumn(AES256_Word r){
-  AES256_Word a;
-  a.x[0] = gmul(r.x[0],0x02) ^ gmul(r.x[1],0x03) ^ gmul(r.x[2],0x01) ^ gmul(r.x[3],0x01);
-  a.x[1] = gmul(r.x[0],0x01) ^ gmul(r.x[1],0x02) ^ gmul(r.x[2],0x03) ^ gmul(r.x[3],0x01);
-  a.x[2] = gmul(r.x[0],0x01) ^ gmul(r.x[1],0x01) ^ gmul(r.x[2],0x02) ^ gmul(r.x[3],0x03);
-  a.x[3] = gmul(r.x[0],0x03) ^ gmul(r.x[1],0x01) ^ gmul(r.x[2],0x01) ^ gmul(r.x[3],0x02);
-  return a;
-}
-
-AES256_Word InvMixColumn(AES256_Word r){
-  AES256_Word a;
-  a.x[0] = gmul(r.x[0],0x0e) ^ gmul(r.x[1],0x0b) ^ gmul(r.x[2],0x0d) ^ gmul(r.x[3],0x09);
-  a.x[1] = gmul(r.x[0],0x09) ^ gmul(r.x[1],0x0e) ^ gmul(r.x[2],0x0b) ^ gmul(r.x[3],0x0d);
-  a.x[2] = gmul(r.x[0],0x0d) ^ gmul(r.x[1],0x09) ^ gmul(r.x[2],0x0e) ^ gmul(r.x[3],0x0b);
-  a.x[3] = gmul(r.x[0],0x0b) ^ gmul(r.x[1],0x0d) ^ gmul(r.x[2],0x09) ^ gmul(r.x[3],0x0e);
-  return a;
-}
-
-AES256_State InvShiftRows(AES256_State in){
-  AES256_State temp;
-  int i,j,k;
-  for(j = 0; j < 4; j++)
-    for(i = 0; i < 4; i++){
-      k = i-j;
-      if(k < 0)
-        k += 4;
-      temp.x[i].x[j] = in.x[k].x[j];
-    }
-  return temp;
-}
-
-AES256_State XorState(AES256_State a, AES256_State b){
-  AES256_State temp;
-  int i;
-  for(i = 0; i < 4; i++)
-    temp.x[i] = XorWord(a.x[i], b.x[i]);
-  return temp;
-}
-
-AES256_State IncState(AES256_State a){
-  int x,y;
-  bool breakevent = false;
-  for(y = 3; y >= 0; y--){
-    for(x = 3; x >= 0; x--){
-      a.x[y].x[x] += 1;
-      if(!a.x[y].x[x] == 0)
-        breakevent = true;
-      if(breakevent)
-        break;
-    }
-    if(breakevent)
-      break;
-  }
-  return a;
-}
\ No newline at end of file
diff --git a/updates/crypto/aes256/aes256.h b/updates/crypto/aes256/aes256.h
deleted file mode 100644
index afc1329..0000000
--- a/updates/crypto/aes256/aes256.h
+++ /dev/null
@@ -1,34 +0,0 @@
-#ifndef AES256_H
-#define AES256_H
-
-#include <stdint.h>
-#include <math.h>
-
-typedef enum { false, true } bool;
-typedef struct AES256_Word { uint8_t x[4]; } AES256_Word; //4 bytes
-typedef struct AES256_State { AES256_Word x[4]; } AES256_State; //16 bytes
-
-AES256_State IncState(AES256_State);
-
-AES256_State AES256Encrypt(AES256_State, uint8_t*);
-AES256_State AES256Decrypt(AES256_State, uint8_t*);
-void AES256MainECB(uint8_t*, uint8_t*, uint32_t, uint8_t*, uint32_t*, bool);
-void AES256MainCBC(uint8_t*, uint8_t*, uint8_t*, uint32_t, uint8_t*, uint32_t*, bool);
-void AES256MainCTR(uint8_t*, uint8_t*, uint8_t*, uint32_t, uint8_t*, uint32_t*, bool);
-char * _Print_Word(AES256_Word);
-char * _Print_State(AES256_State);
-AES256_Word SubWord(AES256_Word, bool);
-AES256_Word RotWord(AES256_Word, uint8_t);
-AES256_Word XorRcon(AES256_Word, uint8_t);
-AES256_Word XorWord(AES256_Word, AES256_Word);
-void KeyExpansion(uint8_t[], AES256_Word[]);
-AES256_State AddRoundKey(AES256_State, AES256_Word*, uint8_t);
-AES256_State SubBytes(AES256_State, bool);
-AES256_State ShiftRows(AES256_State);
-AES256_Word InvMixColumn(AES256_Word);
-AES256_Word MixColumn(AES256_Word);
-AES256_State MixColumns(AES256_State, bool);
-AES256_State InvShiftRows(AES256_State);
-AES256_State XorState(AES256_State, AES256_State);
-
-#endif
\ No newline at end of file
diff --git a/updates/crypto/keys/keys.c b/updates/crypto/keys/keys.c
deleted file mode 100644
index 62cbec1..0000000
--- a/updates/crypto/keys/keys.c
+++ /dev/null
@@ -1,19 +0,0 @@
-#include "keys.h"
-
-char data[][10]= {
-    "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U",
-    "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p",
-    "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" 
-};
-
-char* generatEAS256Keys(){
-    char *key;
-    time_t t;
-    key = malloc(sizeof(char) * EAS256_KEY_SIZE);
-    srand((unsigned) time(&t));
-    for (int i=0; i<EAS256_KEY_SIZE; i++){
-        int index = rand() % 58;
-        strcpy(&key[i], data[index]);
-    }
-    return key;
-}
diff --git a/updates/crypto/keys/keys.h b/updates/crypto/keys/keys.h
deleted file mode 100644
index 87620ab..0000000
--- a/updates/crypto/keys/keys.h
+++ /dev/null
@@ -1,11 +0,0 @@
-#ifndef KEYS_H
-#define KEYS_H
-
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#define EAS256_KEY_SIZE 64
-char* generatEAS256Keys();
-
-#endif
\ No newline at end of file
diff --git a/updates/crypto/keys/test b/updates/crypto/keys/test
deleted file mode 100644
index 4dd4f106797695b6575f4b3d514597f970d83631..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 17648
zcmeHPZ)_aZ5r5~469<y>1(M<<CE2Ec5|A&paZ-n3;<J6u8k|2QHiVY2Ip3Y_Bj-DF
zw+D9Af-6&$ljCBl{(%a$;X~C(g(|I7DST+LNg<&vtwRM0MW}9-s5UJ$n1Vtfxz4<u
zdEQ%}+p6M2rS4d_GxK{h^WM(xzI|_ZpC1afwUl@~g2^jx5vXa)ETn-7s_IDq)*$M{
zQrNB)Ys5m(7f8%1Z?G7YT6CtQke3ne1&)3dC=}tJwqU`WTZkO}=A*tvRta<Aw{-L?
zMUiwT|0cDAIhU*YG;{{i<W})RXaL0A?uWTKR4I$aA<7@~1+p<hlo4k?Oc(k+PJWM*
zAM^86A9Kzp<^+Frv>#5cK^c-Jw@@!}_S;K-PTov*%+Vfc&p9)Sva=r6H8cX!<aV~c
zUF7Gd0w-@Hd*)o<?cj%b`A>-t^KPndzT?nO=O=SYuh^J~cW$oTn21&;;>m1(Wq;k~
z%FVTbOe#<#n}F@YI`Hsq+tDE)%ot*nMtLljlaA%DHNN@k_WbvoGV6bL?CQYG-e*={
zdXi&cooIuE{?sI?qr3!uXk+dFS0s)Y(&^Z5dM&B=HUqF$r08<Mt|)?EJr5q32fu9|
z9Ag)Y|0v)Z{G3z)Kr#DG^WfhFT!WvJt^}Z1oSOk(=QKtgj&lSL>t>NL(~-Ubkx7S>
zQDMe=W5O^pW;k-di1ZvVy29~<=u5|wW|!y<ClaX$6i52QMprx;PQ(wQHO4}hv}yE)
z<4Litt+lbqs0q|6sV1;V7_IHwjc6<#>yBs4Sh{_CQzDg&wTC+s7^Ay4m82MkWm?n_
zn_dEEONsnL8P61Ji)9{=J;3=oSRRir#j|T4VcAvj#c1D+#z5RJalgPx9Hst;@iDqD
zlr=~<)sL`#W~+tcxr+5OP1<no@~~{mhEvxqUC!I^%Qy(|3pSju0W3a3IL5GFKSymi
zUz=!u%!YFxgZOb9Ztri#Y&hov?N8ZoNT{L-8;;kSOKt|-47eF^GvH>x&48PM|CJ29
zSH9*S`p{p?^x@LiHwvMDb<8ZuPv}FxC_5pWnBR0Sz%%)44*)A)E6~0NOJ=73n9t`&
zrH%u=nd#F?#{t;P^tjS-;59S-W2NJOYi9Z>rQ?8bX8JLu<G^cX`YWtM?b~JT%|g}>
z`Z<`7l&_uD-*o7&I`o$v`U?*IXAb?RcD?%T*4*iP^xU8Hp|j_AwYQCww!j|hBTIh^
zJFbt^KL#wn;_Kk@_fb%{R3lnigKWzMa|NU}31yht#retdwS%yC;skN9Uo7o6l_1-2
zNza|v$KTnik6-ZWo)`7gm(1l5AVdMm@{?V1zu6!2KUhCr1tGIHbm&9%>%dazxpU?c
zeYpNQP^O-}l+RB^A(=0hJ^^-~ec-F=NB`*upb&))@Pm^<i|WG*u3azVgf3K%J=Xx@
z)GH81&xOwGBcUlhck(!3V(J+Hb0??11?*&K5~06zO&v$e$b=q$W$~}-NA&TxG|%(7
z)8ikOKC$6+?w7fav%?){54>{IhKXG0>~QETn&u|-@yQb1GogFN^pO>hz|#-i^ZamV
zQjeU{hoMr>DLwZZR6F(2#e9A!H0c@o^5oVBzah(pvlpWJjkU7HX6e*4SiE$C_s44I
z8rVZU_abDw9Hv1Qb{g!YwC_Y$pnUDa*m`+>1@CMdsXuVN5WzcIbFT$ET66CQ+k?4}
zJM@vty8+(Qw&5aPGgHrf3{l4~dd;=fZ_x2<%gwaq-f7PLIhbGm2Yu*-N8j>h_AR`g
zzPK-VcW__uo}h7}tFS)2(y+PmI#gGlY>vBeGvH>x&48N$Hv?`4+zhxGa5La$z|FuX
zmH~WEbRagMRaV}jU7NW~cvgEqkMCab9f$vXK0gS26!=l#M}Ut3_rIIZ<1>H{fu8~X
z(o8;o0l0WCpRa(qa3Apf_)Gu@-+>}|4(=A7e!pk+l0{{sP=+|Z+sBwNw-=&$k$hEk
z4T!byJM=fJZsGH{_$qEKzx;u+L9un!P1oOe%{nwk|GVKg33mLBi*XZ#Gl2IYK!kN2
zhTlqP^8{icpZ}4Prlku@PC|>Uwmc2+OHdAz&)M>*EEe#nLHrtilTaSR@)n=}(UMkQ
z#n-$cpEj}}<XeBZwAokn$U@y$H?(M*uOaEH3;L>pzV(eht<hJ}=<_%F%H;dF<*@%{
zkTd&xFbwIEn*lciZU)>8xEXLW;AX(hfSUm~1OF!(ppO>$`#PFFsc-0(a2jZ`18=b;
z9l{SDfmT{feaE+&bezW_t+JTl@A+^(gv90VU&^OYKSCeLsksRW{4LxmD(7$V<O?+L
z<8Rz5FbL2Ji>WQSi9_^V9KIq(I%+XBPvma^uOj>uRm^x9>D=xyvg2>>xc)VSv)xB|
zYyWWSg+=g+Qts~=+CO+dD0R*|OiQJHoXS5Wo%e&ne`1Wk?{)^PqT}5_d>8Tk#QTU3
z5+5b*jPvjGvWDUoK?OG|sYyvVE4C=af@o3FHYMpwYE{y$O2Ti5Eox&yY**3_CGAww
zE+yTrq}@u|qoj5vSzlM9dWXX9RMK80-KC^2C@HL@P9;T@6jf48NnJ|nR#K0W;!3(#
zNe7gaP*Sgwl1h>%rPTTqcAt{cO2Y5HEyAZE7G+rw_bcfECG{(5KuHIcRHY>NOo6C|
z1#zR2YL$dvZd<gO1@Sp0)hTI<lD0K9-K4GW=*%X~thOak8>p(R&PuKN!J4W-Rc)Yp
zgM}-XqJkHC&59xyDt;}^>l5sbUidD0Z&CXN;!8#GQq@lu##t!1e=NkI_o9BJ5HAzl
zzZBw&1@}vZ_+^6oze4<S!Tn?*4tI?r{ec%&?`TDFpEyz!FBiv(;(oPGsIcB;g6~U(
zINankJ7URRai#DV#g~iyMe!BtK4*{S6`xY~w?h0XQLKOUiVAf<Dzt~YX@ecHWG~!B
z56^ak%D^l5ZmS@9-(Dcz&Cep1g!l0hI4HZ86_)r2A9UcKA)Lnr?1fj7$JQPX6=3h{
zDUt{5OR!%4uAj^WUh5vXTl4q-j6V)SvG!v<#qjURILpPu*kA`0vwud~teA7Weh#=t
z%spNw$==z{-%EV%`SZ4nQ{?!TU>@dP7hc%0D<D6EG@jzi^-91sSx4dKM-rcVo@|tH
z3T;tq0^ARyH0SxV6zxmqUN5)K6Q^q){NOzJ6Z7Ct1CH%+p6Aa3uFY+}I0g8!l9j?a
zPIwh@JgLZO0r`d`zEWrn7Lb6vBb@~ttmn`N688%~<)81R3&F3L{j(6k59j}AV_~SD
zP#le}qm5L&3gV!>Gym7g_<r#^RZ>azHxRy<@Cm}}0mnQz>um*GBO5!50KU!+ko=u_
z@*pB<Gh=4q3$cipT_a?ey+#CA31wh~P&8$9CsLi^gb_7U>5LK1_KQfWw=WShW6?le
z)#mErMz~TbZiLh6@PH9Zn&|=2l@9mDjA*vEcK}>$ngNz(fvFkGn9wA{XxSay9x_5Z
znhjW<RA?6!M)O@eg4<i03QOdQD1cy%n-S6}g5JDa7~9%*HU`^_oh>bULhVL-u(2(K
zQRO<SNG2;={4du_S!=c$8hE9ZTwfK7hRra9DO|iYYg9|?xMmUQ=3Ks2SS*)?6+&<*
zpdxFr7F1Wba?6NjQbrFfCBs!+tvkUg8c!P8Ow3wa=8U9v88c4{%$zoznG97XSC@6i
zlCgBy3<dYpY}$NVYyi&<SWL#p23MICT{>2{Y^|^o5y%Ymn&D31X4>LCEWy&ZSh`OH
zk|{G5=uTz>ed$zRENu?hpw4U@mQ2Q@1O*#gE6s4Xkmfz%Opgde2a-^Q#m%%;a(^tH
ziKmhUiUDQmSR#xLB=sds5s>)_fEegbfr>&V77+n6)(<M4;$WSUXFwp<Lnn1l6r!<a
z#jwt9%Y$X8D%=}~V3s@NTLj?B>V>PN$R+$=K{!%?OCRn*7V$WhInT?fSlY6T{Il?b
z(WLU{@ho!<%Iw7RU&e4OZuj3y<6Gv}upx2o&l$$~o86zs$ILZ0B<}RbIoAg;m*)NF
z=MBucewya1=Mx+@3<5rDV1FKOGq1zs0%03b<o&Ne5D4d9xXbLX#^rRwKaNH=qHqei
z4<vk6!2UdbXU@-AxczL${6X-?XAi9NIG=eH)#PkHH(&$=%qjcxe1Q2F8FKy3{r@)k
zH<BIC8<-!p`D4zU{!amhIpO$lQ?-b=b0q9M{!cpmHS%LVNa2_{!iyg`{Ev_UbGDz)
z|Cqy{=QYgx*pWELV~*nv`~LGdgL#Y(jKiP9KIib~c@p!bY)IUhzZb|~Rilw1ac(D}
z@?2pV`OEOb_OriV0|khAo29C)v;H@r#O}XevrL(<$3h$N`NPmT5OA);(`p{i^ZI<J
zJ?qTh1>bU;KR?eLrGXpUfr%v6nO_7H&t0yc=Y{<L7Wn@v;Pr>Zew^1I0*1TD{`@@i
z5Dhf@(aA>a&wL>`+x<lY8CO~SFdrC#HR8;cfHTJ8`guHixW=+@9xtrRPRpo%s!kQL
z{|ySU1opRcM-!#tajO3ebqrSn8h{_~H}}7b0pqqyN7{^Tv4n>l!MR?xT?Rri|MHtH
Li&YK>hbsOFVIFBU

diff --git a/updates/crypto/keys/test.c b/updates/crypto/keys/test.c
deleted file mode 100644
index baf5a4e..0000000
--- a/updates/crypto/keys/test.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "eas256Keys.c"
-
-
-int main(){
-    printf("key --> %s\n", generatEAS256Keys());
-}
\ No newline at end of file
diff --git a/updates/crypto/sha256/sha256.c b/updates/crypto/sha256/sha256.c
deleted file mode 100644
index 5b307d7..0000000
--- a/updates/crypto/sha256/sha256.c
+++ /dev/null
@@ -1,141 +0,0 @@
-#include "sha256.h"
-
-/****************************** MACROS ******************************/
-#define ROTLEFT(a,b) (((a) << (b)) | ((a) >> (32-(b))))
-#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))
-
-#define CH(x,y,z) (((x) & (y)) ^ (~(x) & (z)))
-#define MAJ(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
-#define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))
-#define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))
-#define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))
-#define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))
-
-/**************************** VARIABLES *****************************/
-static const u32 k[64] = {
-	0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
-	0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
-	0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
-	0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
-	0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
-	0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
-	0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
-	0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
-};
-
-/*********************** FUNCTION DEFINITIONS ***********************/
-void sha256_transform(SHA256_CTX *ctx, const u8 data[])
-{
-	u32 a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];
-
-	for (i = 0, j = 0; i < 16; ++i, j += 4)
-		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
-	for ( ; i < 64; ++i)
-		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
-
-	a = ctx->state[0];
-	b = ctx->state[1];
-	c = ctx->state[2];
-	d = ctx->state[3];
-	e = ctx->state[4];
-	f = ctx->state[5];
-	g = ctx->state[6];
-	h = ctx->state[7];
-
-	for (i = 0; i < 64; ++i) {
-		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
-		t2 = EP0(a) + MAJ(a,b,c);
-		h = g;
-		g = f;
-		f = e;
-		e = d + t1;
-		d = c;
-		c = b;
-		b = a;
-		a = t1 + t2;
-	}
-
-	ctx->state[0] += a;
-	ctx->state[1] += b;
-	ctx->state[2] += c;
-	ctx->state[3] += d;
-	ctx->state[4] += e;
-	ctx->state[5] += f;
-	ctx->state[6] += g;
-	ctx->state[7] += h;
-}
-
-void sha256_init(SHA256_CTX *ctx)
-{
-	ctx->datalen = 0;
-	ctx->bitlen = 0;
-	ctx->state[0] = 0x6a09e667;
-	ctx->state[1] = 0xbb67ae85;
-	ctx->state[2] = 0x3c6ef372;
-	ctx->state[3] = 0xa54ff53a;
-	ctx->state[4] = 0x510e527f;
-	ctx->state[5] = 0x9b05688c;
-	ctx->state[6] = 0x1f83d9ab;
-	ctx->state[7] = 0x5be0cd19;
-}
-
-void sha256_update(SHA256_CTX *ctx, const u8 data[], size_t len)
-{
-	u32 i;
-
-	for (i = 0; i < len; ++i) {
-		ctx->data[ctx->datalen] = data[i];
-		ctx->datalen++;
-		if (ctx->datalen == 64) {
-			sha256_transform(ctx, ctx->data);
-			ctx->bitlen += 512;
-			ctx->datalen = 0;
-		}
-	}
-}
-
-void sha256_final(SHA256_CTX *ctx, u8 hash[])
-{
-	u32 i;
-
-	i = ctx->datalen;
-
-	// Pad whatever data is left in the buffer.
-	if (ctx->datalen < 56) {
-		ctx->data[i++] = 0x80;
-		while (i < 56)
-			ctx->data[i++] = 0x00;
-	}
-	else {
-		ctx->data[i++] = 0x80;
-		while (i < 64)
-			ctx->data[i++] = 0x00;
-		sha256_transform(ctx, ctx->data);
-		memset(ctx->data, 0, 56);
-	}
-
-	// Append to the padding the total message's length in bits and transform.
-	ctx->bitlen += ctx->datalen * 8;
-	ctx->data[63] = ctx->bitlen;
-	ctx->data[62] = ctx->bitlen >> 8;
-	ctx->data[61] = ctx->bitlen >> 16;
-	ctx->data[60] = ctx->bitlen >> 24;
-	ctx->data[59] = ctx->bitlen >> 32;
-	ctx->data[58] = ctx->bitlen >> 40;
-	ctx->data[57] = ctx->bitlen >> 48;
-	ctx->data[56] = ctx->bitlen >> 56;
-	sha256_transform(ctx, ctx->data);
-
-	// Since this implementation uses little endian u8 ordering and SHA uses big endian,
-	// reverse all the u8s when copying the final state to the output hash.
-	for (i = 0; i < 4; ++i) {
-		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
-		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
-		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
-		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
-		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
-		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
-		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
-		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
-	}
-}
\ No newline at end of file
diff --git a/updates/crypto/sha256/sha256.h b/updates/crypto/sha256/sha256.h
deleted file mode 100644
index 796c8a7..0000000
--- a/updates/crypto/sha256/sha256.h
+++ /dev/null
@@ -1,24 +0,0 @@
-#ifndef SHA256_H
-#define SHA256_H
-
-
-#include <stddef.h>
-#include <stdlib.h>
-#include <memory.h>
-
-
-#define SHA256_BLOCK_SIZE 32            // SHA256 outputs a 32 u8 digest
-
-typedef struct {
-	u8 data[64];
-	u32 datalen;
-	u32 bitlen;
-	u32 state[8];
-} SHA256_CTX;
-
-
-void sha256_init(SHA256_CTX *ctx);
-void sha256_update(SHA256_CTX *ctx, const u8 data[], size_t len);
-void sha256_final(SHA256_CTX *ctx, u8 hash[]);
-
-#endif  
\ No newline at end of file
diff --git a/updates/crypto/test/test_sha256.c b/updates/crypto/test/test_sha256.c
deleted file mode 100644
index 0db8ae0..0000000
--- a/updates/crypto/test/test_sha256.c
+++ /dev/null
@@ -1,48 +0,0 @@
-/*************************** HEADER FILES ***************************/
-#include <stdio.h>
-#include <memory.h>
-#include <string.h>
-#include "../sha256/sha256.c"
-
-/*********************** FUNCTION DEFINITIONS ***********************/
-int sha256_test()
-{
-	u8 text1[] = {"abc"};
-	u8 text2[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
-	u8 text3[] = {"aaaaaaaaaa"};
-	u8 hash1[SHA256_BLOCK_SIZE] = {0xba,0x78,0x16,0xbf,0x8f,0x01,0xcf,0xea,0x41,0x41,0x40,0xde,0x5d,0xae,0x22,0x23,
-	                                 0xb0,0x03,0x61,0xa3,0x96,0x17,0x7a,0x9c,0xb4,0x10,0xff,0x61,0xf2,0x00,0x15,0xad};
-	u8 hash2[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
-	                                 0xa3,0x3c,0xe4,0x59,0x64,0xff,0x21,0x67,0xf6,0xec,0xed,0xd4,0x19,0xdb,0x06,0xc1};
-	u8 hash3[SHA256_BLOCK_SIZE] = {0xcd,0xc7,0x6e,0x5c,0x99,0x14,0xfb,0x92,0x81,0xa1,0xc7,0xe2,0x84,0xd7,0x3e,0x67,
-	                                 0xf1,0x80,0x9a,0x48,0xa4,0x97,0x20,0x0e,0x04,0x6d,0x39,0xcc,0xc7,0x11,0x2c,0xd0};
-	u8 buf[SHA256_BLOCK_SIZE];
-	SHA256_CTX ctx;
-	int idx;
-	int pass = 1;
-
-	sha256_init(&ctx);
-	sha256_update(&ctx, text1, strlen(text1));
-	sha256_final(&ctx, buf);
-	pass = pass && !memcmp(hash1, buf, SHA256_BLOCK_SIZE);
-
-	sha256_init(&ctx);
-	sha256_update(&ctx, text2, strlen(text2));
-	sha256_final(&ctx, buf);
-	pass = pass && !memcmp(hash2, buf, SHA256_BLOCK_SIZE);
-
-	sha256_init(&ctx);
-	for (idx = 0; idx < 100000; ++idx)
-	   sha256_update(&ctx, text3, strlen(text3));
-	sha256_final(&ctx, buf);
-	pass = pass && !memcmp(hash3, buf, SHA256_BLOCK_SIZE);
-
-	return(pass);
-}
-
-int main()
-{
-	printf("SHA-256 tests: %s\n", sha256_test() ? "SUCCEEDED" : "FAILED");
-
-	return(0);
-}
diff --git a/updates/crypto/utility/convert.c b/updates/crypto/utility/convert.c
deleted file mode 100644
index 77a0a4e..0000000
--- a/updates/crypto/utility/convert.c
+++ /dev/null
@@ -1,49 +0,0 @@
-#include "convert.h"
-
-void str_to_bytes(char *str, uint8_t *bytes){
-  int str_len = strlen(str);
-  int i;
-  for(i = 0; i < str_len; i++){
-    bytes[i] = str[i];
-  }
-}
-
-char* bytes_to_hexstr(uint8_t *bytes, uint32_t length){
-  static char buffer[(uint32_t)MAX_MSG_LGTH * 2];
-  memset(buffer, 0, strlen(buffer));
-  int i;
-  for(i = 0; i < length; i++){
-    sprintf(buffer + strlen(buffer), "%02x", bytes[i]);
-    if((i + 1) % 16 == 0){
-      sprintf(buffer + strlen(buffer),"\n");
-    }
-  }
-  if(length % 16 != 0)
-    sprintf(buffer + strlen(buffer),"\n");
-  return buffer;
-}
-
-char* bytes_to_str(uint8_t *bytes, uint32_t length){
-  static char buffer[(uint32_t)MAX_MSG_LGTH];
-  memset(buffer, 0, strlen(buffer));
-  int i;
-  for(i = 0; i < length; i++){
-    if(bytes[i] == 0 || 32 <= bytes[i] && bytes[i] <= 126)
-      sprintf(buffer + strlen(buffer), "%c", bytes[i]);
-    else
-      sprintf(buffer + strlen(buffer), "%c", '_');
-  }
-  return buffer;
-}
-
-void parse_02X(uint8_t *key, char *arg, int bytes){
-  int iter;
-  for(iter = 0; iter < bytes; iter ++){
-    uint8_t tempbit;
-    char temp[2] = "";
-    temp[0] = (char*)arg[iter*2];
-    temp[1] = (char*)arg[iter*2+1];
-    sscanf(temp, "%02hhX", &tempbit);
-    key[iter] = tempbit;
-  }
-}
\ No newline at end of file
diff --git a/updates/crypto/utility/convert.h b/updates/crypto/utility/convert.h
deleted file mode 100644
index dab7831..0000000
--- a/updates/crypto/utility/convert.h
+++ /dev/null
@@ -1,15 +0,0 @@
-#ifndef CONVERT_H
-#define CONVERT_H
-
-#include <stdio.h>
-#include <unistd.h>
-#include "aes256.h"
-
-#define MAX_MSG_LGTH 10000
-
-void str_to_bytes(char *str, uint8_t *bytes);
-char* bytes_to_hexstr(uint8_t *bytes, uint32_t length);
-char* bytes_to_str(uint8_t *bytes, uint32_t length);
-void parse_02X(uint8_t *key, char *arg, int bytes);
-
-#endif
\ No newline at end of file
diff --git a/updates/trace_integrity/trace_integrity.c b/updates/trace_integrity/trace_integrity.c
deleted file mode 100644
index 1599486..0000000
--- a/updates/trace_integrity/trace_integrity.c
+++ /dev/null
@@ -1,47 +0,0 @@
-#include "trace_integrity.h"
-
-trace_integrity_main_ trace_integrity_main_t;
-
-static clib_error_t * initTraceIntegrity(void){
-    if ( ioam_trace_hdr_t->signature_suite == 0x01)
-        trace_integrity_main_t->encr_type = 1;
-
-    else if ( ioam_trace_hdr_t->signature_suite == 0x02)
-        trace_integrity_main_t->encr_type = 2; 
-    
-    switch (trace_integrity_main_t->encr_type)
-    {
-    case 1:
-        trace_integrity_main_t->eas256_pk = generatEAS256Keys();
-        break;
-    
-    case 2:
-        // to implement
-        break;
-    }
-    return 0;
-}
-
-char* hashing(char* data){
-    char buffer[SHA256_BLOCK_SIZE];
-    SHA256_CTX ctx;
-
-    sha256_init(&ctx);
-    sha256_update(&ctx, data, strlen(data));
-    sha256_final(&ctx, buffer);
-
-    return buffer;
-}
-
-uint8_t* signature(char* hash, char* prev_sign){
-    uint32_t returnlen = 0;
-    uint8_t *byteBuffer = (uint8_t*)malloc((uint32_t)MAX_MSG_LGTH);
-    uint8_t *returnBuffer = (uint8_t*)malloc((uint32_t)MAX_MSG_LGTH);
-
-    char* msg = strcat(hash, prev_sign);
-    str_to_bytes(msg, byteBuffer);
-    AES256MainECB(key, byteBuffer, strlen(message), returnBuffer, &returnlen, true);
-
-    return returnBuffer;
-}
-
diff --git a/updates/trace_integrity/trace_integrity.h b/updates/trace_integrity/trace_integrity.h
deleted file mode 100644
index c70fc9e..0000000
--- a/updates/trace_integrity/trace_integrity.h
+++ /dev/null
@@ -1,25 +0,0 @@
-#ifndef TRACE_INTEGRITY_H
-#define TRACE_INTEGRITY_H
-
-// add vpp library
-#include "../src/vlib"
-#include "../aes256/eas256.h"
-#include "../sha256/sha256.h"
-#include "../keys/Keys.h"
-#include "../crypto/utility/convert.h"
-
-typedef struct {
-    char* eas256_pk;
-    char* ecdsap256_pk;
-    char* ecdsap256_sk;
-    long encr_type;
-} trace_integrity_main_;
-
-extern trace_integrity_main_ trace_integrity_main_t;
-static clib_error_t * initTraceIntegrity(void);
-char* hashing(char* data);
-char* signature(char* hash, char* prev_sign);
-static clib_error_t * verify();
-
-
-#endif
\ No newline at end of file
diff --git a/vpp b/vpp
index abed0b8..a01be73 160000
--- a/vpp
+++ b/vpp
@@ -1 +1 @@
-Subproject commit abed0b8fb0ece7d98c66512b231b092a809a1f87
+Subproject commit a01be735f25a9a4596d3f67ef71a094e601e8b65
-- 
2.36.0.windows.1

